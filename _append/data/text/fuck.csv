Name,Description,Size,Script: On Execute,Gadget,Slots,NEED TOTAL?,Colour,Upgrade,Weaken,Alternate Status Trigger,SFX,Uses?,Cast Backwards?,Single use?,Tags,Witch Spell,Script: On Dodge,Script: Before Combat,Script: After Combat,Script: Before Start Turn,Script: On Start Turn,Script: End Turn,Script: On any equipment use,Script: Before execute,Script: On Snap,Script: On Fury,Script: On any countdown reduce
Pineapple,Do [fire]10 damage[;]|but then you explode,1,attack(10|FIRE); sfx(~magic_gaindice~); self.textparticle(~F~); self.x += 9000; self.y += 9000;,Time Stop,NORMAL,,RED,,,,_fire,0,NO,NO,,,,,,,,,,,,,
ooer,OH MAN I AM VERY NOT GOOD|WITH DICEY PLS TO HELP,1,var eqlist = self.getvar(~acceptable~); if(self.getvar(~stop~) != true) { if(!self.getvar(~caffeineused~)) { sfx(~yakety~); self.setvar(~caffeineused~|true); self.setvar(~cycle~|1); } self.x += rand([-15|-14|-13|-12|-11|-10|-9|-8|-7|-6|-5|-4|-3|-2|-1|1|2|3|4|5|6|7|8|9|10|11|12|13|14|15]); if(self.x < 0) { self.x = 0; } if(self.x > 2560) { self.x = 2560; } self.y += rand([-15|-14|-13|-12|-11|-10|-9|-8|-7|-6|-5|-4|-3|-2|-1|1|2|3|4|5|6|7|8|9|10|11|12|13|14|15]); if(self.y < 0) { self.y = 0; } if(self.y > 1500) { self.y = 1500; } target.x += rand([-15|-14|-13|-12|-11|-10|-9|-8|-7|-6|-5|-4|-3|-2|-1|1|2|3|4|5|6|7|8|9|10|11|12|13|14|15]);  if(target.x < 0) { target.x += 10; } if(target.x > 2560) { target.x -= 10; } target.y += rand([-15|-14|-13|-12|-11|-10|-9|-8|-7|-6|-5|-4|-3|-2|-1|1|2|3|4|5|6|7|8|9|10|11|12|13|14|15]); if(target.y < 0) { target.y += 10; } if(target.y > 1500) { target.y -= 10; } for(eq in eqlist) { eq.x += rand([-15|-14|-13|-12|-11|-10|-9|-8|-7|-6|-5|-4|-3|-2|-1|1|2|3|4|5|6|7|8|9|10|11|12|13|14|15]); if(eq.x < 0 && eq.ready()) { eq.x += 10; } if(eq.x > 2560 && eq.ready()) { eq.x -= 10; } eq.y += rand([-15|-14|-13|-12|-11|-10|-9|-8|-7|-6|-5|-4|-3|-2|-1|1|2|3|4|5|6|7|8|9|10|11|12|13|14|15]); if(eq.y < 0 && eq.ready()) { eq.y += 10; } if(eq.y > 1500 && eq.ready()) { eq.y -= 10; } if(self.getvar(~cycle~) == 8) { eq.equipmentcol = rand([0|2|3|4|5|8|9|11]); } } for(eq in target.equipment) { eq.x += rand([-15|-14|-13|-12|-11|-10|-9|-8|-7|-6|-5|-4|-3|-2|-1|1|2|3|4|5|6|7|8|9|10|11|12|13|14|15]); if(eq.x < 0 && eq.ready()) { eq.x += 10; } if(eq.x > 2560 && eq.ready()) { eq.x -= 10; } eq.y += rand([-15|-14|-13|-12|-11|-10|-9|-8|-7|-6|-5|-4|-3|-2|-1|1|2|3|4|5|6|7|8|9|10|11|12|13|14|15]); if(eq.y < 0 && eq.ready()) { eq.y += 10; } if(eq.y > 1500 && eq.ready()) { eq.y -= 10; } trace(self.getvar(~cycle~)); if(self.getvar(~cycle~) == 8) { eq.equipmentcol = rand([0|2|3|4|5|8|9|11]); } } if(self.getvar(~cycle~) == 8) { self.setvar(~cycle~|1); } self.setvar(~cycle~|self.getvar(~cycle~) + 1); self.equipmentused-=1; e.doequipmentaction(self|target|e.castdirection|[]|-1|true); },Bubble Gun,NORMAL,,PURPLE,,,,none,0,YES,NO,,1,,var acceptable = []; for(eq in self.equipment) { if(eq.name != ~ooer~) { acceptable.push(eq); } } self.setvar(~acceptable~|acceptable);,,e.setvar(~stop~|false);,,// e.setvar(~stop~|true);,,,,e.preventdefault = true; e.maintainfury = true;,
Hyperspeed,Next status inflicted is its|Parallel Universe variation,1,if(e.getslots() != []) { inflictself(~ncr_hyper~); var acceptablestats = [~silence~|~ice_all~|~fire_all~|~poison~|~fire~|~shock~|~ice~|~weaken~|~curse~|~blind~|~fury~|~lock~|~shield~|~reequipnext~|~dodge~|~thorns~|~confuse~|~counter_1~|~counter_2~|~counter_3~|~counter_4~|~counter_5~|~counter_6~|~dice_trigger_1~|~dice_trigger_2~|~dice_trigger_3~|~dice_trigger_4~|~dice_trigger_5~|~dice_trigger_6~|~reequipnext~|~survive~|~vampire~]; var statuslist = []; if(target.status.length > 0) { for(stat in target.status) { var copystat = new elements.StatusEffect(stat.type|stat.value); statuslist.push(copystat); } for(stat in statuslist) { if(acceptablestats.indexOf(stat.type) == -1) { statuslist.remove(stat); } } } self.setvar(~stored_tstatus~|statuslist); giveequipment(~Hyperspeed~); for(eq in self.equipment) { if(eq.name == ~Hyperspeed~ && eq.x == e.x && eq.y < 0) { eq.equipalpha = 0; eq.changeslots([]); } } } else { trace(~hi~); trace(target.status); var acceptablestats = [~silence~|~ice_all~|~fire_all~|~poison~|~fire~|~shock~|~ice~|~weaken~|~curse~|~blind~|~fury~|~lock~|~shield~|~reequipnext~|~dodge~|~thorns~|~confuse~|~counter_1~|~counter_2~|~counter_3~|~counter_4~|~counter_5~|~counter_6~|~dice_trigger_1~|~dice_trigger_2~|~dice_trigger_3~|~dice_trigger_4~|~dice_trigger_5~|~dice_trigger_6~|~reequipnext~|~survive~|~vampire~]; var oldstatlist = self.getvar(~stored_tstatus~); if(oldstatlist == 0 # oldstatlist == null) { oldstatlist = []; } var oldstatnames = []; var statstoremove = []; if(oldstatlist.length > 0) { for(stat in oldstatlist) { oldstatnames.push(stat.type); } } if(target.status.length > 0 && getstatusself(~ncr_hyper~) > 0) { for(stat in target.status) { if(acceptablestats.indexOf(stat.type) != -1) { if(oldstatlist.length == 0 ) { inflict(~alternate_~ + stat.type); statstoremove.push(stat.type); removestatusself(~ncr_hyper~); if(getstatusself(~ncr_hyper~) == 0) { break; } } else if(oldstatnames.indexOf(stat.type) == -1) { inflict(~alternate_~ + stat.type); statstoremove.push(stat.type); removestatusself(~ncr_hyper~); if(getstatusself(~ncr_hyper~) == 0) { break; } } else if(oldstatlist[oldstatnames.indexOf(stat.type)].value != stat.value) { inflict(~alternate_~ + stat.type); statstoremove.push(stat.type); removestatusself(~ncr_hyper~); if(getstatusself(~ncr_hyper~) == 0) { break; } } } } } if(statstoremove.length > 0) { for(stat in statstoremove) { removestatus(stat); } } },Overload,ODD,,PINK,,,,_mana,0,YES,NO,,,,,,,,self.resetvar(~stored_tstatus~);,trace(~aaa~); if(e.getvar(~counter~) == true) { trace(e.getslots()); trace(e.getslots().length); if(e.getslots() == [] # e.getslots().length == 0) { trace(~yo....~); e.timesused -= 1; self.equipmentused -= 1; e.setvar(~counter~|false); e.doequipmentaction(self|target|e.castdirection|[]|-1|true); } } else { e.setvar(~counter~|true); },,,,
Name Input Field,Please enter your name,1,bonus(-9999999999999); if(!simulation) {  var selfscript = ~removeequipment(\~Equipment That Does Nothing\~);~; if(self.scriptendturn.indexOf(selfscript) == -1) self.scriptendturn = selfscript + self.scriptendturn; self.name = ~~; givedice(d); e.destroydice(); self.setvar(~slotsbackup~|[]); self.setvar(~slotseqbackup~|[]); var slotsbackup = self.getvar(~slotsbackup~); var slotseqbackup = self.getvar(~slotseqbackup~); for(eq in self.equipment) {  eq.setvar(~standardcard~|1);  eq.removedice();  slotsbackup.push(eq.slots);  slotseqbackup.push(eq);  eq.slots = []; } self.setvar(~slotsbackup~|slotsbackup); self.setvar(~slotseqbackup~|slotseqbackup);  var buttonx = 100; var buttony = 400;  var charlist = [~A~|~B~|~C~|~D~|~E~|~F~|~G~|~H~|~I~|~J~|~K~|~L~|~M~|~N~|~O~|~P~|~Q~|~R~|~S~|~T~|~U~|~V~|~W~|~X~|~Y~|~Z~|~a~|~b~|~c~|~d~|~e~|~f~|~g~|~h~|~i~|~j~|~k~|~l~|~m~|~n~|~o~|~p~|~q~|~r~|~s~|~t~|~u~|~v~|~w~|~x~|~y~|~z~];  var i = 0;  for(char in charlist) {  i++;  var charholder = new elements.Equipment(~Equipment That Does Nothing~);  self.equipment.push(charholder);  charholder.script = ~self.equipmentused--;~;  charholder.slotpositions[0].y -= 153;  charholder.slotpositions[0].x -= 260;  charholder.displayname = char;  charholder.equipmentcol = 0;  if(char == char.toLowerCase()) charholder.displayname = ~[70%]~ + charholder.displayname;  charholder.fulldescription = ~~;  charholder.height = 270;  charholder.width = 270;  charholder.x = buttonx;  charholder.y = buttony;  charholder.equipalpha = 0.0;  buttonx += 270;  if(i == 13) {   buttonx = 160;   buttony += 270;  }  if(i == 26) {   buttonx = 100;   buttony += 300;  }  if(i == 39) {   buttonx = 160;   buttony += 270;  } }  buttonx = 1815; buttony += 300;  var confirmbutton = new elements.Equipment(~Equipment That Does Nothing~); self.equipment.push(confirmbutton); confirmbutton.equipmentcol = 2; confirmbutton.displayname = ~Confirm~; confirmbutton.slotpositions[0].y -= 153; confirmbutton.slotpositions[0].x -= 260; confirmbutton.fulldescription = ~~; confirmbutton.height = 270; confirmbutton.width = 270; confirmbutton.x = buttonx; confirmbutton.y = buttony; confirmbutton.equipalpha = 0.0; if(self.getvar(~phoneactuator~) != 0) self.getvar(~phoneactuator~).stop(); var tw = new motion.actuators.SimpleActuator(null|1/60|null); tw._repeat = -1; var s = new elements.Skill(~Against all odds_old~); s.script = ~  var phonedone = false;  for(eq in self.equipment) {   if(self.getvar(\~phonephase2\~) != 1) {    if(eq.equipalpha > 0.0 && eq.getvar(\~standardcard\~) == 1) eq.equipalpha -= 0.2;    if(eq.equipalpha < 1.0 && eq.getvar(\~standardcard\~) != 1) eq.equipalpha += 0.2;    if(eq.assigneddice.length > 0 && eq.assigneddice[0] != null) {     eq.removedice();     var neweq = eq.copy();         neweq.height = 270;     neweq.width = 270;     neweq.equipalpha = eq.equipalpha;     neweq.displayname = eq.displayname;     neweq.equipmentcol = eq.equipmentcol;     neweq.slotpositions = eq.slotpositions;     neweq.script = eq.script;     self.equipment.push(neweq);     eq.name = \~deleteme\~;     eq.slots = [];     eq.equipalpha = 0;     if(eq.displayname != \~Confirm\~) {      sfx(\~jackpot_increasecounter\~);      if(eq.displayname.substr(0|1) == \~[\~) self.name += eq.displayname.substr(5|1); else self.name += eq.displayname.substr(0|1);     }     else {      sfx(\~_thinghappens\~);      self.setvar(\~phonephase2\~|1);     }    }   }   else {    if(eq.equipalpha <= 1.0 && eq.getvar(\~standardcard\~) == 1) {     eq.equipalpha += 0.2;    }    if(eq.equipalpha > 0.0 && eq.getvar(\~standardcard\~) != 1) {     eq.removedice();     eq.equipalpha -= 0.2;     eq.slots = [];     eq.script = \~\~;    }    if(eq.equipalpha <= 0.0 && eq.getvar(\~standardcard\~) != 1) {     eq.name = \~deleteme\~;     phonedone = true;    }   }  }  removeequipment(\~deleteme\~);  if(self.doendturnnow # target.hp <= 0) {   trace(\~ending turn!\~);   for(eq in self.equipment) {    if(eq.getvar(\~standardcard\~) == 1) {     eq.equipalpha = 1.0;     eq.slots = self.getvar(\~slotsbackup\~)[self.getvar(\~slotseqbackup\~).indexOf(eq)];    }    else {     eq.name = \~deleteme\~;    }   }   removeequipment(\~deleteme\~); /*for some reason not everything gets named deleteme during cleanup*/   removeequipment(\~Equipment That Does Nothing\~);   self.resetvar(\~slotsbackup\~);   self.resetvar(\~slotseqbackup\~);   self.getvar(\~phoneactuator\~).stop();   self.resetvar(\~phonephase2\~);   self.resetvar(\~phoneactuator\~);  }  if(phonedone) {   for(eq in self.equipment) {    if(eq.equipalpha <= 1.0 && eq.getvar(\~standardcard\~) == 1) {     eq.equipalpha = 1.0;     eq.slots = self.getvar(\~slotsbackup\~)[self.getvar(\~slotseqbackup\~).indexOf(eq)];    }   }   removeequipment(\~Equipment That Does Nothing\~);   self.resetvar(\~slotsbackup\~);   self.resetvar(\~slotseqbackup\~);   self.getvar(\~phoneactuator\~).stop();   self.resetvar(\~phonephase2\~);   self.resetvar(\~phoneactuator\~);  } ~; tw.onRepeat(s.execute|[self|target]); self.setvar(~phoneactuator~|tw); tw.move(); },Identity Crisis,ODD,,,simplify,change_power,,,,YES,,excludefromrandomlists,,,,,,,for(eq in self.equipment) trace(eq.name);,,,,e.maintainfury = true; e.preventdefault = true;,
Name Input Field_downgraded,Please enter|the enemy's name,1,bonus(-9999999999999); if(!simulation) {  var selfscript = ~removeequipment(\~Equipment That Does Nothing\~);~; if(self.scriptendturn.indexOf(selfscript) == -1) self.scriptendturn = selfscript + self.scriptendturn; target.name = ~~; givedice(d); e.destroydice(); self.setvar(~slotsbackup~|[]); self.setvar(~slotseqbackup~|[]); var slotsbackup = self.getvar(~slotsbackup~); var slotseqbackup = self.getvar(~slotseqbackup~); for(eq in self.equipment) {  eq.setvar(~standardcard~|1);  eq.removedice();  slotsbackup.push(eq.slots);  slotseqbackup.push(eq);  eq.slots = []; } self.setvar(~slotsbackup~|slotsbackup); self.setvar(~slotseqbackup~|slotseqbackup);  var buttonx = 100; var buttony = 400;  var charlist = [~A~|~B~|~C~|~D~|~E~|~F~|~G~|~H~|~I~|~J~|~K~|~L~|~M~|~N~|~O~|~P~|~Q~|~R~|~S~|~T~|~U~|~V~|~W~|~X~|~Y~|~Z~|~a~|~b~|~c~|~d~|~e~|~f~|~g~|~h~|~i~|~j~|~k~|~l~|~m~|~n~|~o~|~p~|~q~|~r~|~s~|~t~|~u~|~v~|~w~|~x~|~y~|~z~];  var i = 0;  for(char in charlist) {  i++;  var charholder = new elements.Equipment(~Equipment That Does Nothing~);  self.equipment.push(charholder);  charholder.script = ~self.equipmentused--;~;  charholder.slotpositions[0].y -= 153;  charholder.slotpositions[0].x -= 260;  charholder.displayname = char;  charholder.equipmentcol = 0;  if(char == char.toLowerCase()) charholder.displayname = ~[70%]~ + charholder.displayname;  charholder.fulldescription = ~~;  charholder.height = 270;  charholder.width = 270;  charholder.x = buttonx;  charholder.y = buttony;  charholder.equipalpha = 0.0;  buttonx += 270;  if(i == 13) {   buttonx = 160;   buttony += 270;  }  if(i == 26) {   buttonx = 100;   buttony += 300;  }  if(i == 39) {   buttonx = 160;   buttony += 270;  } }  buttonx = 1815; buttony += 300;  var confirmbutton = new elements.Equipment(~Equipment That Does Nothing~); self.equipment.push(confirmbutton); confirmbutton.equipmentcol = 2; confirmbutton.displayname = ~Confirm~; confirmbutton.slotpositions[0].y -= 153; confirmbutton.slotpositions[0].x -= 260; confirmbutton.fulldescription = ~~; confirmbutton.height = 270; confirmbutton.width = 270; confirmbutton.x = buttonx; confirmbutton.y = buttony; confirmbutton.equipalpha = 0.0;  if(self.getvar(~phoneactuator~) != 0) self.getvar(~phoneactuator~).stop();  var tw = new motion.actuators.SimpleActuator(null|1/60|null); tw._repeat = -1; var s = new elements.Skill(~Against all odds_old~); s.script = ~  var phonedone = false;  for(eq in self.equipment) {   if(self.getvar(\~phonephase2\~) != 1) {    if(eq.equipalpha > 0.0 && eq.getvar(\~standardcard\~) == 1) eq.equipalpha -= 0.2;    if(eq.equipalpha < 1.0 && eq.getvar(\~standardcard\~) != 1) eq.equipalpha += 0.2;    if(eq.assigneddice.length > 0 && eq.assigneddice[0] != null) {     eq.removedice();     var neweq = eq.copy();         neweq.height = 270;     neweq.width = 270;     neweq.equipalpha = eq.equipalpha;     neweq.displayname = eq.displayname;     neweq.equipmentcol = eq.equipmentcol;     neweq.slotpositions = eq.slotpositions;     neweq.script = eq.script;     self.equipment.push(neweq);     eq.name = \~deleteme\~;     eq.slots = [];     eq.equipalpha = 0;     if(eq.displayname != \~Confirm\~) {      sfx(\~jackpot_increasecounter\~);      if(eq.displayname.substr(0|1) == \~[\~) target.name += eq.displayname.substr(5|1); else target.name += eq.displayname.substr(0|1);     }     else {      sfx(\~_thinghappens\~);      self.setvar(\~phonephase2\~|1);     }    }   }   else {    if(eq.equipalpha <= 1.0 && eq.getvar(\~standardcard\~) == 1) {     eq.equipalpha += 0.2;    }    if(eq.equipalpha > 0.0 && eq.getvar(\~standardcard\~) != 1) {     eq.removedice();     eq.equipalpha -= 0.2;     eq.slots = [];     eq.script = \~\~;    }    if(eq.equipalpha <= 0.0 && eq.getvar(\~standardcard\~) != 1) {     eq.name = \~deleteme\~;     phonedone = true;    }   }  }  removeequipment(\~deleteme\~);  if(self.doendturnnow # target.hp <= 0) {   trace(\~ending turn!\~);   for(eq in self.equipment) {    if(eq.getvar(\~standardcard\~) == 1) {     eq.equipalpha = 1.0;     eq.slots = self.getvar(\~slotsbackup\~)[self.getvar(\~slotseqbackup\~).indexOf(eq)];    }    else {     eq.name = \~deleteme\~;    }   }   removeequipment(\~deleteme\~); /*for some reason not everything gets named deleteme during cleanup*/   removeequipment(\~Equipment That Does Nothing\~);   self.resetvar(\~slotsbackup\~);   self.resetvar(\~slotseqbackup\~);   self.getvar(\~phoneactuator\~).stop();   self.resetvar(\~phonephase2\~);   self.resetvar(\~phoneactuator\~);  }  if(phonedone) {   for(eq in self.equipment) {    if(eq.equipalpha <= 1.0 && eq.getvar(\~standardcard\~) == 1) {     eq.equipalpha = 1.0;     eq.slots = self.getvar(\~slotsbackup\~)[self.getvar(\~slotseqbackup\~).indexOf(eq)];    }   }   removeequipment(\~Equipment That Does Nothing\~);   self.resetvar(\~slotsbackup\~);   self.resetvar(\~slotseqbackup\~);   self.getvar(\~phoneactuator\~).stop();   self.resetvar(\~phonephase2\~);   self.resetvar(\~phoneactuator\~);  } ~; tw.onRepeat(s.execute|[self|target]); self.setvar(~phoneactuator~|tw); tw.move(); },Identity Crisis,ODD,,,,,,,,,,excludefromrandomlists,,,,,,,,,,,e.maintainfury = true; e.preventdefault = true;,
Blackout,Never roll <d6>s this fight,2,if(!e.hastag(~donoeffectparticle~)) { screenshake(); sfx(~permadice~); } else { self.textparticle(~No effect!~); } /*sometimes this crashes and idk why*/,,NORMAL,,BLACK,reducesize,change_power,,,,,,excludefromrandomlists|curseavoid|unfinished,,,var dicerange = Rules.actualplayerdicerange.copy(); if(dicerange.length == 0) { dicerange = [1|2|3|4|5|6]; } self.setvar(~olddicerange~|dicerange);,Rules.playerdicerange(self.getvar(~olddicerange~));,e.removetag(~donoeffectparticle~);,,,,var dicerange = Rules.actualplayerdicerange.copy(); trace(dicerange); if(dicerange.length == 0) { dicerange = [1|2|3|4|5|6]; } if(dicerange.indexOf(d) == -1 # dicerange.length == 1) { e.addtag(~donoeffectparticle~); } else { while(dicerange.indexOf(d) != -1) { dicerange.remove(d); } trace(dicerange); Rules.playerdicerange(dicerange); },,,
Blackout_downgraded,Never roll <d6>s this fight,2,if(!e.hastag(~donoeffectparticle~)) { screenshake(); sfx(~permadice~); } else { self.textparticle(~No effect!~); },,MIN4,,BLACK,,,,,,,,excludefromrandomlists|curseavoid|unfinished,,,var dicerange = Rules.actualplayerdicerange.copy(); if(dicerange.length == 0) { dicerange = [1|2|3|4|5|6]; } self.setvar(~olddicerange~|dicerange);,Rules.playerdicerange(self.getvar(~olddicerange~));,e.removetag(~donoeffectparticle~);,,,,var dicerange = Rules.actualplayerdicerange.copy(); trace(dicerange); if(dicerange.length == 0) { dicerange = [1|2|3|4|5|6]; } if(dicerange.indexOf(d) == -1 # dicerange.length == 1) { e.addtag(~donoeffectparticle~); } else { while(dicerange.indexOf(d) != -1) { dicerange.remove(d); } trace(dicerange); Rules.playerdicerange(dicerange); },,,
Blackout_weakened,Never roll <d6>s this fight,1,if(!e.hastag(~donoeffectparticle~)) { screenshake(); sfx(~permadice~); } else { self.textparticle(~No effect!~); },,MIN4,,BLACK,,,,,,,,excludefromrandomlists|curseavoid|unfinished,,,var dicerange = Rules.actualplayerdicerange.copy(); if(dicerange.length == 0) { dicerange = [1|2|3|4|5|6]; } self.setvar(~olddicerange~|dicerange);,Rules.playerdicerange(self.getvar(~olddicerange~));,e.removetag(~donoeffectparticle~);,,,,var dicerange = Rules.actualplayerdicerange.copy(); trace(dicerange); if(dicerange.length == 0) { dicerange = [1|2|3|4|5|6]; } if(dicerange.indexOf(d) == -1 # dicerange.length == 1) { e.addtag(~donoeffectparticle~); } else { while(dicerange.indexOf(d) != -1) { dicerange.remove(d); } trace(dicerange); Rules.playerdicerange(dicerange); },,,
Old Maid,Do [sword]<d6> damage. On 6[;]|permanently swap this with|the last card the enemy used,2,attack(d); sfxdamage(target|d); if(d == 6) { if(!simulation) { for(eq in self.equipment) { eq.setvar(~alreadyheretemp~|1); } trace(~checks~); trace((self.getvar(~oldmaidtarget~) + 1) == ~Equipment1~); trace(self.getvar(~oldmaidtarget~) + 1); trace(target.equipment.indexOf(self.getvar(~oldmaidtarget~))); trace(self.getvar(~oldmaidtarget~).name); trace(self.getvar(~oldmaidtarget~).name != ~Old Maid~); if((self.getvar(~oldmaidtarget~) + 1) == ~Equipment1~ && target.equipment.indexOf(self.getvar(~oldmaidtarget~)) != -1 && self.getvar(~oldmaidtarget~).name != ~Old Maid~)  { sfx(~_curse~|~~|0.2); giveequipment(self.getvar(~oldmaidtarget~).name|true|false); giveenemyequipment(~Old Maid~|false|false); self.getvar(~oldmaidtarget~).name = ~deleteme~; removeequipment(~deleteme~|target); self.resetvar(~oldmaidtarget~);    for(eq in self.equipment) { if(eq.getvar(~alreadyheretemp~) != 1) { self.setvar(~doonthis~|eq); var estandardize = ~var e = self.getvar(\~doonthis\~); ~; var doscripts = new elements.Skill(~Against all odds_old~); doscripts.script = estandardize + eq.scriptbeforecombat; doscripts.execute(self|target); doscripts.script = estandardize + eq.scriptbeforestartturn; doscripts.execute(self|target); doscripts.script = estandardize + eq.scriptonstartturn; doscripts.execute(self|target); self.resetvar(~doonthis~); break; } }  e.name = ~deleteme~; removeequipment(~deleteme~); }  else { self.textparticle(~No effect!~); } for(eq in self.equipment) { eq.resetvar(~alreadyheretemp~); } } else { bonus(10000); } },Comedy,NORMAL,,GRAY,change_power,change_power,,none,,,,excludefromrandomlists|unfinished,,,var injectstring = ~/*NCR INJECTION*/ self.resetvar(\~oldmaidtarget\~); if(target != null) target.resetvar(\~oldmaidtarget\~); /*NCR INJECTION END*/~; if(self.scriptaftercombat.indexOf(injectstring) == -1) { self.scriptaftercombat = injectstring + self.scriptaftercombat; },,,,var injectstring = ~/*NCR INJECTION*/ if(!simulation && e.skillcard == \~\~) { target.setvar(\~oldmaidtarget\~|e); trace(target.getvar(\~oldmaidtarget\~).name); } /*NCR INJECTION END*/~; for(eq in target.equipment) { if(eq.script.indexOf(injectstring) == -1) { eq.script = injectstring + eq.script; } } for(eq in self.equipment) { if(eq.script.indexOf(injectstring) == -1) { eq.script = injectstring + eq.script; } },,,,,
Old Maid_upgraded,Do [sword]<d6> damage. On 6[;]|permanently swap this with|the last card the enemy used,2,attack(d); sfxdamage(target|d); if(d == 6) { if(!simulation) { for(eq in self.equipment) { eq.setvar(~alreadyheretemp~|1); } trace(~checks~); trace((self.getvar(~oldmaidtarget~) + 1) == ~Equipment1~); trace(self.getvar(~oldmaidtarget~) + 1); trace(target.equipment.indexOf(self.getvar(~oldmaidtarget~))); trace(self.getvar(~oldmaidtarget~).name); trace(self.getvar(~oldmaidtarget~).name != ~Old Maid~); if((self.getvar(~oldmaidtarget~) + 1) == ~Equipment1~ && target.equipment.indexOf(self.getvar(~oldmaidtarget~)) != -1 && self.getvar(~oldmaidtarget~).name != ~Old Maid~)  { sfx(~_curse~|~~|0.2); giveequipment(self.getvar(~oldmaidtarget~).name|true|false); giveenemyequipment(~Old Maid~|false|false); self.getvar(~oldmaidtarget~).name = ~deleteme~; removeequipment(~deleteme~|target); self.resetvar(~oldmaidtarget~);    for(eq in self.equipment) { if(eq.getvar(~alreadyheretemp~) != 1) { self.setvar(~doonthis~|eq); var estandardize = ~var e = self.getvar(\~doonthis\~); ~; var doscripts = new elements.Skill(~Against all odds_old~); doscripts.script = estandardize + eq.scriptbeforecombat; doscripts.execute(self|target); doscripts.script = estandardize + eq.scriptbeforestartturn; doscripts.execute(self|target); doscripts.script = estandardize + eq.scriptonstartturn; doscripts.execute(self|target); self.resetvar(~doonthis~); break; } }  e.name = ~deleteme~; removeequipment(~deleteme~); }  else { self.textparticle(~No effect!~); } for(eq in self.equipment) { eq.resetvar(~alreadyheretemp~); } } else { bonus(10000); } },Comedy,REQUIRE6,,GRAY,,,,none,,,,excludefromrandomlists|unfinished,,,var injectstring = ~/*NCR INJECTION*/ self.resetvar(\~oldmaidtarget\~); if(target != null) target.resetvar(\~oldmaidtarget\~); /*NCR INJECTION END*/~; if(self.scriptaftercombat.indexOf(injectstring) == -1) { self.scriptaftercombat = injectstring + self.scriptaftercombat; },,,,var injectstring = ~/*NCR INJECTION*/ if(!simulation && e.skillcard == \~\~) { target.setvar(\~oldmaidtarget\~|e); trace(target.getvar(\~oldmaidtarget\~).name); } /*NCR INJECTION END*/~; for(eq in target.equipment) { if(eq.script.indexOf(injectstring) == -1) { eq.script = injectstring + eq.script; } } for(eq in self.equipment) { if(eq.script.indexOf(injectstring) == -1) { eq.script = injectstring + eq.script; } },,,,,
Old Maid_downgraded,Permanently swap this with|the last card the enemy used,2,if(true) { if(!simulation) { for(eq in self.equipment) { eq.setvar(~alreadyheretemp~|1); } trace(~checks~); trace((self.getvar(~oldmaidtarget~) + 1) == ~Equipment1~); trace(self.getvar(~oldmaidtarget~) + 1); trace(target.equipment.indexOf(self.getvar(~oldmaidtarget~))); trace(self.getvar(~oldmaidtarget~).name); trace(self.getvar(~oldmaidtarget~).name != ~Old Maid~); if((self.getvar(~oldmaidtarget~) + 1) == ~Equipment1~ && target.equipment.indexOf(self.getvar(~oldmaidtarget~)) != -1 && self.getvar(~oldmaidtarget~).name != ~Old Maid~)  { sfx(~_curse~|~~|0.2); giveequipment(self.getvar(~oldmaidtarget~).name|true|false); giveenemyequipment(~Old Maid~|false|false); self.getvar(~oldmaidtarget~).name = ~deleteme~; removeequipment(~deleteme~|target); self.resetvar(~oldmaidtarget~);    for(eq in self.equipment) { if(eq.getvar(~alreadyheretemp~) != 1) { self.setvar(~doonthis~|eq); var estandardize = ~var e = self.getvar(\~doonthis\~); ~; var doscripts = new elements.Skill(~Against all odds_old~); doscripts.script = estandardize + eq.scriptbeforecombat; doscripts.execute(self|target); doscripts.script = estandardize + eq.scriptbeforestartturn; doscripts.execute(self|target); doscripts.script = estandardize + eq.scriptonstartturn; doscripts.execute(self|target); self.resetvar(~doonthis~); break; } }  e.name = ~deleteme~; removeequipment(~deleteme~); }  else { self.textparticle(~No effect!~); } for(eq in self.equipment) { eq.resetvar(~alreadyheretemp~); } } else { bonus(10000); } },Comedy,REQUIRE6,,GRAY,,,,none,,,,excludefromrandomlists|unfinished,,,var injectstring = ~/*NCR INJECTION*/ self.resetvar(\~oldmaidtarget\~); if(target != null) target.resetvar(\~oldmaidtarget\~); /*NCR INJECTION END*/~; if(self.scriptaftercombat.indexOf(injectstring) == -1) { self.scriptaftercombat = injectstring + self.scriptaftercombat; },,,,var injectstring = ~/*NCR INJECTION*/ if(!simulation && e.skillcard == \~\~) { target.setvar(\~oldmaidtarget\~|e); trace(target.getvar(\~oldmaidtarget\~).name); } /*NCR INJECTION END*/~; for(eq in target.equipment) { if(eq.script.indexOf(injectstring) == -1) { eq.script = injectstring + eq.script; } } for(eq in self.equipment) { if(eq.script.indexOf(injectstring) == -1) { eq.script = injectstring + eq.script; } },,,,,
beep,beep|,1,attack(2); sfxdamage(target|2);,,COUNTDOWN,5,,,,,,-1,,,testitem|excludefromrandomlists,,,,,,,,,,,,
revolver 2,the sequel|,1,self.setvar(~ereference~|e); var tw = new motion.actuators.SimpleActuator(null|0.01|null); var s = new elements.Skill(~Against all odds_old~); s.script = ~var e = self.getvar(\~ereference\~); if(e.dicehistory.length == 0) { e.dicehistory = self.getvar(\~diceshit\~); } var sum = 0; trace(e.dicehistory); for(dice in e.dicehistory) { sum += dice.basevalue; if(sum > e.countdown) break; } if(sum - e.countdown > 0) { attack((sum - e.countdown) * 2); sfxdamage(target|(sum - e.countdown) * 2); } else { self.textparticle(\~No effect!\~); } self.resetvar(\~ereference\~);~; tw.onComplete(s.execute|[self|target]); tw.move();,Oh Shit!,COUNTDOWN,9,,,,,,-1,,,testitem|excludefromrandomlists,,,,,,,,,,,,
Gravity,Get a lower dice|[gray](Reuseable),1,givedice(rand([1|2|3|4|5|6].splice(0|d))); /*awful when you're literally anyone but inventor... or if you're inventor and have a build designed around 6s*/,Mirror Smash,REQUIRE6,,GREEN,change_power,change_power,,,-1,YES,,,,,,,,,,,,,,
Gravity_upgraded,Get a lower dice[;] do [sword]1 dmg|[gray](Reuseable),1,attack(1); sfxdamage(target|1); givedice(rand([1|2|3|4|5|6].splice(0|d)));,Mirror Smash,REQUIRE6,,GREEN,,,,,-1,,,,,givedice(rand([1|2|3|4|5|6].splice(0|d)));,,,,,,,,,,
Gravity_downgraded,Get three lower dice|[gray](Reuseable),1,givedice([rand([1|2|3|4|5|6].splice(0|actualdice[0].basevalue))|rand([1|2|3|4|5|6].splice(0|actualdice[1].basevalue))|rand([1|2|3|4|5|6].splice(0|actualdice[2].basevalue))]);,Mirror Smash,REQUIRE6|REQUIRE6|REQUIRE6,,GREEN,,,,,-1,YES,,,,,,,,,,,,,,
Bookmark,Do [sword]<d6> damage. On 6[;]|temporarily replace Bookmark|with a new[;] random spell,1,/*ability to cancel spells makes this 'on 6; get a new dice' unless i were to track if the spell was cancelled somehow via actuator which sounds dumb and icky*/ attack(d); sfxdamage(target|d); if(d == 6) { var acceptablevalues = []; for(i in 1...7) if(!Spellbook.isempty(i)) acceptablevalues.push(i); if(acceptablevalues.length > 0 && self.getskillcard().skillcard == ~witch~) { var castdice = new elements.Dice(); castdice.basevalue = rand(acceptablevalues); self.getskillcard().assigndice(castdice); sfx(~_thinghappens~|~~|0.2); } else self.textparticle(~Uhh...~); },Stardust,NORMAL,,GREEN,change_power,change_power,,none,,,,witchonly,1,,,,,,,,,,,
Bookmark_upgraded,Do [sword]<d6> damage[;] then|temporarily replace Bookmark|with a new[;] random spell,1,attack(d); sfxdamage(target|d); if(d > 3) { var acceptablevalues = []; for(i in 1...7) if(!Spellbook.isempty(i)) acceptablevalues.push(i); if(acceptablevalues.length > 0 && self.getskillcard().skillcard == ~witch~) { var castdice = new elements.Dice(); castdice.basevalue = rand(acceptablevalues); self.getskillcard().assigndice(castdice); sfx(~_thinghappens~|~~|0.2); } else self.textparticle(~Uhh...~); },Stardust,NORMAL,,GREEN,,,,none,,,,witchonly,,,,,,,,,,,,
Bookmark_downgraded,Do [sword]<d6> damage,1,attack(d); sfxdamage(target|d);,Stardust,NORMAL,,GREEN,,,,none,,,,witchonly,,,,,,,,,,,,
Tap,Snap the card to the right|of this[;] if it's available,2,/*old version of tap; which i think would be slightly more robust than mystic's implementation if i got multislot cards working right with it*/,Less Fluff,EVEN,,ORANGE,simplify,complicate,,none,,YES,,,,,,,,,,,var snapcard = null; var altequipment = [for(eq in self.equipment) if(eq.onscreen()) eq]; trace(altequipment); var _snapcard = null; if(self.layout == ~DECK~) { _snapcard = altequipment[altequipment.indexOf(e) + 1]; } else { var mycolumn = e.column; trace(mycolumn); for(eq in altequipment) { trace(eq.displayname + ~ ~ + eq.column); if(eq.column == mycolumn + 1 && eq.get_slotsfree() > 0) { _snapcard = eq; break; } else if(eq.column == mycolumn + 1 && eq.name == ~Thief Stolen Card~ && self.stolencard != null && self.stolencard.onscreen() && self.stolencard.get_slotsfree() > 0) { _snapcard = self.stolencard; break; } } } trace(_snapcard); if(_snapcard != null) snapcard = _snapcard; if(snapcard != null && snapcard.onscreen() && snapcard.isready() && snapcard.slots.length > 0) { sfx(~jester_snap~); snapcard.animate(~snap~); var i = 0; for(slot in snapcard.slots) { trace(snapcard.slots); trace(slot); var snapvalue = 6; if(slot == ~ODD~) snapvalue = 5; if((slot + ~~).substr(0|3) == ~MAX~) snapvalue = (slot + ~~).substr(3|1) - 0; if((slot + ~~).substr(0|5) == ~RANGE~) snapvalue = (slot + ~~).substr(5|1) - 0; if((slot + ~~).substr(0|7) == ~REQUIRE~) snapvalue = (slot + ~~).substr(7|1) - 0; if(snapcard.remainingcountdown > 6) snapcard.remainingcountdown = 6; var snapdice = new elements.Dice(); snapdice.basevalue = snapvalue; self.dicepool.push(snapdice); snapcard.assigndice(snapdice|i); if(snapcard.remainingcountdown == 0 && (snapcard.needstotal == 0 # snapcard.needstotal == snapcard.getpower()) && (!snapcard.needsdoubles # [for(dice in snapcard.assigneddice) dice.basevalue == 6].indexOf(false) == -1)) { snapcard.doequipmentaction(self|target|1|snapcard.assigneddice|0|false|true); } } } else { self.textparticle(~No effect!~); } /*high concept donated by cody*/,,e.preventdefault = true; e.maintainfury = true;,
Book Bash,Do [sword]2 damage[;] put|this dice in your spellbook|[gray](Reuseable),1,/*ability to cancel spells makes this an infinite*/ attack(2); sfxdamage(target|2); trace(self.getskillcard().skillcard); if(self.getskillcard().skillcard == ~witch~) self.getskillcard().assigndice(actualdice[0]); else self.textparticle(~Uhh...~); /*originally this was 3 dmg; one use. jacke said it was too much like keyblade and could be 1 dmg reusable; like a passive that does 1 dmg every time you insert a spell at the cost of taking up a spell slot. this is a compromise (also the latter would probably cost 2 to cast)*/,Stardust,NORMAL,,GREEN,change_power,removereusable,,none,2,,,witchonly,1,,,,,,,,,e.maintainfury = true; e.preventdefault = true;,,
Book Bash_upgraded,Do [sword]1 damage[;] put|this dice in your spellbook|[gray](Reuseable),1,attack(1); sfxdamage(target|1); trace(self.getskillcard().skillcard); if(self.getskillcard().skillcard == ~witch~) self.getskillcard().assigndice(actualdice[0]); else self.textparticle(~Uhh...~);,Stardust,NORMAL,,GREEN,,,,none,4,,,witchonly,,,,,,,,,,e.maintainfury = true; e.preventdefault = true;,,
