Name,Displayed As,Symbol,Description,Stacks?,Remove at End Turn?,Remove at Start Turn?,Invisible?,Blocked by Reduce?,Script: When inflicted,Script: On any status infliction,Script: Before Start Turn,Script: On Start Turn,Script: On any equipment use,Script: On any countdown reduce,Script: End Turn,Script: After Combat,Script: On damage inflicted,Script: On damage taken,Script: On status remove
reversenexttarget,Swap_Next_Target,recycle,The next equipment you use will swap target.,YES,YES,NO,NO,NO,,,,,,,,,,,
ncr_lightswitch1,Light_Switch_1,dice,Roll an extra 1 next turn.,NO,NO,YES,NO,NO,,,,,,,,,,,
ncr_lightswitch2,Light_Switch_2,dice,Roll an extra 2 next turn.,NO,NO,YES,NO,NO,,,,,,,,,,,
ncr_lightswitch3,Light_Switch_3,dice,Roll an extra 3 next turn.,NO,NO,YES,NO,NO,,,,,,,,,,,
ncr_lightswitch4,Light_Switch_4,dice,Roll an extra 4 next turn.,NO,NO,YES,NO,NO,,,,,,,,,,,
ncr_lightswitch5,Light_Switch_5,dice,Roll an extra 5 next turn.,NO,NO,YES,NO,NO,,,,,,,,,,,
ncr_lightswitch6,Light_Switch_6,dice,Roll an extra 6 next turn.,NO,NO,YES,NO,NO,,,,,,,,,,,
ncr_vanish,Vanish,vanish,Up to <value> duplicate dice are immediately destroyed.,YES,YES,NO,NO,YES,var skipsetup = false; var noeffect = false;  if(self.status.length > 0) for(stat in self.status) { if(stat.type == ~ncr_vanish~) skipsetup = true; if(stat.type == ~vanish~) noeffect = true; } if((self.getvar(~vanishactuator~) + 1 == ~SimpleActuator1~) # (target.getvar(~vanishactuator~) + 1 == ~SimpleActuator1~)) skipsetup = true; trace(skipsetup); trace(noeffect); if(skipsetup) trace(~skipping setup~); if(noeffect) { self.textparticle(~No effect!~); removestatusself(~ncr_vanish~|ALL); } else if(!skipsetup) {  trace(~starting vanish actuator~);  var tw = new motion.actuators.SimpleActuator(null|1/60|null);  tw._repeat = -1;  var s = new elements.Skill(~Against all odds_old~);  s.script = ~   if(self.hp <= 0 # self.graphic == null # target == null # target.graphic == null # target.hp <= 0) {    trace(\~vanish actuator stopped\~);    self.getvar(\~vanishactuator\~).stop();    self.resetvar(\~vanishactuator\~);   }   else {    if(self.dicepool.length > 0 && self.hasstatus(\~ncr_vanish\~)) {     var hasvalue = [false|false|false|false|false|false|false];     var dicevanished = false;     for (i in 0 ... self.dicepool.length){      if (self.dicepool[i].available()){       if (!self.dicepool[i].intween()){        if (!hasvalue[self.dicepool[i].basevalue]){         hasvalue[self.dicepool[i].basevalue] = true;        }else{         self.dicepool[i].animate(\~disappear\~);         dicevanished = true;         trace(\~decrementing self vanish\~);         removestatusself(\~ncr_vanish\~|1);         if(!self.hasstatus(\~ncr_vanish\~)) { trace(\~breaking vanish for self\~); break; }        }       }      }     }     if (dicevanished){      sfx(\~_diceburn\~);     }    }    if(target != null && target.dicepool.length > 0 && target.hasstatus(\~ncr_vanish\~)) {     var hasvalue = [false|false|false|false|false|false|false];     var dicevanished = false;     for (i in 0 ... target.dicepool.length){      if (target.dicepool[i].available()){       if (!target.dicepool[i].intween()){        if (!hasvalue[target.dicepool[i].basevalue]){         hasvalue[target.dicepool[i].basevalue] = true;        }else{         target.dicepool[i].animate(\~disappear\~);         target.dicepool[i].canbedragged = false;         dicevanished = true;         trace(\~decrementing target vanish\~);         removestatus(\~ncr_vanish\~|1);         if(!target.hasstatus(\~ncr_vanish\~)){ trace(\~breaking vanish for target\~); break; }        }       }      }     }     if (dicevanished){      sfx(\~_diceburn\~);     }    }   }  ~;  if(self.isplayer) s.execute(self|target); else s.execute(target|self);  if(self.isplayer) tw.onRepeat(s.execute|[self|target]); else tw.onRepeat(s.execute|[target|self]);  if(self.isplayer) self.setvar(~vanishactuator~|tw); else target.setvar(~vanishactuator~|tw);  tw.move(); },,,,,,,,,,
ncr_lessfluff,Less_Fluff,cog,The next card you use is immediately gadgetized.,NO,YES,NO,NO,NO,,,,,,,,,,,
ncr_injection,Script_Injection,cog,Next card you use will do damage equal to|the dice inserted before its normal effect.,YES,NO,NO,NO,NO,,,,,,,,,,,
ncr_invisiblehook,Invisible_Hook,silence,You shouldn't be seeing this[;] it's an internal thing.,YES,NO,NO,YES,NO,,,,,,,,,,,
ncr_hyper,Hyperspeed,confuse,Convert the next status you inflict to its Parallel Universe version.,YES,YES,NO,NO,NO,,,,,,,,,,,
alternate_ncr_hyper,Hyperspeed?,confuse,Convert the next status you inflict to its non-Parallel Universe version.,YES,YES,NO,NO,NO,,,,,,,,,,,
ncr_poisontemp,Poisontemp,cog,You shouldn't be seeing this description.|Go yell at ncrecc,YES,YES,NO,NO,NO,,,,,,,,,,,
ncr_error,Error,curse,At the start of your turn[;] a random item will error out[;]|rendering it unusable for that turn.,YES,YES,NO,NO,YES,if(self.dicepool.length > 0) { /*kludge to detect whether it's this fighter's turn*/ var erroreq = []; if(self.equipment.length > 0) { for(eq in self.equipment) { if(eq.hastag(~errorimmune~) == false && eq.skillcard == ~~ && eq.isready()) { erroreq.push(eq); } } roboterror(self|[rand(erroreq)]); } },,,var erroramt = status.value; var erroreq = []; if(self.equipment.length > 0) { for(eq in self.equipment) { if(eq.hastag(~errorimmune~) == false && eq.skillcard == ~~ && eq.isready()) { erroreq.push(eq); } } while(erroramt > 0) { var pickedeq = rand(erroreq); roboterror(self|[pickedeq]); erroreq.remove(pickedeq); if(erroreq.length < 1) break; erroramt--; } },,,,,,,
ncr_silence,Silence,silence,Temporarily disables your most important equipment.|Can use two dice to unsilence.,NO,YES,NO,NO,YES,/*as it turns out megaquest ALSO has a custom silence implementation for enemies... i think my 'most important card' thing is a bit nicer though. anyway i need to actually play megaquest some time; the betas i got of it were rather frustrating and unfair but my feedback probably helped*/ if(self.isplayer) { var tw = new motion.actuators.SimpleActuator(null|0.01|null); var s = new elements.Skill(~Against all odds_old~); s.script = ~  removestatus(\~ncr_silence\~|ALL); inflict(SILENCE); ~; tw.onComplete(s.execute|[target|self]); tw.move(); } else { self.symbolparticle(~silence~); },,,if(self.equipment.length > 0) {  var eqtosilence = null;  var eqstosort = [];  var exceptions = loaddata(~ncrmod/silenceexceptions~);  for(enemy in exceptions) { trace(self.name); trace(enemy.enemyname); if(self.name == enemy.enemyname) {   for(eq in self.equipment) { trace(enemy.importantcard); trace(eq.name); if(eq.name == enemy.importantcard) { eqstosort.push(eq); eqtosilence = eq; break; } }   if(eqtosilence == null) for(eq in self.equipment) if(eq.name == enemy.importantcard2) { eqstosort.push(eq); eqtosilence = eq; break; }  } }  if(eqtosilence == null) {   var never = [for(card in loaddata(~ncrmod/silencecardexceptions~)) if(card.priority == ~never~) card.cardname];   var always = [for(card in loaddata(~ncrmod/silencecardexceptions~)) if(card.priority == ~always~) card.cardname];   eqstosort = [for(eq in self.equipment) if(eq.isready() && never.indexOf(eq.name) == -1 && eq.shockedsetting != 2) eq];   var eqstosort2 = [];   if(eqstosort.length > 0) for(eq in eqstosort) if(always.indexOf(eq.name) != -1) eqstosort2.push(eq);   if(eqstosort2.length > 0) eqstosort = eqstosort2;   if(eqstosort.length == 1) eqtosilence = eqstosort[0];   if(eqtosilence == null && eqstosort.length > 0) {    var largeeqs = [for(eq in eqstosort) if(eq.size == 2) eq];    if(largeeqs.length > 0) eqstosort = largeeqs;    if(eqstosort.length == 1) eqtosilence = eqstosort[0];    if(eqtosilence == null) {     var sorton = ~~;     for(eq in eqstosort) {      if(eq.usesleft > 0 # (eq.usesleft == -1 && !eq.hastag(~hidereuseable~))) {       sorton = ~uses~; break;      }     }     if(sorton == ~~) for(eq in eqstosort) {      if(eq.countdown > 0) {       sorton = ~cd~; break;      }     }     if(sorton == ~~) for(eq in eqstosort) {      if(eq.getslots().length > 0 && !eq.getslots()[0].substr(0|7) == ~REQUIRE~) {       sorton = ~normal~; break;      }     }     if(sorton == ~~) sorton = ~needsx~;     trace(sorton);     var max = null;     if(sorton == ~normal~) max = eqstosort[0];     for(eq in eqstosort) {      if(sorton == ~uses~) {       if(eq.usesleft == -1) {        max = eq; break;       }       else if(max == null # eq.usesleft > max.usesleft) {        max = eq;       }      }      if(sorton == ~cd~) {       if(max == null # eq.countdown > max.countdown) {        max = eq;       }      }      if(sorton == ~needsx~) {       if(max == null # (eq.getslots().length > 0 && eq.getslots()[0].substr(0|7) == ~REQUIRE~ && (max.getslots.length == 0) # (max.getslots()[0].substr(0|7) != ~REQUIRE~)) # (eq.getslots().length > 0 && eq.getslots()[0].substr(0|7) == ~REQUIRE~ && (eq.getslots()[0].substr(7|0) - 0) > (max.getslots()[0].substr(7|0) - 0))) {        max = eq;       }      }     }     if(max != null) eqtosilence = max;    }   }  }  if(eqtosilence == null && eqstosort.length > 0) { trace(~what the fuck~); eqtosilence = eqstosort[0]; }  if(eqtosilence == null && eqstosort.length == 0) { trace(~what went on here~); eqtosilence = self.equipment[0]; }  if(getstatusself(~alternate_ncr_silence~) > 0) { eqtosilence.downgrade(); eqtosilence.animate(~flashandshake~); eqtosilence.animation[eqtosilence.animation.length - 1].addcommand(~textparticle~[;] ~[silence] Silenced!~[;] 16777215); sfx(~apply_silence_to_equipment~); } else if(getstatusself(~ncr_silence~) > 0) { eqtosilence.shockedsetting = 0; eqtosilence.animate(~silence~); } },,,,,,,
alternate_ncr_silence,Silence?!,silence,Temporarily weakens your most important equipment.|Equipment becomes less powerful.,NO,YES,NO,NO,YES,if(self.isplayer) { var tw = new motion.actuators.SimpleActuator(null|0.01|null); var s = new elements.Skill(~Against all odds_old~); s.script = ~  removestatus(\~ncr_silence\~|ALL); inflict(\~alternate_silence\~); ~; tw.onComplete(s.execute|[target|self]); tw.move(); } else { self.symbolparticle(~silence~); },,,if(self.equipment.length > 0) {  var eqtosilence = null;  var eqstosort = [];  var exceptions = loaddata(~ncrmod/silenceexceptions~);  for(enemy in exceptions) { trace(self.name); trace(enemy.enemyname); if(self.name == enemy.enemyname) {   for(eq in self.equipment) { trace(enemy.importantcard); trace(eq.name); if(eq.name == enemy.importantcard) { eqstosort.push(eq); eqtosilence = eq; break; } }   if(eqtosilence == null) for(eq in self.equipment) if(eq.name == enemy.importantcard2) { eqstosort.push(eq); eqtosilence = eq; break; }  } }  if(eqtosilence == null) {   var never = [for(card in loaddata(~ncrmod/silencecardexceptions~)) if(card.priority == ~never~) card.cardname];   var always = [for(card in loaddata(~ncrmod/silencecardexceptions~)) if(card.priority == ~always~) card.cardname];   eqstosort = [for(eq in self.equipment) if(eq.isready() && never.indexOf(eq.name) == -1 && eq.shockedsetting != 2) eq];   var eqstosort2 = [];   if(eqstosort.length > 0) for(eq in eqstosort) if(always.indexOf(eq.name) != -1) eqstosort2.push(eq);   if(eqstosort2.length > 0) eqstosort = eqstosort2;   if(eqstosort.length == 1) eqtosilence = eqstosort[0];   if(eqtosilence == null && eqstosort.length > 0) {    var largeeqs = [for(eq in eqstosort) if(eq.size == 2) eq];    if(largeeqs.length > 0) eqstosort = largeeqs;    if(eqstosort.length == 1) eqtosilence = eqstosort[0];    if(eqtosilence == null) {     var sorton = ~~;     for(eq in eqstosort) {      if(eq.usesleft > 0 # (eq.usesleft == -1 && !eq.hastag(~hidereuseable~))) {       sorton = ~uses~; break;      }     }     if(sorton == ~~) for(eq in eqstosort) {      if(eq.countdown > 0) {       sorton = ~cd~; break;      }     }     if(sorton == ~~) for(eq in eqstosort) {      if(eq.getslots().length > 0 && !eq.getslots()[0].substr(0|7) == ~REQUIRE~) {       sorton = ~normal~; break;      }     }     if(sorton == ~~) sorton = ~needsx~;     trace(sorton);     var max = null;     if(sorton == ~normal~) max = eqstosort[0];     for(eq in eqstosort) {      if(sorton == ~uses~) {       if(eq.usesleft == -1) {        max = eq; break;       }       else if(max == null # eq.usesleft > max.usesleft) {        max = eq;       }      }      if(sorton == ~cd~) {       if(max == null # eq.countdown > max.countdown) {        max = eq;       }      }      if(sorton == ~needsx~) {       if(max == null # (eq.getslots().length > 0 && eq.getslots()[0].substr(0|7) == ~REQUIRE~ && (max.getslots.length == 0) # (max.getslots()[0].substr(0|7) != ~REQUIRE~)) # (eq.getslots().length > 0 && eq.getslots()[0].substr(0|7) == ~REQUIRE~ && (eq.getslots()[0].substr(7|0) - 0) > (max.getslots()[0].substr(7|0) - 0))) {        max = eq;       }      }     }     if(max != null) eqtosilence = max;    }   }  }  if(eqtosilence == null && eqstosort.length > 0) { trace(~what the fuck~); eqtosilence = eqstosort[0]; }  if(eqtosilence == null && eqstosort.length == 0) { trace(~what went on here~); eqtosilence = self.equipment[0]; }  if(getstatusself(~alternate_ncr_silence~) > 0) { eqtosilence.downgrade(); eqtosilence.animate(~flashandshake~); eqtosilence.animation[eqtosilence.animation.length - 1].addcommand(~textparticle~[;] ~[silence] Silenced!~[;] 16777215); sfx(~apply_silence_to_equipment~); } else if(getstatusself(~ncr_silence~) > 0) { eqtosilence.shockedsetting = 0; eqtosilence.animate(~silence~); } },,,,,,,
ncr_dummysilence,Silence,silence,Cannot use special character skills or limit breaks.,NO,YES,NO,NO,YES,,,,,,,,,,,
alternate_ncr_dummysilence,Silence?,silence,Limit break is less powerful.,NO,YES,NO,NO,YES,,,,,,,,,,,
ncr_lingeringburn,Lingering_burn,fire,Receive [fire]Burn_all every turn.,NO,NO,NO,NO,YES,,,if(self.innate.indexOf(~gaindice~) != -1) inflictself(FIRE|1); inflictself(FIRE|ALL);,,,,,,,,
ncr_lingeringfreeze,Lingering_freeze,fire,Receive [ice]Freeze_all every turn.,NO,NO,NO,NO,YES,,,if(self.innate.indexOf(~gaindice~) != -1) inflictself(ICE|1); inflictself(ICE|ALL);,,,,,,,,
ncr_lingeringvanish,Lingering_vanish,fire,Receive [vanish]Vanish_all every turn.,NO,NO,NO,NO,YES,,,inflictself(VANISH);,,,,,,,,
ncr_ransom1,Ransom_1,lock,Temporarily disables a random equipment until|you insert a 1 into it. The dice will be returned.,NO,YES,NO,NO,YES,var myscript = ~runscript(\~ncrmod/ransomwareprep\~);~; if(self.scriptonstartturn.indexOf(myscript) == -1) self.scriptonstartturn = myscript + self.scriptonstartturn; /*i want this on start turn script to run only once; regardless of how many different ransoms you have. (read: i just migrated from 1.8 and wat do i do)*/ runscript(~ncrmod/ransomwareprep~); /*just in case you ransom yourself midturn. that sounds so weird out of context.*/ trace(self.scriptonstartturn);,,,,,,,,,,
ncr_ransom2,Ransom_2,lock,Temporarily disables a random equipment until|you insert a 2 into it. The dice will be returned.,NO,YES,NO,NO,YES,var myscript = ~runscript(\~ncrmod/ransomwareprep\~);~; if(self.scriptonstartturn.indexOf(myscript) == -1) self.scriptonstartturn = myscript + self.scriptonstartturn; runscript(~ncrmod/ransomwareprep~); trace(self.scriptonstartturn);,,,,,,,,,,
ncr_ransom3,Ransom_3,lock,Temporarily disables a random equipment until|you insert a 3 into it. The dice will be returned.,NO,YES,NO,NO,YES,var myscript = ~runscript(\~ncrmod/ransomwareprep\~);~; if(self.scriptonstartturn.indexOf(myscript) == -1) self.scriptonstartturn = myscript + self.scriptonstartturn; runscript(~ncrmod/ransomwareprep~); trace(self.scriptonstartturn);,,,,,,,,,,
ncr_ransom4,Ransom_4,lock,Temporarily disables a random equipment until|you insert a 4 into it. The dice will be returned.,NO,YES,NO,NO,YES,var myscript = ~runscript(\~ncrmod/ransomwareprep\~);~; if(self.scriptonstartturn.indexOf(myscript) == -1) self.scriptonstartturn = myscript + self.scriptonstartturn; runscript(~ncrmod/ransomwareprep~); trace(self.scriptonstartturn);,,,,,,,,,,
ncr_ransom5,Ransom_5,lock,Temporarily disables a random equipment until|you insert a 5 into it. The dice will be returned.,NO,YES,NO,NO,YES,var myscript = ~runscript(\~ncrmod/ransomwareprep\~);~; if(self.scriptonstartturn.indexOf(myscript) == -1) self.scriptonstartturn = myscript + self.scriptonstartturn; runscript(~ncrmod/ransomwareprep~); trace(self.scriptonstartturn);,,,,,,,,,,
ncr_ransom6,Ransom_6,lock,Temporarily disables a random equipment until|you insert a 6 into it. The dice will be returned.,NO,YES,NO,NO,YES,var myscript = ~runscript(\~ncrmod/ransomwareprep\~);~; if(self.scriptonstartturn.indexOf(myscript) == -1) self.scriptonstartturn = myscript + self.scriptonstartturn; runscript(~ncrmod/ransomwareprep~); trace(self.scriptonstartturn);,,,,,,,,,,
ncr_lingeringcounter1,Lingering_counter_1,lock,Receive [lock]Counter_1 every turn.,NO,NO,NO,NO,YES,,,inflictself(~counter_1~);,,,,,,,,
ncr_lingeringcounter2,Lingering_counter_2,lock,Receive [lock]Counter_2 every turn.,NO,NO,NO,NO,YES,,,inflictself(~counter_2~);,,,,,,,,
ncr_lingeringcounter3,Lingering_counter_3,lock,Receive [lock]Counter_3 every turn.,NO,NO,NO,NO,YES,,,inflictself(~counter_3~);,,,,,,,,
ncr_lingeringcounter4,Lingering_counter_4,lock,Receive [lock]Counter_4 every turn.,NO,NO,NO,NO,YES,,,inflictself(~counter_4~);,,,,,,,,
ncr_lingeringcounter5,Lingering_counter_5,lock,Receive [lock]Counter_5 every turn.,NO,NO,NO,NO,YES,,,inflictself(~counter_5~);,,,,,,,,
ncr_lingeringcounter6,Lingering_counter_6,lock,Receive [lock]Counter_6 every turn.,NO,NO,NO,NO,YES,,,inflictself(~counter_6~);,,,,,,,,
ncr_paralysis,Paralyze,shock,Temporarily disable a random equipment whenever you use a card|directed at the enemy. Equipment can be re-enabled for 1 dice.,YES,YES,NO,NO,YES,,,,,if(e.castdirection == 1) { inflictself(SHOCK); self.applyequipmentcurses(); status.value--; } },,,,,,
ncr_restraint,Restrain,weaken,Temporarily weaken a random equipment whenever you use a card|directed at the enemy. Equipment becomes less powerful.,YES,YES,NO,NO,YES,,,,,if(e.castdirection == 1) { inflictself(WEAKEN); self.applyequipmentcurses(); status.value--; },,,,,,
alternate_ncr_paralysis,Paralyze?,shock,Temporarily disable a random equipment whenever you use a card|directed at the enemy. Equipment can be re-enabled for 3 health.,YES,YES,NO,NO,YES,,,,,if(e.castdirection == 1) { inflictself(SHOCK); self.applyequipmentcurses(); status.value--; } },,,,,,
alternate_ncr_restraint,Restrain?,weaken,Become weakened whenever you use a card directed at|the enemy. This makes you take extra damage.,YES,YES,NO,NO,YES,,,,,if(e.castdirection == 1) { inflictself(WEAKEN); self.applyequipmentcurses(); status.value--; },,,,,,
ncr_paralysis_all,Paralyze_all,shock,Temporarily disable a random equipment whenever you use a card|directed at the enemy. Equipment can be re-enabled for 1 dice.,NO,YES,NO,NO,YES,,,,,if(e.castdirection == 1) { inflictself(SHOCK); self.applyequipmentcurses(); } },,,,,,
ncr_restraint_all,Restrain_all,weaken,Temporarily weaken a random equipment whenever you use a card|directed at the enemy. Equipment becomes less powerful.,NO,YES,NO,NO,YES,,,,,if(e.castdirection == 1) { inflictself(WEAKEN); self.applyequipmentcurses(); },,,,,,
alternate_ncr_paralysis_all,Paralyze_all?,shock,Temporarily disable a random equipment whenever you use a card|directed at the enemy. Equipment can be re-enabled for 3 health.,NO,YES,NO,NO,YES,,,,,if(e.castdirection == 1) { inflictself(SHOCK); self.applyequipmentcurses(); } },,,,,,
alternate_ncr_restraint_all,Restrain_all?,weaken,Become weakened whenever you use a card directed at|the enemy. This makes you take extra damage.,NO,YES,NO,NO,YES,,,,,if(e.castdirection == 1) { inflictself(WEAKEN); self.applyequipmentcurses(); },,,,,,
ncr_jumble,Jumble,weaken,Your cards' slots are mixed up.,NO,YES,NO,NO,YES,,,,sfx(~apply_weaken_to_equipment~); var indices = []; var shuffledindices = []; for(eq in self.equipment) { if(eq.isready() && eq.skillcard == ~~) { indices.push(self.equipment.indexOf(eq)); } }   shuffledindices = shuffle(indices.copy());  self.setvar(~jumbleindices~|indices); self.setvar(~jumbleshuffledindices~|shuffledindices);  self.setvar(~jumbleequipmentnames~|[for(eq in self.equipment) eq.name]); var indicessame = true; for(indice in shuffledindices) { if(shuffledindices[indices.indexOf(indice)] != indice) { indicessame = false; break; } } if(indicessame) { shuffledindices.unshift(shuffledindices.pop()); } /*there are people who are going to read this and cry*/ trace(indices); trace(shuffledindices);   var slotlist = []; var cdlist = []; var i = 0;  for(indice in indices) { slotlist.push(self.equipment[indice].getslots()); cdlist.push(self.equipment[indice].remainingcountdown); }  trace(indices); trace(shuffledindices); trace(slotlist); trace(cdlist);  for(indice in shuffledindices) { var eq = self.equipment[indice]; eq.changeslots(slotlist[i]); eq.remainingcountdown = cdlist[i]; eq.animate(~flashandshake~); eq.animation[eq.animation.length - 1].addcommand(~textparticle~[;] ~[weaken] Jumbled!~[;] 14519873); i++; },,,var names = self.getvar(~jumbleequipmentnames~); var indices = self.getvar(~jumbleindices~); var shuffledindices = self.getvar(~jumbleshuffledindices~); var slotlist = []; var cdlist = []; var i = 0;  for(indice in shuffledindices) { slotlist.push(self.equipment[indice].getslots()); cdlist.push(self.equipment[indice].remainingcountdown); }  for(indice in indices) { var eq = self.equipment[indice]; eq.changeslots(slotlist[i]); eq.remainingcountdown = cdlist[i]; if(eq.name != names[self.equipment.indexOf(eq)]) { eq.resetslots(); eq.remainingcountdown = eq.countdown; } i++; },,,,
ncr_chip,Chip,cog,Your amount of chips this turn.,YES,YES,NO,NO,NO,,,,,,,,,,,
locky,locky,lock,locky,NO,YES,NO,NO,NO,,,,,for(dice in self.dicepool) dice.animate(LOCK);,,,,,,
