Name,Displayed As,Symbol,Description,Stacks?,Remove at End Turn?,Remove at Start Turn?,Invisible?,Blocked by Reduce?,Script: When inflicted,Script: On any status infliction,Script: Before Start Turn,Script: On Start Turn,Script: On any equipment use,Script: On any countdown reduce,Script: End Turn,Script: After Combat,Script: On damage inflicted,Script: On damage taken,Script: On status remove
reversenexttarget,Swap_Next_Target,recycle,The next equipment you use will swap target.,YES,YES,NO,NO,NO,,,,,,,,,,,
ncr_lightswitch1,Light_Switch_1,dice,Roll an extra 1 next turn.,NO,NO,YES,NO,NO,,,,,,,,,,,
ncr_lightswitch2,Light_Switch_2,dice,Roll an extra 2 next turn.,NO,NO,YES,NO,NO,,,,,,,,,,,
ncr_lightswitch3,Light_Switch_3,dice,Roll an extra 3 next turn.,NO,NO,YES,NO,NO,,,,,,,,,,,
ncr_lightswitch4,Light_Switch_4,dice,Roll an extra 4 next turn.,NO,NO,YES,NO,NO,,,,,,,,,,,
ncr_lightswitch5,Light_Switch_5,dice,Roll an extra 5 next turn.,NO,NO,YES,NO,NO,,,,,,,,,,,
ncr_lightswitch6,Light_Switch_6,dice,Roll an extra 6 next turn.,NO,NO,YES,NO,NO,,,,,,,,,,,
ncr_vanish,Vanish,vanish,Duplicate dice are immediately destroyed.,YES,YES,NO,NO,YES,var skipsetup = false; var noeffect = false;  if(self.status.length > 0) for(stat in self.status) { if(stat.type == ~ncr_vanish~) skipsetup = true; if(stat.type == ~vanish~) noeffect = true; } if((self.getvar(~vanishactuator~) + 1 == ~SimpleActuator1~) # (target.getvar(~vanishactuator~) + 1 == ~SimpleActuator1~)) skipsetup = true; trace(skipsetup); trace(noeffect); if(skipsetup) trace(~skipping setup~); if(noeffect) { self.textparticle(~No effect!~); removestatusself(~ncr_vanish~|ALL); } else if(!skipsetup) {  trace(~starting vanish actuator~);  var tw = new motion.actuators.SimpleActuator(null|1/60|null);  tw._repeat = -1;  var s = new elements.Skill(~Against all odds_old~);  s.script = ~   if(self.hp <= 0 # self.graphic == null # target == null # target.graphic == null # target.hp <= 0) {    trace(\~vanish actuator stopped\~);    self.getvar(\~vanishactuator\~).stop();    self.resetvar(\~vanishactuator\~);   }   else {    if(self.dicepool.length > 0 && self.hasstatus(\~ncr_vanish\~)) {     var hasvalue = [false|false|false|false|false|false|false];     var dicevanished = false;     for (i in 0 ... self.dicepool.length){      if (self.dicepool[i].available()){       if (!self.dicepool[i].intween()){        if (!hasvalue[self.dicepool[i].basevalue]){         hasvalue[self.dicepool[i].basevalue] = true;        }else{         self.dicepool[i].animate(\~disappear\~);         dicevanished = true;         trace(\~decrementing self vanish\~);         removestatusself(\~ncr_vanish\~|1);         if(!self.hasstatus(\~ncr_vanish\~)) { trace(\~breaking vanish for self\~); break; }        }       }      }     }     if (dicevanished){      sfx(\~_diceburn\~);     }    }    if(target != null && target.dicepool.length > 0 && target.hasstatus(\~ncr_vanish\~)) {     var hasvalue = [false|false|false|false|false|false|false];     var dicevanished = false;     for (i in 0 ... target.dicepool.length){      if (target.dicepool[i].available()){       if (!target.dicepool[i].intween()){        if (!hasvalue[target.dicepool[i].basevalue]){         hasvalue[target.dicepool[i].basevalue] = true;        }else{         target.dicepool[i].animate(\~disappear\~);         target.dicepool[i].canbedragged = false;         dicevanished = true;         trace(\~decrementing target vanish\~);         removestatus(\~ncr_vanish\~|1);         if(!target.hasstatus(\~ncr_vanish\~)){ trace(\~breaking vanish for target\~); break; }        }       }      }     }     if (dicevanished){      sfx(\~_diceburn\~);     }    }   }  ~;  if(self.isplayer) s.execute(self|target); else s.execute(target|self);  if(self.isplayer) tw.onRepeat(s.execute|[self|target]); else tw.onRepeat(s.execute|[target|self]);  if(self.isplayer) self.setvar(~vanishactuator~|tw); else target.setvar(~vanishactuator~|tw);  tw.move(); },,,,,,,,,,
ncr_lessfluff,Less_Fluff,cog,The next card you use is immediately gadgetized.,NO,YES,NO,NO,NO,,,,,,,,,,,
ncr_injection,Script_Injection,cog,Next card you use will do damage equal to|the dice inserted before its normal effect.,YES,NO,NO,NO,NO,,,,,,,,,,,
ncr_invisiblehook,Invisible_Hook,silence,You shouldn't be seeing this[;] it's an internal thing.,YES,NO,NO,YES,NO,,,,,,,,,,,
ncr_hyper,Hyperspeed,confuse,Convert the next status you inflict to its Parallel Universe version.,YES,YES,NO,NO,NO,,removestatusself(inflicted_type);,,,,,,,,,
alternate_ncr_hyper,Hyperspeed?,confuse,Convert the next status you inflict to its non-Parallel Universe version.,YES,YES,NO,NO,NO,,if(self.getvar(~hs_noloop~) == 0) { self.setvar(~hs_noloop~|1); trace(~a status~); trace(Rules.alternatestatus); if(Rules.alternatestatus == null) Rules.alternatestatus = []; var isalt = false; var isaltdummy = new elements.Fighter(~Wisp~); isaltdummy.addstatus(inflicted_type.split(~alternate_~).join(~~)|1); if(isaltdummy.status[0].type.indexOf(~alternate_~)  == 0) { isalt = true; } if(isalt) { var oldalternate = Rules.alternatestatus.copy(); Rules.alternatestatus = []; removestatusself(inflicted_type|inflicted_value); inflictself(inflicted_type|inflicted_value); var tw = new motion.actuators.SimpleActuator(null|0.01|null); var s = new elements.Skill(~Against all odds_old~); s.script = ~  removestatusself(\~~ + status.type + ~\~);~; tw.onComplete(s.execute|[self|target]); tw.move(); Rules.alternatestatus = oldalternate; } } else { self.setvar(~hs_noloop~|0); },,,,,,,,,
ncr_poisontemp,Poisontemp,cog,You shouldn't be seeing this description.|Go yell at ncrecc,YES,YES,NO,NO,NO,,,,,,,,,,,
ncr_error,Error,ncr_error,At the start of your turn[;] a random item errors out[;]|rendering it unusable for that turn.,YES,YES,NO,NO,YES,if(self.dicepool.length > 0) { var erroramt = inflicted_value; var erroreq = []; var optimalerroreq = []; if(self.equipment.length > 0) { for(eq in self.equipment) { if(eq.hastag(~errorimmune~) == false && eq.skillcard == ~~ && eq.isready()) { erroreq.push(eq); optimalerroreq.push(eq); /*don't avoid erroring shocked equipment if error inflicted midturn*/ } } while(erroramt > 0) { var pickedeq = null; if(optimalerroreq.length > 0) pickedeq = rand(optimalerroreq); else pickedeq = rand(erroreq); pickedeq.removedice(); if(pickedeq.shockedsetting != 1) roboterror(self|[pickedeq]); optimalerroreq.remove(pickedeq); erroreq.remove(pickedeq); if(erroreq.length < 1) break; erroramt--; } if (self.layout == ~DECK~) { Deck.advance(0.8); } } },,,var erroramt = status.value; var erroreq = []; var optimalerroreq = []; if(self.equipment.length > 0) { for(eq in self.equipment) { if(eq.hastag(~errorimmune~) == false && eq.skillcard == ~~ && eq.isready()) { erroreq.push(eq); if(!eq.weakened && eq.shockedsetting == 0) optimalerroreq.push(eq); } } while(erroramt > 0) { var pickedeq = null; if(optimalerroreq.length > 0) pickedeq = rand(optimalerroreq); else pickedeq = rand(erroreq); pickedeq.removedice(); if(pickedeq.shockedsetting != 1) roboterror(self|[pickedeq]); optimalerroreq.remove(pickedeq); erroreq.remove(pickedeq); if(erroreq.length < 1) break; erroramt--; } if (self.layout == ~DECK~) { Deck.advance(0.8); } },,,,,,,
ncr_silence,Silence,silence,Temporarily disables your most important equipment.|Can use two dice to unsilence.,NO,YES,NO,NO,YES,/*as it turns out megaquest ALSO has a custom silence implementation for enemies... i think my 'most important card' thing is a bit nicer though. anyway i need to actually play megaquest some time; the betas i got of it were rather frustrating and unfair but my feedback probably helped*/ if(self.isplayer) { var tw = new motion.actuators.SimpleActuator(null|0.01|null); var s = new elements.Skill(~Against all odds_old~); s.script = ~  removestatus(\~ncr_silence\~|ALL); inflict(SILENCE); ~; tw.onComplete(s.execute|[target|self]); tw.move(); } else { self.symbolparticle(~silence~); },,,if(self.equipment.length > 0) {  var eqtosilence = null;  var eqstosort = [];  var exceptions = loaddata(~ncrmod/silenceexceptions~);  for(enemy in exceptions) { trace(self.name); trace(enemy.enemyname); if(self.name == enemy.enemyname) {   for(eq in self.equipment) { trace(enemy.importantcard); trace(eq.name); if(eq.name == enemy.importantcard) { eqstosort.push(eq); eqtosilence = eq; break; } }   if(eqtosilence == null) for(eq in self.equipment) if(eq.name == enemy.importantcard2) { eqstosort.push(eq); eqtosilence = eq; break; }  } }  if(eqtosilence == null) {   var never = [for(card in loaddata(~ncrmod/silencecardexceptions~)) if(card.priority == ~never~) card.cardname];   var always = [for(card in loaddata(~ncrmod/silencecardexceptions~)) if(card.priority == ~always~) card.cardname];   eqstosort = [for(eq in self.equipment) if(eq.isready() && never.indexOf(eq.name) == -1 && eq.shockedsetting != 2) eq];   var eqstosort2 = [];   if(eqstosort.length > 0) for(eq in eqstosort) if(always.indexOf(eq.name) != -1) eqstosort2.push(eq);   if(eqstosort2.length > 0) eqstosort = eqstosort2;   if(eqstosort.length == 1) eqtosilence = eqstosort[0];   if(eqtosilence == null && eqstosort.length > 0) {    var largeeqs = [for(eq in eqstosort) if(eq.size == 2) eq];    if(largeeqs.length > 0) eqstosort = largeeqs;    if(eqstosort.length == 1) eqtosilence = eqstosort[0];    if(eqtosilence == null) {     var sorton = ~~;     for(eq in eqstosort) {      if(eq.usesleft > 0 # (eq.usesleft == -1 && !eq.hastag(~hidereuseable~))) {       sorton = ~uses~; break;      }     }     if(sorton == ~~) for(eq in eqstosort) {      if(eq.countdown > 0) {       sorton = ~cd~; break;      }     }     if(sorton == ~~) for(eq in eqstosort) {      if(eq.getslots().length > 0 && !eq.getslots()[0].substr(0|7) == ~REQUIRE~) {       sorton = ~normal~; break;      }     }     if(sorton == ~~) sorton = ~needsx~;     trace(sorton);     var max = null;     if(sorton == ~normal~) max = eqstosort[0];     for(eq in eqstosort) {      if(sorton == ~uses~) {       if(eq.usesleft == -1) {        max = eq; break;       }       else if(max == null # eq.usesleft > max.usesleft) {        max = eq;       }      }      if(sorton == ~cd~) {       if(max == null # eq.countdown > max.countdown) {        max = eq;       }      }      if(sorton == ~needsx~) {       if(max == null # (eq.getslots().length > 0 && eq.getslots()[0].substr(0|7) == ~REQUIRE~ && (max.getslots.length == 0) # (max.getslots()[0].substr(0|7) != ~REQUIRE~)) # (eq.getslots().length > 0 && eq.getslots()[0].substr(0|7) == ~REQUIRE~ && (eq.getslots()[0].substr(7|0) - 0) > (max.getslots()[0].substr(7|0) - 0))) {        max = eq;       }      }     }     if(max != null) eqtosilence = max;    }   }  }  if(eqtosilence == null && eqstosort.length > 0) { trace(~what the fuck~); eqtosilence = eqstosort[0]; }  if(eqtosilence == null && eqstosort.length == 0) { trace(~what went on here~); eqtosilence = self.equipment[0]; }  if(getstatusself(~alternate_ncr_silence~) > 0) { eqtosilence.downgrade(); eqtosilence.animate(~flashandshake~); eqtosilence.animation[eqtosilence.animation.length - 1].addcommand(~textparticle~[;] ~[silence] Silenced!~[;] 16777215); sfx(~apply_silence_to_equipment~); } else if(getstatusself(~ncr_silence~) > 0) { eqtosilence.shockedsetting = 0; eqtosilence.animate(~silence~); } },,,,,,,
alternate_ncr_silence,Silence?!,silence,Temporarily weakens your most important equipment.|Equipment becomes less powerful.,NO,YES,NO,NO,YES,if(self.isplayer) { var tw = new motion.actuators.SimpleActuator(null|0.01|null); var s = new elements.Skill(~Against all odds_old~); s.script = ~  removestatus(\~ncr_silence\~|ALL); inflict(\~alternate_silence\~); ~; tw.onComplete(s.execute|[target|self]); tw.move(); } else { self.symbolparticle(~silence~); },,,if(self.equipment.length > 0) {  var eqtosilence = null;  var eqstosort = [];  var exceptions = loaddata(~ncrmod/silenceexceptions~);  for(enemy in exceptions) { trace(self.name); trace(enemy.enemyname); if(self.name == enemy.enemyname) {   for(eq in self.equipment) { trace(enemy.importantcard); trace(eq.name); if(eq.name == enemy.importantcard) { eqstosort.push(eq); eqtosilence = eq; break; } }   if(eqtosilence == null) for(eq in self.equipment) if(eq.name == enemy.importantcard2) { eqstosort.push(eq); eqtosilence = eq; break; }  } }  if(eqtosilence == null) {   var never = [for(card in loaddata(~ncrmod/silencecardexceptions~)) if(card.priority == ~never~) card.cardname];   var always = [for(card in loaddata(~ncrmod/silencecardexceptions~)) if(card.priority == ~always~) card.cardname];   eqstosort = [for(eq in self.equipment) if(eq.isready() && never.indexOf(eq.name) == -1 && eq.shockedsetting != 2) eq];   var eqstosort2 = [];   if(eqstosort.length > 0) for(eq in eqstosort) if(always.indexOf(eq.name) != -1) eqstosort2.push(eq);   if(eqstosort2.length > 0) eqstosort = eqstosort2;   if(eqstosort.length == 1) eqtosilence = eqstosort[0];   if(eqtosilence == null && eqstosort.length > 0) {    var largeeqs = [for(eq in eqstosort) if(eq.size == 2) eq];    if(largeeqs.length > 0) eqstosort = largeeqs;    if(eqstosort.length == 1) eqtosilence = eqstosort[0];    if(eqtosilence == null) {     var sorton = ~~;     for(eq in eqstosort) {      if(eq.usesleft > 0 # (eq.usesleft == -1 && !eq.hastag(~hidereuseable~))) {       sorton = ~uses~; break;      }     }     if(sorton == ~~) for(eq in eqstosort) {      if(eq.countdown > 0) {       sorton = ~cd~; break;      }     }     if(sorton == ~~) for(eq in eqstosort) {      if(eq.getslots().length > 0 && !eq.getslots()[0].substr(0|7) == ~REQUIRE~) {       sorton = ~normal~; break;      }     }     if(sorton == ~~) sorton = ~needsx~;     trace(sorton);     var max = null;     if(sorton == ~normal~) max = eqstosort[0];     for(eq in eqstosort) {      if(sorton == ~uses~) {       if(eq.usesleft == -1) {        max = eq; break;       }       else if(max == null # eq.usesleft > max.usesleft) {        max = eq;       }      }      if(sorton == ~cd~) {       if(max == null # eq.countdown > max.countdown) {        max = eq;       }      }      if(sorton == ~needsx~) {       if(max == null # (eq.getslots().length > 0 && eq.getslots()[0].substr(0|7) == ~REQUIRE~ && (max.getslots.length == 0) # (max.getslots()[0].substr(0|7) != ~REQUIRE~)) # (eq.getslots().length > 0 && eq.getslots()[0].substr(0|7) == ~REQUIRE~ && (eq.getslots()[0].substr(7|0) - 0) > (max.getslots()[0].substr(7|0) - 0))) {        max = eq;       }      }     }     if(max != null) eqtosilence = max;    }   }  }  if(eqtosilence == null && eqstosort.length > 0) { trace(~what the fuck~); eqtosilence = eqstosort[0]; }  if(eqtosilence == null && eqstosort.length == 0) { trace(~what went on here~); eqtosilence = self.equipment[0]; }  if(getstatusself(~alternate_ncr_silence~) > 0) { eqtosilence.downgrade(); eqtosilence.animate(~flashandshake~); eqtosilence.animation[eqtosilence.animation.length - 1].addcommand(~textparticle~[;] ~[silence] Silenced!~[;] 16777215); sfx(~apply_silence_to_equipment~); } else if(getstatusself(~ncr_silence~) > 0) { eqtosilence.shockedsetting = 0; eqtosilence.animate(~silence~); } },,,,,,,
ncr_dummysilence,Silence,silence,Cannot use special character skills or limit breaks.,NO,YES,NO,NO,YES,,,,,,,,,,,
alternate_ncr_dummysilence,Silence?,silence,Limit break is less powerful.,NO,YES,NO,NO,YES,,,,,,,,,,,
ncr_lingeringburn,Lingering_burn_all,fire,Receive [fire]Burn_all every turn.,NO,NO,NO,NO,YES,,,if(self.innate.indexOf(~gaindice~) != -1) inflictself(FIRE|1); inflictself(FIRE|ALL);,,,,,,,,
ncr_lingeringfreeze,Lingering_freeze_all,fire,Receive [ice]Freeze_all every turn.,NO,NO,NO,NO,YES,,,if(self.innate.indexOf(~gaindice~) != -1) inflictself(ICE|1); inflictself(ICE|ALL);,,,,,,,,
ncr_lingeringvanish,Lingering_vanish_all,fire,Receive [vanish]Vanish_all every turn.,NO,NO,NO,NO,YES,,,inflictself(VANISH);,,,,,,,,
ncr_ransom1,Ransom_1,lock,Temporarily disables a random equipment until|you insert a 1 into it. The dice will be returned.,NO,YES,NO,NO,YES,var myscript = ~runscript(\~ncrmod/ransomwareprep\~);~; if(self.scriptonstartturn.indexOf(myscript) == -1) self.scriptonstartturn = myscript + self.scriptonstartturn; /*i want this on start turn script to run only once; regardless of how many different ransoms you have. (read: i just migrated from 1.8 and wat do i do)*/ runscript(~ncrmod/ransomwareprep~); /*just in case you ransom yourself midturn. that sounds so weird out of context.*/ trace(self.scriptonstartturn);,,,,,,,,,,
ncr_ransom2,Ransom_2,lock,Temporarily disables a random equipment until|you insert a 2 into it. The dice will be returned.,NO,YES,NO,NO,YES,var myscript = ~runscript(\~ncrmod/ransomwareprep\~);~; if(self.scriptonstartturn.indexOf(myscript) == -1) self.scriptonstartturn = myscript + self.scriptonstartturn; runscript(~ncrmod/ransomwareprep~); trace(self.scriptonstartturn);,,,,,,,,,,
ncr_ransom3,Ransom_3,lock,Temporarily disables a random equipment until|you insert a 3 into it. The dice will be returned.,NO,YES,NO,NO,YES,var myscript = ~runscript(\~ncrmod/ransomwareprep\~);~; if(self.scriptonstartturn.indexOf(myscript) == -1) self.scriptonstartturn = myscript + self.scriptonstartturn; runscript(~ncrmod/ransomwareprep~); trace(self.scriptonstartturn);,,,,,,,,,,
ncr_ransom4,Ransom_4,lock,Temporarily disables a random equipment until|you insert a 4 into it. The dice will be returned.,NO,YES,NO,NO,YES,var myscript = ~runscript(\~ncrmod/ransomwareprep\~);~; if(self.scriptonstartturn.indexOf(myscript) == -1) self.scriptonstartturn = myscript + self.scriptonstartturn; runscript(~ncrmod/ransomwareprep~); trace(self.scriptonstartturn);,,,,,,,,,,
ncr_ransom5,Ransom_5,lock,Temporarily disables a random equipment until|you insert a 5 into it. The dice will be returned.,NO,YES,NO,NO,YES,var myscript = ~runscript(\~ncrmod/ransomwareprep\~);~; if(self.scriptonstartturn.indexOf(myscript) == -1) self.scriptonstartturn = myscript + self.scriptonstartturn; runscript(~ncrmod/ransomwareprep~); trace(self.scriptonstartturn);,,,,,,,,,,
ncr_ransom6,Ransom_6,lock,Temporarily disables a random equipment until|you insert a 6 into it. The dice will be returned.,NO,YES,NO,NO,YES,var myscript = ~runscript(\~ncrmod/ransomwareprep\~);~; if(self.scriptonstartturn.indexOf(myscript) == -1) self.scriptonstartturn = myscript + self.scriptonstartturn; runscript(~ncrmod/ransomwareprep~); trace(self.scriptonstartturn);,,,,,,,,,,
ncr_lingeringcounter1,Lingering_counter_1,lock,Receive [lock]Counter_1 every turn.,NO,NO,NO,NO,YES,,,inflictself(~counter_1~);,,,,,,,,
ncr_lingeringcounter2,Lingering_counter_2,lock,Receive [lock]Counter_2 every turn.,NO,NO,NO,NO,YES,,,inflictself(~counter_2~);,,,,,,,,
ncr_lingeringcounter3,Lingering_counter_3,lock,Receive [lock]Counter_3 every turn.,NO,NO,NO,NO,YES,,,inflictself(~counter_3~);,,,,,,,,
ncr_lingeringcounter4,Lingering_counter_4,lock,Receive [lock]Counter_4 every turn.,NO,NO,NO,NO,YES,,,inflictself(~counter_4~);,,,,,,,,
ncr_lingeringcounter5,Lingering_counter_5,lock,Receive [lock]Counter_5 every turn.,NO,NO,NO,NO,YES,,,inflictself(~counter_5~);,,,,,,,,
ncr_lingeringcounter6,Lingering_counter_6,lock,Receive [lock]Counter_6 every turn.,NO,NO,NO,NO,YES,,,inflictself(~counter_6~);,,,,,,,,
ncr_paralysis,Paralyze,shock,Temporarily disable a random equipment whenever you use a card|directed at the enemy. Equipment can be re-enabled for 1 dice.,YES,YES,NO,NO,YES,,,,,if(e.castdirection == 1) { inflictself(SHOCK); self.applyequipmentcurses(); var tw = new motion.actuators.SimpleActuator(null|0.01|null); var s = new elements.Skill(~Against all odds_old~); s.script = ~  removestatusself(\~~ + status.type + ~\~);~; tw.onComplete(s.execute|[self|target]); tw.move(); },,,,,,
ncr_restraint,Restrain,weaken,Temporarily weaken a random equipment whenever you use a card|directed at the enemy. Equipment becomes less powerful.,YES,YES,NO,NO,YES,,,,,if(e.castdirection == 1) { inflictself(WEAKEN); self.applyequipmentcurses(); var tw = new motion.actuators.SimpleActuator(null|0.01|null); var s = new elements.Skill(~Against all odds_old~); s.script = ~  removestatusself(\~~ + status.type + ~\~);~; tw.onComplete(s.execute|[self|target]); tw.move(); },,,,,,
alternate_ncr_paralysis,Paralyze?,shock,Temporarily disable a random equipment whenever you use a card|directed at the enemy. Equipment can be re-enabled for 3 health.,YES,YES,NO,NO,YES,,,,,if(e.castdirection == 1) { inflictself(SHOCK); self.applyequipmentcurses(); var tw = new motion.actuators.SimpleActuator(null|0.01|null); var s = new elements.Skill(~Against all odds_old~); s.script = ~  removestatusself(\~~ + status.type + ~\~);~; tw.onComplete(s.execute|[self|target]); tw.move(); },,,,,,
alternate_ncr_restraint,Restrain?,weaken,Become weakened whenever you use a card directed at|the enemy. This makes you take extra damage.,YES,YES,NO,NO,YES,,,,,if(e.castdirection == 1) { inflictself(WEAKEN); self.applyequipmentcurses(); var tw = new motion.actuators.SimpleActuator(null|0.01|null); var s = new elements.Skill(~Against all odds_old~); s.script = ~  removestatusself(\~~ + status.type + ~\~);~; tw.onComplete(s.execute|[self|target]); tw.move(); },,,,,,
ncr_paralysis_all,Paralyze_all,shock,Temporarily disable a random equipment whenever you use a card|directed at the enemy. Equipment can be re-enabled for 1 dice.,NO,YES,NO,NO,YES,,,,,if(e.castdirection == 1) { inflictself(SHOCK); self.applyequipmentcurses(); },,,,,,
ncr_restraint_all,Restrain_all,weaken,Temporarily weaken a random equipment whenever you use a card|directed at the enemy. Equipment becomes less powerful.,NO,YES,NO,NO,YES,,,,,if(e.castdirection == 1) { inflictself(WEAKEN); self.applyequipmentcurses(); },,,,,,
alternate_ncr_paralysis_all,Paralyze_all?,shock,Temporarily disable a random equipment whenever you use a card|directed at the enemy. Equipment can be re-enabled for 3 health.,NO,YES,NO,NO,YES,,,,,if(e.castdirection == 1) { inflictself(SHOCK); self.applyequipmentcurses(); },,,,,,
alternate_ncr_restraint_all,Restrain_all?,weaken,Become weakened whenever you use a card directed at|the enemy. This makes you take extra damage.,NO,YES,NO,NO,YES,,,,,if(e.castdirection == 1) { inflictself(WEAKEN); self.applyequipmentcurses(); },,,,,,
ncr_jumble,Jumble,weaken,Your cards' slots are mixed up.,NO,YES,NO,NO,YES,,,,sfx(~apply_weaken_to_equipment~); var indices = []; var shuffledindices = []; for(eq in self.equipment) { if(eq.isready() && eq.skillcard == ~~) { indices.push(self.equipment.indexOf(eq)); } }   shuffledindices = shuffle(indices.copy());  self.setvar(~jumbleindices~|indices); self.setvar(~jumbleshuffledindices~|shuffledindices);  self.setvar(~jumbleequipmentnames~|[for(eq in self.equipment) eq.name]); var indicessame = true; for(indice in shuffledindices) { if(shuffledindices[indices.indexOf(indice)] != indice) { indicessame = false; break; } } if(indicessame) { shuffledindices.unshift(shuffledindices.pop()); } /*there are people who are going to read this and cry*/ trace(indices); trace(shuffledindices);   var slotlist = []; var cdlist = []; var i = 0;  for(indice in indices) { slotlist.push(self.equipment[indice].getslots()); cdlist.push(self.equipment[indice].remainingcountdown); }  trace(indices); trace(shuffledindices); trace(slotlist); trace(cdlist);  for(indice in shuffledindices) { var eq = self.equipment[indice]; eq.changeslots(slotlist[i]); eq.remainingcountdown = cdlist[i]; eq.animate(~flashandshake~); eq.animation[eq.animation.length - 1].addcommand(~textparticle~[;] ~[weaken] Jumbled!~[;] 14519873); i++; },,,for(eq in self.equipment) eq.resetslots(); /*this probably does some unsatisfying stuff with equipment that modifies its own slot; but no enemies have those and how the hell would this get inflicted on the player before their turn starts*/ /*var names = self.getvar(~jumbleequipmentnames~); var indices = self.getvar(~jumbleindices~); var shuffledindices = self.getvar(~jumbleshuffledindices~); var slotlist = []; var cdlist = []; var i = 0;  for(indice in shuffledindices) { slotlist.push(self.equipment[indice].getslots()); cdlist.push(self.equipment[indice].remainingcountdown); }  for(indice in indices) { var eq = self.equipment[indice]; eq.changeslots(slotlist[i]); eq.remainingcountdown = cdlist[i]; if(eq.name != names[self.equipment.indexOf(eq)]) { eq.resetslots(); eq.remainingcountdown = eq.countdown; } i++; }*/,,,,
ncr_drainmonster_helper,Drain Monster? helper,cog,shouldn't be visible,NO,NO,NO,YES,NO,,if(self.getvar(~dm_noloop~) == 0) {  if(inflicted_type == ~poison~ # inflicted_type == ~alternate_poison~) {   self.setvar(~dm_noloop~|1);   inflictself(WEAKEN|inflicted_value); sfx(~_weaken~);  }  if(inflicted_type == ~weaken~ # inflicted_type == ~alternate_weaken~) {   self.setvar(~dm_noloop~|1);   inflictself(POISON|inflicted_value); sfx(~_poison~);  } } else { self.setvar(~dm_noloop~|0); },,,,,,,,,
ncr_bountyhunter_helper,Bounty Hunter? helper,cog,shouldn't be visible,NO,NO,NO,YES,NO,,if(self.getvar(~bh_noloop~) == 0) {  if(inflicted_type == ~shock~ # inflicted_type == ~alternate_shock~) {   self.setvar(~bh_noloop~|1);   inflictself(FIRE|inflicted_value); sfx(~_fire~); }  if(inflicted_type == ~fire~ # inflicted_type == ~alternate_fire~) {   self.setvar(~bh_noloop~|1);   inflictself(SHOCK|inflicted_value); sfx(~_shock~); } if(inflicted_type == ~fire_all~ # inflicted_type == ~alternate_fire_all~) { inflictself(SHOCK|ALL); sfx(~_shock~); } } else { self.setvar(~bh_noloop~|0); },,,,,,,,,
alternate_vanish,Vanish_all?,vanish,Whenever you use an equipment[;] there is a 50% chance[;]|one of your unused dice will vanish.,NO,YES,NO,NO,YES,,,,,if(chance(50) && self.dicepool.length > 0) { var dicelist = [for(dice in self.dicepool) if(dice.available() && !dice.intween()) dice]; if(dicelist.length > 0) { rand(dicelist).animate(~disappear~); sfx(~_vanish~); } },,,,,,
alternate_ncr_vanish,Vanish?,vanish,Whenever you use an equipment[;] there is a 50% chance[;]|one of your unused dice will vanish. Disappears when triggered.,YES,YES,NO,NO,YES,,,,,if(chance(50) && self.dicepool.length > 0) { var dicelist = [for(dice in self.dicepool) if(dice.available() && !dice.intween()) dice]; if(dicelist.length > 0) { rand(dicelist).animate(~disappear~); sfx(~_vanish~); var tw = new motion.actuators.SimpleActuator(null|0.01|null); var s = new elements.Skill(~Against all odds_old~); s.script = ~  removestatusself(\~~ + status.type + ~\~);~; tw.onComplete(s.execute|[self|target]); tw.move(); } },,,,,,
ncr_car,Cars,ncr_car,Cars are used to grant bonus powers on certain cards.|They disappear at the end of the fight.,YES,NO,NO,NO,NO,/*car symbol by notan lemon*/,,,,,,,,,,
ncr_lingeringshock,Lingering_shock,shock,Receive [shock]<value> shock every turn.,YES,NO,NO,NO,YES,,,inflictself(SHOCK|stat.value);,,,,,,,,
ncr_error_all,Error_all,ncr_error,All of your items error out[;] rendering them unusable for this turn.,NO,YES,NO,NO,YES,if(self.dicepool.length > 0) { roboterror(self); self.roll_error = true; if (self.layout == ~DECK~) { Deck.advance(0.8); } },,,roboterror(self); if (self.layout == ~DECK~) { self.roll_error = true; Deck.advance(0.8); },,,,,,,
ncr_motive,Motive,confuse,Whenever you take damage[;] your limit break is charged|as though you had taken <value> extra damage.,YES,NO,YES,NO,NO,,,,,,,,,,if(self.limitvalue != null && self.limitmax != null) { self.limitvalue += status.value; if(self.limitvalue > self.limitmax) { self.limitvalue = self.limitmax; } },
ncr_ultramotive,Ultra_Motive,confuse,Whenever you take damage[;] your limit break is charged|as though you had taken that amount of damage|again[;] times <value>.,YES,NO,YES,NO,NO,,,,,,,,,,if(self.limitvalue != null && self.limitmax != null) { self.limitvalue += (dmg * status.value); if(self.limitvalue > self.limitmax) { self.limitvalue = self.limitmax; } },
ncr_exhaustion,Exhaustion,curse,Your limit break is charged by <value> less|from all sources of damage.,YES,NO,YES,NO,YES,,,,,,,,,,if(self.limitvalue != null) { self.limitvalue -= status.value; if(self.limitvalue < 0) { self.limitvalue = 0; } },
errorall,Error_All,recycle,(text should not appear - workaround for Polarity Flip + Pandemonium combination),NO,YES,NO,YES,NO,,,,,,,,,,,
ncr_counter_buffer,Counter_buffer,cog,The next time you use a dice[;] also|inflict [lock]Counter equal to its value.,YES,YES,NO,NO,NO,/*halligan bar counts as used before it inserts 3s hopefully. if not force the status to look for equipment dice before countdown dice*/,,,,,,,,,,
ncr_stash_buffer,Stash_buffer,cog,The next time you use a dice[;] also|stash it for your next turn.,YES,YES,NO,NO,NO,/*should use illuminate!*/,,,,,,,,,,
