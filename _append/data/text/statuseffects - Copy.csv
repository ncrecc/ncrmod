Name,Displayed As,Symbol,Description,Stacks?,Remove at End Turn?,Remove at Start Turn?,Invisible?,Blocked by Reduce?,Script: When inflicted,Script: On any status infliction,Script: Before Start Turn,Script: On Start Turn,Script: On any equipment use,Script: On any countdown reduce,Script: End Turn,Script: After Combat,Script: On damage inflicted,Script: On damage taken,Script: On status remove
ncr_vanish,Vanish,vanish,Up to <value> duplicate dice are immediately destroyed.,YES,YES,NO,NO,YES,var skipsetup = false; var noeffect = false;  if(self.status.length > 0) for(stat in self.status) { if(stat.type == ~ncr_vanish~) skipsetup = true; if(stat.type == ~vanish~) noeffect = true; } if((self.getvar(~vanishactuator~) + 1 == ~SimpleActuator1~) # (target.getvar(~vanishactuator~) + 1 == ~SimpleActuator1~)) skipsetup = true; trace(skipsetup); trace(noeffect); if(skipsetup) trace(~skipping setup~); if(noeffect) { self.textparticle(~No effect!~); removestatusself(~ncr_vanish~|ALL); } else if(!skipsetup) {  trace(~starting vanish actuator~);  var tw = new motion.actuators.SimpleActuator(null|1/60|null);  tw._repeat = -1;  var s = new elements.Skill(~Against all odds_old~);  s.script = ~   if(self.hp <= 0 # self.graphic == null # target == null # target.graphic == null # target.hp <= 0) {    trace(\~vanish actuator stopped\~);    self.getvar(\~vanishactuator\~).stop();    self.resetvar(\~vanishactuator\~);   }   else {    if(self.dicepool.length > 0 && self.hasstatus(\~ncr_vanish\~)) {     var hasvalue = [false|false|false|false|false|false|false];     var dicevanished = false;     for (i in 0 ... self.dicepool.length){      if (self.dicepool[i].available()){       if (!self.dicepool[i].intween()){        if (!hasvalue[self.dicepool[i].basevalue]){         hasvalue[self.dicepool[i].basevalue] = true;        }else{         self.dicepool[i].animate(\~disappear\~);         dicevanished = true;         trace(\~decrementing self vanish\~);         removestatusself(\~ncr_vanish\~|1);         if(!self.hasstatus(\~ncr_vanish\~)) { trace(\~breaking vanish for self\~); break; }        }       }      }     }     if (dicevanished){      sfx(\~_diceburn\~);     }    }    if(target != null && target.dicepool.length > 0 && target.hasstatus(\~ncr_vanish\~)) {     var hasvalue = [false|false|false|false|false|false|false];     var dicevanished = false;     for (i in 0 ... target.dicepool.length){      if (target.dicepool[i].available()){       if (!target.dicepool[i].intween()){        if (!hasvalue[target.dicepool[i].basevalue]){         hasvalue[target.dicepool[i].basevalue] = true;        }else{         target.dicepool[i].animate(\~disappear\~);         target.dicepool[i].canbedragged = false;         dicevanished = true;         trace(\~decrementing target vanish\~);         removestatus(\~ncr_vanish\~|1);         if(!target.hasstatus(\~ncr_vanish\~)){ trace(\~breaking vanish for target\~); break; }        }       }      }     }     if (dicevanished){      sfx(\~_diceburn\~);     }    }   }  ~;  if(self.isplayer) s.execute(self|target); else s.execute(target|self);  if(self.isplayer) tw.onRepeat(s.execute|[self|target]); else tw.onRepeat(s.execute|[target|self]);  if(self.isplayer) self.setvar(~vanishactuator~|tw); else target.setvar(~vanishactuator~|tw);  tw.move(); },,,,,,,,,,
