Name,Description,Size,Script: On Execute,Gadget,Slots,NEED TOTAL?,Colour,Upgrade,Weaken,Alternate Status Trigger,SFX,Uses?,Cast Backwards?,Single use?,Tags,Witch Spell,Script: On Dodge,Script: Before Combat,Script: After Combat,Script: Before Start Turn,Script: On Start Turn,Script: End Turn,Script: On any equipment use,Script: Before execute,Script: On Snap,Script: On Fury,Script: On any countdown reduce
Trinity Charm,Roll a 3[;] 33% chance|to roll another 3,1,var odds = 33.33; if(getstatusself(~luck~) > 0){ odds = 66.66; } if(getstatusself(~luck+~) > 0){ odds = 100; }   if(chance(odds)) { self.textparticle(~Success!~); givedice([3|3]); } else{ givedice(3); },Trinity,MIN4,,YELLOW,change_power,change_power,,,0,YES,NO,,1,,,,,,,,,,,
Trinity Charm_upgraded,Roll a 3[;] 33% chance|to roll another 3,1,var odds = 33.33; if(getstatusself(~luck~) > 0){ odds = 66.66; } if(getstatusself(~luck+~) > 0){ odds = 100; }   if(chance(odds)) { self.textparticle(~Success!~); givedice([3|3]); } else{ givedice(3); },Trinity,COUNTDOWN,4,YELLOW,,,,,0,YES,NO,,,,,,,,,,,,,
Trinity Charm_downgraded,Roll a 3,1,givedice(3); /*tc has gone through a million and one iterations. in its very first incarnation it was a 3-countdown 33% chance to roll a 3; 3 uses this turn but it kind of captured the very essence of why jackeea doesn't like chance items. same with when its chance was to roll three 3s. at some point the base was needs 3 and the upgrade made it min 3. the incarnation this was in before i wrote this note and redesigned it was the same as before; but min3 and the upgrade made it a countdown of 3. for the longest time i refused to touch tc because i didn't want it to involve any number that wasn't a 3. this incarnation involves a 4 (min; countdown) and a 2 (how many 3s you roll when the chance succeeds). oh well. (also: in its very first few stages; it was green. how bizarre is that?) (also also: if this were morefluff i would've just stuck with the first design and never rethought it. nah jk ilu jackeea)*/,Trinity,MIN4,,YELLOW,,,,,0,YES,NO,,,,,,,,,,,,,
Funk Blaster,Double [weaken]weaken|[gray](once per battle),1,inflict(WEAKEN| getstatus(WEAKEN)); /*this item was very specifically created for thief pu back when i thought of ncrmod as an extension onto existing episodes ala more fluff. that's why it's so out of place*/,Theremin,COUNTDOWN,18,ORANGE,change_power,change_power,,_weaken,0,NO,YES,,,,,,,,,,,,,
Funk Blaster_upgraded,Double [weaken]weaken|[gray](once per battle),1,inflict(WEAKEN| getstatus(WEAKEN));,Theremin,COUNTDOWN,12,ORANGE,,,,_weaken,0,NO,YES,,,,,,,,,,,,,
Funk Blaster_downgraded,Increase [weaken]weaken by 50%|[gray](once per battle),1,inflict(WEAKEN| getstatus(WEAKEN) * 0.5);,Theremin,COUNTDOWN,18,ORANGE,,,,_weaken,0,NO,YES,,,,,,,,,,,,,
Funk Blaster_weakened,Increase [weaken]weaken by 50%|[gray](once per battle),1,inflict(WEAKEN| getstatus(WEAKEN) * 0.5);,Theremin,COUNTDOWN,12,ORANGE,,,,_weaken,0,NO,YES,,,,,,,,,,,,,
FK 47,[sword]6[;] rob enemy after battle|[gray](unusable after turn 1),1,if(self.finderskeepers == null) { self.finderskeepers = 0; } if(self.finderskeepers >= 0 && self.finderskeepers < 999) self.finderskeepers += 1; screenshake(); attack(6); sfx(~_thinghappens~);,Steal,NORMAL|NORMAL,8,GREEN,change_power,change_function,,_damage,0,NO,NO,excludefromrandomlists,,,,,if(turn > 1) {e.availablethisturn = false; e.unavailabledetails = [~This card is not available~|~after your first turn.~];},,,,,,,
FK 47_upgraded,[sword]6[;] rob enemy after battle|[gray](unusable after turn 2),1,if(self.finderskeepers == null) { self.finderskeepers = 0; } if(self.finderskeepers >= 0 && self.finderskeepers < 999) self.finderskeepers += 1; screenshake(); attack(6); sfx(~_thinghappens~);,Steal,NORMAL|NORMAL,8,GREEN,,,,_damage,0,NO,NO,excludefromrandomlists,,,,,if(turn > 2) {e.availablethisturn = false; e.unavailabledetails = [~This card is not available~|~after your second turn.~];},,,,,,,
FK 47_downgraded,Do [sword]6 damage|[gray](unusable after turn 1),1,attack(6);,Steal,NORMAL|NORMAL,8,GREEN,,,,_damage,0,NO,NO,excludefromrandomlists,,,,,if(turn > 1) {e.availablethisturn = false; e.unavailabledetails = [~This card is not available~|~after your first turn.~];},,,,,,,
FK 47_weakened,Do [sword]6 damage|[gray](unusable after turn 2),1,attack(6);,Steal,NORMAL|NORMAL,8,GREEN,,,,_damage,0,NO,NO,excludefromrandomlists,,,,,if(turn > 2) {e.availablethisturn = false; e.unavailabledetails = [~This card is not available~|~after your second turn.~];},,,,,,,
Switchblade@even,Do [sword]<d6> damage,1,attack(d); /*this predates megaquest's switchblade; or at least it was introduced early enough that switchblade hadn't had much association with mq yet. this is a very old mod that just didn't release for a long time*/,Neutron Star,EVEN,,RED,change_requirements,change_power,,_damage,0,NO,NO,,1,,,,var neweq = new elements.Equipment(~Switchblade@odd~); neweq.x = e.x; neweq.y = e.y; self.equipment[self.equipment.indexOf(e)] = neweq;,,,,,,,
Switchblade@even_upgraded,Do [sword]<d6> damage[;]|+1 if dice is odd,1,if (d % 2 == 1) { attack(d + 1); } else {attack(d);},Neutron Star,NORMAL,,RED,,,,_damage,0,NO,NO,,,,,,,,,,,,,
Switchblade@even_downgraded,Do [sword]<d6> damage,1,attack(d);,Neutron Star,REQUIRE4,,RED,,,,_damage,0,NO,NO,,,,,,,,,,,,,
Switchblade@even_weakened,Do [sword]<d6> damage[;]|+1 if dice is odd,1,if (d % 2 == 1) { attack(d + 1); } else {attack(d);},Neutron Star,RANGE34,,RED,,,,_damage,0,NO,NO,,,,,,,,,,,,,
Switchblade@odd,Do [sword]<d6> damage,1,attack(d);,Neutron Star,ODD|FREE1,,RED,change_requirements,change_power,,_damage,0,NO,NO,,1,,,,var neweq = new elements.Equipment(~Switchblade@even~); neweq.x = e.x; neweq.y = e.y; self.equipment[self.equipment.indexOf(e)] = neweq;,,,,,,,
Switchblade@odd_upgraded,Do [sword]<d6> damage[;]|+1 if dice is odd,1,if (d % 2 == 1) { attack(d + 1); } else {attack(d);},Neutron Star,NORMAL,,RED,,,,_damage,0,NO,NO,,,,,,,,,,,,,
Switchblade@odd_downgraded,Do [sword]<d6> damage,1,attack(d);,Neutron Star,REQUIRE3|FREE1,,RED,,,,_damage,0,NO,NO,,,,,,,,,,,,,
Switchblade@odd_weakened,Do [sword]<d6> damage[;]|+1 if dice is odd,1,if (d % 2 == 1) { attack(d + 1); } else {attack(d);},Neutron Star,RANGE34,,RED,,,,_damage,0,NO,NO,,,,,,,,,,,,,
Power Fantasy,Do [sword]999 damage,1,attack(999); sfxdamage(target|999);,Catapult,ODD|ODD,9,PURPLE,change_power,change_function,,none,0,NO,NO,,,,,,,,,,,,,
Power Fantasy_upgraded,Do [sword]999 damage,1,attack(999); sfxdamage(target|999);,Catapult,ODD|ODD,7,PURPLE,,,,none,0,NO,NO,,,,,,,,,,,,,
Power Fantasy_downgraded,Do [sword]1 damage,1,attack(1); sfxdamage(target|1);,Catapult,ODD|ODD,10,PURPLE,,,,none,0,NO,NO,,,,,,,,,,,,,
Heavenly Nectar,Recover [heal]<d6> health|for both you and enemy,1,attackself(-d); attack(-d);,Recover,NORMAL,,GREEN,change_power,change_function,,_heal,0,NO,NO,,1,attackself(-d);,,,,,,,,,,
Heavenly Nectar_upgraded,Recover [heal]<double> health|for both you and enemy,1,attackself(-d * 2); attack(-d * 2);,Recover,NORMAL,,GREEN,,,,_heal,0,NO,NO,,,attackself(-d * 2);,,,,,,,,,,
Heavenly Nectar_downgraded,Recover [heal]<d6> health|for you[;] [heal]<double> for enemy,1,attackself(-d); attack(-d * 2);,Recover,NORMAL,,GREEN,,,,_heal,0,NO,NO,,,attackself(-d);,,,,,,,,,,
Gas Lamp,Return dice. In [jinx]2 turns[;]|return them again,1,givedice([d|d]); jinx(~Gas Lamp~|~receive two %VAR%s~|~Receive two %VAR%s~|~inflict(\~stash\~+%VAR%|2); sfx(\~magic_gaindice\~);~|self|self|2|d);,Replicate,DOUBLES|DOUBLES,,PINK,change_power,change_function,,,0,YES,NO,,1,,,,,,,,,,,
Gas Lamp_upgraded,Return dice. In [jinx]2 turns[;]|return them again,1,givedice([actualdice[0].basevalue|actualdice[1].basevalue]); jinx(~Gas Lamp+~|~receive a ~ + actualdice[0].basevalue + ~ and a ~ + actualdice[1].basevalue|~Receive a ~ + actualdice[0].basevalue + ~ and a ~ + actualdice[1].basevalue|~if(~ + actualdice[0].basevalue + ~ == ~ + actualdice[1].basevalue + ~) { inflict(\~stash~ + actualdice[0].basevalue + ~\~|2); } else { inflict(\~stash~ + actualdice[0].basevalue + ~\~); inflict(\~stash~ + actualdice[1].basevalue + ~\~); } sfx(\~magic_gaindice\~);~|self|self|2|0);,Replicate,MIN4|MIN4,,PINK,,,,,0,YES,NO,,,,,,,,,,,,,
Gas Lamp_downgraded,Return a dice. In [jinx]2 turns[;]|return both dice,1,givedice(d); jinx(~Gas Lamp-~|~receive two %VAR%s~|~Receive two %VAR%s~|~inflict(\~stash\~+%VAR%|2); sfx(\~magic_gaindice\~);~|self|self|2|d);,Replicate,DOUBLES|DOUBLES,,PINK,,,,,0,YES,NO,,,,,,,,,,,,,
Hyper Beam,Do [sword]8 damage[;]|end your turn,1,attack(8); self.endturnnow();,Plasma Gun,REQUIRE5,,GRAY,change_power,change_power,,_damage,0,NO,NO,,1,self.endturnnow();,,,,,,,,,e.preventdefault = true; e.maintainfury = true;,
Hyper Beam_upgraded,Do [sword]10 damage[;]|end your turn,1,attack(10); self.endturnnow();,Plasma Gun,REQUIRE5,,GRAY,,,,_damage,0,NO,NO,,,self.endturnnow();,,,,,,,,,e.preventdefault = true; e.maintainfury = true;,
Hyper Beam_downgraded,Do [sword]6 damage[;]|end your turn,1,attack(6); self.endturnnow();,Plasma Gun,REQUIRE5,,GRAY,,,,_damage,0,NO,NO,,,self.endturnnow();,,,,,,,,,e.preventdefault = true; e.maintainfury = true;,
Russian Roulette,Do [sword]<double> damage to|either you or the enemy,1,var odds = 50; if(getstatusself(~luck~) > 0){ odds = 100; } else if(getstatusself(~luck+~) > 0){ odds = 100; } if(chance(odds)) { attackself(d); } else { attack(d); },Drunken Boxing,NORMAL,,RED,add3,change_function,,_damage,0,NO,NO,,,,,,,,,,,,,
Russian Roulette_downgraded,Do [sword]<double> damage to yourself,1,attackself(d);,Drunken Boxing,NORMAL,,RED,,,,_damage,0,NO,NO,,,,,,,,,,,,,
Very Bad Sword,Just straight up take [sword]<d6>|damage. See if I care.,1,attackself(d);,Catapult,NORMAL,,RED,add3,change_power,,_damage,0,YES,NO,,,,,,,,,,,,,
Very Bad Sword_downgraded,Just straight up take [sword]<d6>|damage. See if I care.,1,attackself(d);,Catapult,NORMAL|FREE6,,RED,,,,_damage,0,YES,NO,,,,,,,,,,,,,
Zombocom,Do [sword]<d6>[;] inflict 1 to 4|of a random effect|[80%][gray]''The unattainable is unknown''[],2,var sl = [CURSE|LOCK|FIRE|ICE|WEAKEN|SHOCK|POISON|BLIND|~vanish~]; var s = e.getvar(~statustoinflict~); trace(e.getvar(~statustoinflict~)); trace(s); trace(sl[s]); var r = e.getvar(~amounttoinflict~); trace(e.getvar(~amounttoinflict~)); trace(r); if(sl[s] == ~vanish~) { sfx(~_vanish~); inflict(~ncr_vanish~|r);  } else { self.textparticle(~No effect!~); } } else { inflict(sl[s]|r); sfx(~_~ + sl[s]);  } attack(d);,Overload,REQUIRE5|REQUIRE5,,PINK,change_power,change_function,,_damage,0,NO,NO,,,,e.changecolour(~PINK~);,e.changecolour(~PINK~);,e.changeslots([rand([~REQUIRE1~|~REQUIRE2~|~REQUIRE3~|~REQUIRE4~|~REQUIRE5~|~REQUIRE6~])|rand([~REQUIRE1~|~REQUIRE2~|~REQUIRE3~|~REQUIRE4~|~REQUIRE5~|~REQUIRE6~])]); var sl = [0|1|2|2|2|2|3|3|3|3|4|4|4|5|5|5|6|6|7]; for(i in 0...1) { sl = sl.concat(sl); } sl.push(8); var s = rand(sl); trace(sl); trace(~hi~); trace(s); var r = rand([1|2|2|2|3|3|4]); trace(r); e.setvar(~statustoinflict~|s); trace(e.getvar(~statustoinflict~)); e.setvar(~amounttoinflict~|r); trace(e.getvar(~amounttoinflict~)); if(s == 7 # s == 0 # s == 1) { e.changecolour(~GRAY~); } if(s == 2) { e.changecolour(~RED~); } if(s == 3) { e.changecolour(~BLUE~); } if(s == 4) { e.changecolour(~ORANGE~); } if(s == 5) { e.changecolour(~YELLOW~); } if(s == 6) { e.changecolour(~PURPLE~); } if(s == 8) { e.changecolour(~PINK~); },,,,,,,
Zombocom_downgraded,Do [sword]<d6> damage|[80%][gray]''The only limit is yourself''[],2,attack(d);,Overload,REQUIRE5|REQUIRE5,,PINK,,,,_damage,0,NO,NO,,,,e.changecolour(~PINK~);,e.changecolour(~PINK~);,e.changeslots([rand([~REQUIRE1~|~REQUIRE2~|~REQUIRE3~|~REQUIRE4~|~REQUIRE5~|~REQUIRE6~])|rand([~REQUIRE1~|~REQUIRE2~|~REQUIRE3~|~REQUIRE4~|~REQUIRE5~|~REQUIRE6~])]),,,,,,,
Zombocom_upgraded,Do [sword]<d6>[;] inflict 1 to 4|of a random effect|[80%][gray]''You can do anything at Zombocom''[],2,var sl = [CURSE|LOCK|FIRE|ICE|WEAKEN|SHOCK|POISON|BLIND|~vanish~]; var s = e.getvar(~statustoinflict~); trace(e.getvar(~statustoinflict~)); trace(s); trace(sl[s]); var r = e.getvar(~amounttoinflict~); trace(e.getvar(~amounttoinflict~)); trace(r); if(sl[s] == ~vanish~) { sfx(~_vanish~); inflict(~ncr_vanish~|r);  } else { self.textparticle(~No effect!~); } } else { inflict(sl[s]|r); sfx(~_~ + sl[s]);  } attack(d);,Overload,NORMAL|NORMAL,10,PINK,,,,_damage,0,NO,NO,,,,e.changecolour(~PINK~);,e.changecolour(~PINK~);,e.needstotal = rand([2|3|4|5|6|7|8|9|10|11|12]); var sl = [0|1|2|2|2|2|3|3|3|3|4|4|4|5|5|5|6|6|7]; for(i in 0...1) { sl = sl.concat(sl); } sl.push(8); var s = rand(sl); trace(sl); trace(~hi~); trace(s); var r = rand([1|2|2|2|3|3|4]); trace(r); e.setvar(~statustoinflict~|s); trace(e.getvar(~statustoinflict~)); e.setvar(~amounttoinflict~|r); trace(e.getvar(~amounttoinflict~)); if(s == 7 # s == 0 # s == 1) { e.changecolour(~GRAY~); } if(s == 2) { e.changecolour(~RED~); } if(s == 3) { e.changecolour(~BLUE~); } if(s == 4) { e.changecolour(~ORANGE~); } if(s == 5) { e.changecolour(~YELLOW~); } if(s == 6) { e.changecolour(~PURPLE~); } if(s == 8) { e.changecolour(~PINK~); },,,,,,,
Obmozcom,Do [sword]6[;] inflict 2 or 3|of a random effect|[80%][gray]''The vast universe is available''[],2,var sl = [CURSE|LOCK|FIRE|ICE|WEAKEN|SHOCK|POISON|BLIND|~vanish~]; var s = e.getvar(~statustoinflict~); trace(e.getvar(~statustoinflict~)); trace(s); trace(sl[s]); var r = e.getvar(~amounttoinflict~); trace(e.getvar(~amounttoinflict~)); trace(r); if(sl[s] == ~vanish~) { sfx(~_vanish~); inflict(~ncr_vanish~|r);  } else { self.textparticle(~No effect!~); } } else { inflict(sl[s]|r); sfx(~_~ + sl[s]);  } attack(6);,Overload,REQUIRE5|REQUIRE5,,PINK,change_power,change_function,,_damage,0,NO,NO,,,,e.changecolour(~PINK~);,e.changecolour(~PINK~);,e.changeslots([rand([~REQUIRE1~|~REQUIRE2~|~REQUIRE3~|~REQUIRE4~|~REQUIRE5~|~REQUIRE6~])|rand([~REQUIRE1~|~REQUIRE2~|~REQUIRE3~|~REQUIRE4~|~REQUIRE5~|~REQUIRE6~])]); var sl = [0|1|2|2|2|2|3|3|3|3|4|4|4|5|5|5|6|6|7]; for(i in 0...1) { sl = sl.concat(sl); } sl.push(8); var s = rand(sl); trace(sl); trace(~hi~); trace(s); var r = rand([2|2|2|2|3|3|3]); trace(r); e.setvar(~statustoinflict~|s); trace(e.getvar(~statustoinflict~)); e.setvar(~amounttoinflict~|r); trace(e.getvar(~amounttoinflict~)); if(s == 7 # s == 0 # s == 1) { e.changecolour(~GRAY~); } if(s == 2) { e.changecolour(~RED~); } if(s == 3) { e.changecolour(~BLUE~); } if(s == 4) { e.changecolour(~ORANGE~); } if(s == 5) { e.changecolour(~YELLOW~); } if(s == 6) { e.changecolour(~PURPLE~); } if(s == 8) { e.changecolour(~PINK~); },,,,,,,
Obmozcom_downgraded,Do [sword]6 damage|[80%][gray]''You'll always be welcome at Obmozcom''[],2,attack(6);,Overload,REQUIRE5|REQUIRE5,,PINK,,,,_damage,0,NO,NO,,,,e.changecolour(~PINK~);,e.changecolour(~PINK~);,e.changeslots([rand([~REQUIRE1~|~REQUIRE2~|~REQUIRE3~|~REQUIRE4~|~REQUIRE5~|~REQUIRE6~])|rand([~REQUIRE1~|~REQUIRE2~|~REQUIRE3~|~REQUIRE4~|~REQUIRE5~|~REQUIRE6~])]),,,,,,,
Obmozcom_upgraded,Do [sword]6[;] inflict 2 or 3|of a random effect|[80%][gray]''Obmozcom is omnipotent''[],2,var sl = [CURSE|LOCK|FIRE|ICE|WEAKEN|SHOCK|POISON|BLIND|~vanish~]; var s = e.getvar(~statustoinflict~); trace(e.getvar(~statustoinflict~)); trace(s); trace(sl[s]); var r = e.getvar(~amounttoinflict~); trace(e.getvar(~amounttoinflict~)); trace(r); if(sl[s] == ~vanish~) { sfx(~_vanish~); inflict(~ncr_vanish~|r);  } else { self.textparticle(~No effect!~); } } else { inflict(sl[s]|r); sfx(~_~ + sl[s]);  } attack(6);,Overload,NORMAL|NORMAL,10,PINK,,,,_damage,0,NO,NO,,,,e.changecolour(~PINK~);,e.changecolour(~PINK~);,e.needstotal = rand([2|3|4|5|6|7|8|9|10|11|12]); var sl = [0|1|2|2|2|2|3|3|3|3|4|4|4|5|5|5|6|6|7]; for(i in 0...1) { sl = sl.concat(sl); } sl.push(8); var s = rand(sl); trace(sl); trace(~hi~); trace(s); var r = rand([2|2|2|2|3|3|3]); trace(r); e.setvar(~statustoinflict~|s); trace(e.getvar(~statustoinflict~)); e.setvar(~amounttoinflict~|r); trace(e.getvar(~amounttoinflict~)); if(s == 7 # s == 0 # s == 1) { e.changecolour(~GRAY~); } if(s == 2) { e.changecolour(~RED~); } if(s == 3) { e.changecolour(~BLUE~); } if(s == 4) { e.changecolour(~ORANGE~); } if(s == 5) { e.changecolour(~YELLOW~); } if(s == 6) { e.changecolour(~PURPLE~); } if(s == 8) { e.changecolour(~PINK~); },,,,,,,
Hijack,Split a dice in two[;]|on 1[;] do [sword]3 instead,1,if(d==1){ attack(3); sfxdamage(target|3); }; else { givedice(split(d)| ~splitdice~); };,Pure Evil,NORMAL,,GREEN,change_power,change_function,,,0,YES,NO,,,,,,,,,,if(d==1){ e.castdirection = 1; }; else { e.castdirection = -1; };,,,
Hijack_upgraded,Split a dice in two[;]|on 1[;] also do [sword]3 damage,1,if(d==1){ attack(3); sfxdamage(target|3); }; givedice(split(d)| ~splitdice~);,Pure Evil,NORMAL,,GREEN,,,,,0,YES,NO,,,givedice(split(d)| ~splitdice~);,,,,,,,if(d==1){ e.castdirection = 1; }; else { e.castdirection = -1; };,,,
Hijack_downgraded,Split a dice in two,1,givedice(split(d)| ~splitdice~);,Pure Evil,MIN2,,GREEN,,,,,0,YES,NO,,,,,,,,,,,,,
Tension,Gain [fury]2 fury[;] end your turn|[gray](once per battle),1,inflictself(FURY|2); self.endturnnow();,Fury,NORMAL|NORMAL,9,RED,change_power,change_power,,_fury,0,YES,YES,,2,,,,,,,,,,e.preventdefault = true; e.maintainfury = true;,
Tension_upgraded,Gain [fury]2 fury[;] end your turn|[gray](once per battle),1,inflictself(FURY|2); self.endturnnow();,Fury,COUNTDOWN,9,RED,,,,_fury,0,YES,YES,,,,,,,,,,,,e.preventdefault = true; e.maintainfury = true;,
Tension_downgraded,Gain [fury]1 fury[;] end your turn|[gray](once per battle),1,inflictself(FURY); self.endturnnow();,Fury,NORMAL|NORMAL,9,RED,,,,_fury,0,YES,YES,,,,,,,,,,,,e.preventdefault = true; e.maintainfury = true;,
Tension_weakened,Gain [fury]1 fury[;] end your turn|[gray](once per battle),1,inflictself(FURY); self.endturnnow();,Fury,COUNTDOWN,9,RED,,,,_fury,0,YES,YES,,,,,,,,,,,,e.preventdefault = true; e.maintainfury = true;,
First Stand,At the start of the first|turn[;] gain [dodge]Dodge,1,,Quick Thinking,,,YELLOW,change_power,noeffect,,none,0,YES,NO,,,,,e.changecolour(~YELLOW~);,,if(turn == 1) { e.animate(~flashandshake~); e.changecolour(~GRAY~); inflictself(DODGE); sfx(~_dodge~); },,,,,,
First Stand_upgraded,At the start of the first|two turns[;] gain [dodge]Dodge,1,,Quick Thinking,,,YELLOW,,,,none,0,YES,NO,,,,,e.changecolour(~YELLOW~);,,if(turn == 1 # turn == 2) { e.animate(~flashandshake~); inflictself(DODGE); sfx(~_dodge~); } if(turn == 2) { e.changecolour(~GRAY~); },,,,,,
Buster Knife,Do [sword]<d6> damage|[gray](immune to errors)|[gray](Reusable),1,attack(d);,Pea Gun,MAX2|FREE1,,GRAY,increaserange,change_function,,_damage,-1,NO,NO,errorimmune,,,,,,,,,,,,
Buster Knife_downgraded,Do [sword]<d6> damage|[gray](immune to errors)|[gray](Reusable),1,attack(d);,Pea Gun,MAX2|FREE1,,GRAY,,,,_damage,2,NO,NO,errorimmune,,,,,,,,,,,,
Keyhole,Flip and split die[;]|flip results,2,var s = split(7-d); givedice([7-s[0]|7-s[1]]);,Clone Device,NORMAL,,GREEN,reducesize,complicate,,splitdice,0,YES,NO,,,,,,,,,,,,,
Keyhole_weakened,Flip and split die[;]|flip results,1,var s = split(7-d); givedice([7-s[0]|7-s[1]]);,Clone Device,MAX3,,GREEN,,,,splitdice,0,YES,NO,,,,,,,,,,,,,
Keyhole_deckupgrade,Split die[;]|flip results,2,var s = split(d); givedice([7-s[0]|7-s[1]]);,Clone Device,NORMAL,,GREEN,,,,splitdice,0,YES,NO,,,,,,,,,,,,,
Cookie Cake,Repeat next action twice,1,inflictself(FURY|2);,Fury,COUNTDOWN,24,ORANGE,change_power,change_function,fury,_fury,0,YES,NO,,,,,,,,,,,,e.preventdefault = true; e.maintainfury = true;,
Cookie Cake_upgraded,Repeat next action twice,1,inflictself(FURY|2);,Fury,COUNTDOWN,18,ORANGE,,,,_fury,0,YES,NO,,,,,,,,,,,,e.preventdefault = true; e.maintainfury = true;,
Cookie Cake_downgraded,Repeat next action,1,inflictself(FURY);,Fury,COUNTDOWN,24,ORANGE,,,,_fury,0,YES,NO,,,,,,,,,,,,e.preventdefault = true; e.maintainfury = true;,
Cookie Cake_weakened,Repeat next action,1,inflictself(FURY);,Fury,COUNTDOWN,18,ORANGE,,,,_fury,0,YES,NO,,,,,,,,,,,,e.preventdefault = true; e.maintainfury = true;,
Cookie Cake?,Repeat next action twice[;]|but disable it next turn,1,inflictself(FURY|2);,Fury,COUNTDOWN,24,ORANGE,change_power,change_function,,_fury,0,YES,NO,alternateversion,,,,,,,,,,,e.preventdefault = true; e.maintainfury = true;,
Cookie Cake?_upgraded,Repeat next action twice[;]|but disable it next turn,1,inflictself(FURY|2);,Fury,COUNTDOWN,18,ORANGE,,,,_fury,0,YES,NO,alternateversion,,,,,,,,,,,e.preventdefault = true; e.maintainfury = true;,
Cookie Cake?_downgraded,Repeat next action[;]but|disable it next turn,1,inflictself(FURY);,Fury,COUNTDOWN,24,ORANGE,,,,_fury,0,YES,NO,alternateversion,,,,,,,,,,,e.preventdefault = true; e.maintainfury = true;,
Cookie Cake?_weakened,Repeat next action[;]but|disable it next turn,1,inflictself(FURY);,Fury,COUNTDOWN,18,ORANGE,,,,_fury,0,YES,NO,alternateversion,,,,,,,,,,,e.preventdefault = true; e.maintainfury = true;,
Big Knife,Do [sword]<d6> - 3[;] get dice - 3|[gray](Reusable),1,if(d < 4){ self.textparticle(~No effect!~); } else { attack(d - 3); givedice(d - 3); },Underwhelm,MIN4,,RED,change_power,change_function,,_damage,3,NO,NO,,1,if(d < 4){ self.textparticle(~No effect!~); } else { givedice(d - 3); },,,,,,,,,,
Big Knife_upgraded,Do [sword]<d6> - 2[;] get dice - 2|[gray](Reusable),1,if(d < 3){ self.textparticle(~No effect!~); } else { attack(d - 2); givedice(d - 2); },Underwhelm,MIN4,,RED,,,,_damage,3,NO,NO,,,if(d < 4){ self.textparticle(~No effect!~); } else { givedice(d - 2); },,,,,,,,,,
Big Knife_downgraded,Do [sword]<d6> - 4[;] get dice - 4|[gray](Reusable),1,if(d < 5){ self.textparticle(~No effect!~); } else { attack(d - 4); givedice(d - 4); },Underwhelm,MIN4,,RED,,,,_damage,3,NO,NO,,,if(d < 4){ self.textparticle(~No effect!~); } else { givedice(d - 4); },,,,,,,,,,
Biohazard,Inflict [poison]<d6> poison|[gray](once per battle),2,inflict(POISON|d);,Anthrax,NORMAL,,PURPLE,change_power,complicate,,_poison,0,NO,YES,,,,,,,,,,,,,
Biohazard_upgraded,Inflict [poison]<d6> poison|[gray](cooldown of 3 turns),2,inflict(POISON|d); e.setvar(~biocooldown~|3);,Anthrax,NORMAL,,PURPLE,,,,_poison,0,NO,NO,,,,e.setvar(~biocooldown~[;]0);,e.setvar(~biocooldown~[;]0);,if(e.getvar(~biocooldown~) > 0) { e.availablethisturn = false; e.unavailabletext = ~On cooldown~; e.unavailabledetails = [~Available in ~ + e.getvar(~biocooldown~) + ~turns.~]; e.setvar(~biocooldown~[;]e.getvar(~biocooldown~) - 1); },,,,,,,
Berlin Massachusetts Key,Get a dice you already have|[gray](Reuseable),1,var seen = []; for (mydice in self.dicepool){ if (mydice.available() && mydice != actualdice[0] && seen[seen.indexOf(mydice.basevalue)] == null ){ seen.push(mydice.basevalue); } } if(seen.length > 0) { shuffle(seen); givedice(seen[0]); } else { givedice(d); self.textparticle(~Only 1 dice!~); },Light Switch,NORMAL,,PINK,change_power,removereusable,,none,2,YES,NO,,1,,,,,,,,,,,
Berlin Massachusetts Key_upgraded,Get a dice you already have|[gray](Reuseable),1,var seen = []; for (mydice in self.dicepool){ if (mydice.available() && mydice != actualdice[0] && seen[seen.indexOf(mydice.basevalue)] == null ){ seen.push(mydice.basevalue); } } if(seen.length > 0) { shuffle(seen); givedice(seen[0]); } else { givedice(d); self.textparticle(~Only 1 dice!~); },Light Switch,NORMAL,,PINK,,,,none,3,YES,NO,,,,,,,,,,,,,
Slim Jim,Split a <double> in two,1,if(d > 6) { self.textparticle(~stop using booster pack!!~); } else { if(d < 4){ var doub = d * 2; givedice(split(doub)| ~splitdice~); } else if(d == 4){ var r = rand([6|5|4|3|2]); givedice([r|8 - r]| ~splitdice~); } else if(d == 5){ var r = rand([6|5|4]); givedice([r|10 - r]| ~splitdice~); } else { givedice([6|6]| ~splitdice~); } },Trinity,MAX4,,GREEN,simplify,change_power,,none,0,YES,NO,,1,,,,,,,,,,,
Slim Jim_downgraded,Split a <d6> in two,1,givedice(split(d)| ~splitdice~);,Trinity,MAX4,,GREEN,,,,none,0,YES,NO,,,,,,,,,,,,,
Retreat,Convert half of your|[shield]shield to [heart]health,1,attackself(getstatusself(SHIELD) * -0.5); removestatusself(SHIELD|getstatusself(SHIELD) * 0.5);,Health Pack,COUNTDOWN,12,ORANGE,change_power,change_function,,_heal,0,YES,NO,,1,,,,,,,,,,,
Retreat_upgraded,Convert half of your|[shield]shield to [heart]health,1,attackself(getstatusself(SHIELD) * -0.5); removestatusself(SHIELD|getstatusself(SHIELD) * 0.5);,Health Pack,COUNTDOWN,9,ORANGE,,,,_heal,0,YES,NO,,,,,,,,,,,,,
Retreat_downgraded,Remove all your [shield]shield[;]|convert half to [heart]health,1,attackself(getstatusself(SHIELD) * -0.5); removestatusself(SHIELD|ALL);,Health Pack,COUNTDOWN,12,ORANGE,,,,_heal,0,YES,NO,,,,,,,,,,,,,
Retreat_weakened,Remove all your [shield]shield[;]|convert half to [heart]health,1,attackself(getstatusself(SHIELD) * -0.5); removestatusself(SHIELD|ALL);,Health Pack,COUNTDOWN,9,ORANGE,,,,_heal,0,YES,NO,,,,,,,,,,,,,
Watering Can,Dice value -1|(Cost [mana]1[]: return two dice),1,if(getstatusself(MANA) > 0) { removestatusself(MANA|1); if(d < 3) { givedice([1|1]); } else { givedice([d-1|d-2]); } } else { givedice(d-1); },Meganudge,MIN2,,BRIGHTCYAN,change_power,complicate,,,0,YES,NO,,1,,,,,,,,,,,
Watering Can_upgraded,Dice value -1|(Cost [mana]1[]: return two dice)|[gray](Reusable),1,if(getstatusself(MANA) > 0) { removestatusself(MANA|1); if(d < 3) { givedice([1|1]); } else { givedice([d-1|d-2]); } } else { givedice(d-1); },Meganudge,MIN2,,BRIGHTCYAN,,,,,2,YES,NO,,,,,,,,,,,,,
Sucker Punch,Do [sword]6[;] return both dice|[gray](must be first action),1,attack(6); givedice([actualdice[0].basevalue|actualdice[1].basevalue]);,Shuriken,NORMAL|NORMAL,8,GREEN,change_power,change_power,,_damage,0,NO,NO,,1,givedice([actualdice[0].basevalue|actualdice[1].basevalue]);,,,,,,if(!onlimit) { if(e.availablethisturn == true) { if(actualdice == null # actualdice.length < 2) { e.animate(~flashandshake~); e.availablethisturn = false; e.unavailabletext = e.displayname; e.unavailabledetails = [~This card must be used~|~first every turn.~]; } else if(actualdice[0].basevalue + actualdice[1].basevalue != 8 && e.availablethisturn == true) {e.animate(~flashandshake~); e.availablethisturn = false; e.unavailabledetails = [~This card must be used~|~first every turn.~]; } } },,,,
Sucker Punch_upgraded,Do [sword]6[;] return both dice|[gray](must be second action),1,attack(6); givedice([actualdice[0].basevalue|actualdice[1].basevalue]);,Shuriken,NORMAL|NORMAL,8,GREEN,,,,_damage,0,NO,NO,,,givedice([actualdice[0].basevalue|actualdice[1].basevalue]);,self.setvar(~lstrike~[;]0); e.availablethisturn = false; e.unavailabledetails = [~This card must be used~|~second every turn.~];,,self.setvar(~lstrike~[;]0); e.availablethisturn = false; e.unavailabletext = e.displayname; e.unavailabledetails = [~This card must be used~|~second every turn.~];,,,if(!onlimit) { self.setvar(~lstrike~[;]self.getvar(~lstrike~)+1); if (self.getvar(~lstrike~) == 1 && e.availablethisturn == false) { e.animate(~flashandshake~); e.availablethisturn = true; } if (self.getvar(~lstrike~) > 1) { if(actualdice == null # actualdice.length < 2) { e.animate(~flashandshake~); e.availablethisturn = false; e.unavailabletext = e.displayname; e.unavailabledetails = [~This card must be used~|~second every turn.~]; } else if(actualdice[0].basevalue + actualdice[1].basevalue != 8 && e.availablethisturn == true) {e.animate(~flashandshake~); e.availablethisturn = false; e.unavailabletext = e.displayname; e.unavailabledetails = [~This card must be used~|~second every turn.~]; } } },,,,
Sucker Punch_downgraded,Do [sword]6[;] return a dice|[gray](must be first action),1,attack(6);  var returndice = rand([actualdice[0].basevalue|actualdice[1].basevalue]); givedice(returndice);,Shuriken,NORMAL|NORMAL,8,GREEN,,,,_damage,0,NO,NO,,,var returndice = rand([actualdice[0].basevalue|actualdice[1].basevalue]); givedice(returndice);,,,,,,if(!onlimit) { if(e.availablethisturn == true) { if(actualdice == null # actualdice.length < 2) { e.animate(~flashandshake~); e.availablethisturn = false; e.unavailabletext = e.displayname; e.unavailabledetails = [~This card must be used~|~first every turn.~]; } else if(actualdice[0].basevalue + actualdice[1].basevalue != 8 && e.availablethisturn == true) {e.animate(~flashandshake~); e.availablethisturn = false; e.unavailabledetails = [~This card must be used~|~first every turn.~]; } } },,,,
Innovate,Get a dice you don't have,1,var notseen = [1|2|3|4|5|6]; notseen.remove(d); for (mydice in self.dicepool){ if (mydice.available() && notseen[notseen.indexOf(mydice.basevalue)] != null) {notseen.remove(mydice.basevalue);} } if (notseen.length == 0) {givedice(d); self.textparticle(~You've got all dice!~);} else { shuffle(notseen); givedice(notseen[0]); },Reroll,NORMAL,,GREEN,change_power,change_power,,,0,YES,NO,,1,,,,,,,,,,,
Innovate_upgraded,Get a dice you don't have|,1,var notseen = [1|2|3|4|5|6]; notseen.remove(d); for (mydice in self.dicepool){ if (mydice.available() && notseen[notseen.indexOf(mydice.basevalue)] != null) {notseen.remove(mydice.basevalue);} } if (notseen.length == 0) {givedice(d); self.textparticle(~You've got all dice!~);} else { shuffle(notseen); givedice(notseen[0]); },Reroll,NORMAL,,GREEN,,,,,2,YES,NO,,,,,,,,,,,,,
Innovate_downgraded,Get a 4[;] if you don't have one,1,var flag = true; for (mydice in self.dicepool){ if (mydice.available() && mydice.basevalue == 4) {flag = false; } } if (flag == false) {givedice(d); self.textparticle(~You've got a 4!~);} else { givedice(4); },Reroll,NORMAL,,GREEN,,,,,0,YES,NO,,,,,,,,,,,,,
Broadkunai,Do [sword]<double> damage|[gray](Reuseable),1,attack(d*2);,Steal,MAX2,,RED,change_power,decreaserange,,_damage,3,NO,NO,,,,,,,,,,,,,
Broadkunai_upgraded,Do [sword]<double> damage|[gray](Reuseable),1,attack(d*2);,Steal,MAX2,,RED,,,,_damage,-1,NO,NO,,,,,,,,,,,,,
Hell's Bells,Inflict [fire]1 burn per|[weaken]1 weaken on enemy,1,inflict(FIRE|getstatus(WEAKEN)); /*same situation here as with funk blaster*/,Hellfire,COUNTDOWN,18,RED,change_power,change_function,,_fire,0,NO,NO,,,,,,,,,,,,,
Hell's Bells_upgraded,Inflict [fire]1 burn per|[weaken]1 weaken on enemy,1,inflict(FIRE|getstatus(WEAKEN));,Hellfire,COUNTDOWN,12,RED,,,,_fire,0,NO,NO,,,,,,,,,,,,,
Hell's Bells_downgraded,Inflict [fire]1 burn per|[weaken]2 weaken on enemy,1,var f = getstatus(WEAKEN) * 0.5; if (f % 1 != 0) { f = f - 0.5; } inflict(FIRE|f);,Hellfire,COUNTDOWN,18,RED,,,,_fire,0,NO,NO,,,,,,,,,,,,,
Hell's Bells_weakened,Inflict [fire]1 burn per|[weaken]2 weaken on enemy,1,var f = getstatus(WEAKEN) * 0.5; if (f % 1 != 0) { f = f - 0.5; } inflict(FIRE|f);,Hellfire,COUNTDOWN,12,RED,,,,_fire,0,NO,NO,,,,,,,,,,,,,
Jingle Bells,Inflict [ice]1 freeze per|[weaken]1 weaken on enemy,1,inflict(ICE|getstatus(WEAKEN));,Arctic Storm,COUNTDOWN,18,BRIGHTCYAN,change_power,change_function,,_ice,0,NO,NO,,,,,,,,,,,,,
Jingle Bells_upgraded,Inflict [ice]1 freeze per|[weaken]1 weaken on enemy,1,inflict(ICE|getstatus(WEAKEN));,Arctic Storm,COUNTDOWN,12,BRIGHTCYAN,,,,_ice,0,NO,NO,,,,,,,,,,,,,
Jingle Bells_downgraded,Inflict [ice]1 freeze per|[weaken]2 weaken on enemy,1,var f = getstatus(WEAKEN) * 0.5; if (f % 1 != 0) { f = f - 0.5; } inflict(ICE|f); /* the f is for freeze */,Arctic Storm,COUNTDOWN,18,BRIGHTCYAN,,,,_ice,0,NO,NO,,,,,,,,,,,,,
Jingle Bells_weakened,Inflict [ice]1 freeze per|[weaken]2 weaken on enemy,1,var f = getstatus(WEAKEN) * 0.5; if (f % 1 != 0) { f = f - 0.5; } inflict(ICE|f);,Arctic Storm,COUNTDOWN,12,BRIGHTCYAN,,,,_ice,0,NO,NO,,,,,,,,,,,,,
Disco Floor,Inflict [shock]1 shock per|[weaken]1 weaken on enemy,1,inflict(SHOCK|getstatus(WEAKEN));,Electrify,COUNTDOWN,18,PINK,change_power,change_function,,_shock,0,NO,NO,,,,,,e.changecolour(rand([~YELLOW~|~GREEN~|~BLUE~|~RED~|~PURPLE~|~PINK~|~ORANGE~]));,,,,,,,
Disco Floor_upgraded,Inflict [shock]1 shock per|[weaken]1 weaken on enemy,1,inflict(SHOCK|getstatus(WEAKEN));,Electrify,COUNTDOWN,12,PINK,,,,_shock,0,NO,NO,,,,,,e.changecolour(rand([~YELLOW~|~GREEN~|~BLUE~|~RED~|~PURPLE~|~PINK~|~ORANGE~]));,,,,,,,
Disco Floor_downgraded,Inflict [shock]1 shock per|[weaken]2 weaken on enemy,1,var f = getstatus(WEAKEN) * 0.5; if (f % 1 != 0) { f = f - 0.5; } inflict(SHOCK|f); /* the f is for fuckiambeinghitbyalightningbolt */,Electrify,COUNTDOWN,18,PINK,,,,_shock,0,NO,NO,,,,,,,,,,,,,
Disco Floor_weakened,Inflict [shock]1 shock per|[weaken]2 weaken on enemy,1,var f = getstatus(WEAKEN) * 0.5; if (f % 1 != 0) { f = f - 0.5; } inflict(SHOCK|f);,Electrify,COUNTDOWN,12,PINK,,,,_shock,0,NO,NO,,,,,,,,,,,,,
Drill,Inflict [weaken]<d6> weaken,2,inflict(WEAKEN|d);,Burrower,MAX3,,ORANGE,change_power,change_function,,_weaken,0,NO,NO,,,,,,,,,,,,,
Drill_downgraded,Do [weaken]<d6> damage,2,attack(d|WEAKEN);,Burrower,MAX3,,ORANGE,,,,_weaken,0,NO,NO,,,,,,,,,,,,,
Drill_upgraded,Do [weaken]<d6> damage[;] then|inflict [weaken]<d6> weaken,2,attack(d|WEAKEN); inflict(WEAKEN|d);,Burrower,MAX3,,ORANGE,,,,_weaken,0,NO,NO,,,,,,,,,,,,,
Dril,i love saiyng shit like [quote]Yow!|This kittens got Claws![quote]|whenever a woman stabs|me <var:yow> times in the neck|and chest,2,attack(1);,Throw Dice,COUNTDOWN,45,ORANGE,,change_power,,_damage,0,NO,NO,excludefromrandomlists,,,,,self.setvar(~yow~|38);,,,,if (self.getvar(~yow~) > 0) { inflictself(FURY); self.setvar(~yow~|self.getvar(~yow~)-1); },,,
Dril_downgraded,setting foward the|doomsday clock a little bit|because i saw a guy with|yakuza tattoos knifing the|shit out of a mattress,2,jinx(~Doomsday~|~take [sword]38 damage~|~Take [sword]38 damage~|~attack(38); sfxdamage(null|38);~|target|self|2|(d * 3));  sfx(~_thinghappens~);,Throw Dice,COUNTDOWN,45,RED,,,,_damage,0,NO,NO,excludefromrandomlists,,,,,,,,,,,,
Kale Bat,Do [sword]<slotdoubles>. If this defeats[;]|gain max HP equal to excess|damage[;] and destroy this,2,var thp = target.hp; attack(d); if(target.hp <= 0){ var gain = thp - d; gain -= getstatus(~alternate_weaken~); gain -= getstatusself(~extradamage~); gain += getstatus(~reduce~); if(gain < 0) { self.maxhp -= gain; attackself(gain); sfx(~_heal~); } if(self.layout == ~DECK~) { var deleteindex = -1; for(i in 0...Deck.getcards(~all~).length) if(Deck.getcards(~all~)[i].equipment == e) { deleteindex = i; break; } Deck.getcards(~all~)[deleteindex].delete(); } else { e.name = ~ncrsaysremovethis~; removeequipment(~ncrsaysremovethis~); } },Healthy Eating,DOUBLES|DOUBLES,,GREEN,change_power,change_function,,_damage,0,NO,NO,,,,,,,,,,,,,
Kale Bat_upgraded,Do [sword]<d6>. If this defeats[;]|gain max HP equal to excess|damage[;] and destroy this,2,var thp = target.hp; attack(d); if(target.hp <= 0){ var gain = thp - d; gain -= getstatus(~alternate_weaken~); gain -= getstatusself(~extradamage~); gain += getstatus(~reduce~); if(gain < 0) { self.maxhp -= gain; attackself(gain); sfx(~_heal~); } if(self.layout == ~DECK~) { var deleteindex = -1; for(i in 0...Deck.getcards(~all~).length) if(Deck.getcards(~all~)[i].equipment == e) { deleteindex = i; break; } Deck.getcards(~all~)[deleteindex].delete(); } else { e.name = ~ncrsaysremovethis~; removeequipment(~ncrsaysremovethis~); } },Healthy Eating,NORMAL,,GREEN,,,,_damage,0,NO,NO,,,,,,,,,,,,,
Kale Bat_downgraded,Do [sword]6. If this defeats[;]|gain max HP equal to excess|damage[;] and destroy this,2,d = 6; var thp = target.hp; attack(d); if(target.hp <= 0){ var gain = thp - d; gain -= getstatus(~alternate_weaken~); gain -= getstatusself(~extradamage~); gain += getstatus(~reduce~); if(gain < 0) { self.maxhp -= gain; attackself(gain); sfx(~_heal~); } if(self.layout == ~DECK~) { var deleteindex = -1; for(i in 0...Deck.getcards(~all~).length) if(Deck.getcards(~all~)[i].equipment == e) { deleteindex = i; break; } Deck.getcards(~all~)[deleteindex].delete(); } else { e.name = ~ncrsaysremovethis~; removeequipment(~ncrsaysremovethis~); } },Healthy Eating,REQUIRE6|REQUIRE6,,GREEN,,,,_damage,0,NO,NO,,,,,,,,,,,,,
Platinum Blade,Do [sword]<d6> damage. On three|6s in a row[;] start an extra|turn & take this out of play,2,trace(~here's me on execute:~); trace(self.getvar(~fixedeqlist~).indexOf(e)); var myfixedeqlist = self.getvar(~fixedeqlist~); var myname = ~platinumblade~ + myfixedeqlist.indexOf(e); attack(d); sfxdamage(target|d); if(d == 6) { sfx(~_plasma~); self.setvar(myname|self.getvar(myname) + 1); } else { self.resetvar(myname); } if(self.getvar(myname) >= 3) { if(getstatusself(EXTRATURN) < 1) { inflictself(EXTRATURN); } self.resetvar(myname); e.onceperbattle = true; e.usedthisbattle = true; self.endturnnow(); },Time Stop,NORMAL,,PINK,change_power,change_power,,none,0,NO,NO,cannotreuse,,,var myfixedeqlist = self.getvar(~fixedeqlist~); if(myfixedeqlist.length > 0) { var myname = ~platinumblade~ + myfixedeqlist.indexOf(e); self.resetvar(myname); } self.resetvar(~fixedeqlist~); self.setvar(~fixedeqlist~|self.equipment.copy());,var myfixedeqlist = self.getvar(~fixedeqlist~); if(myfixedeqlist.length > 0) { var myname = ~platinumblade~ + myfixedeqlist.indexOf(e); self.resetvar(myname); } self.resetvar(~fixedeqlist~); ,e.maintainfury = false; e.preventdefault = false;,,,trace(~here's me:~); trace(self.getvar(~fixedeqlist~).indexOf(e)),,,var myfixedeqlist = self.getvar(~fixedeqlist~); var myname = ~platinumblade~ + myfixedeqlist.indexOf(e); if(d == 6 && self.getvar(myname) >= 2) { e.maintainfury = true; e.preventdefault = true; },
Platinum Blade_upgraded,Do [sword]<d6> damage. On three|6s in a row[;] gain an extra|turn & take this out of play,2,var myfixedeqlist = self.getvar(~fixedeqlist~); var myname = ~platinumblade~ + myfixedeqlist.indexOf(e); attack(d); sfxdamage(target|d); if(d == 6) { sfx(~_plasma~); self.setvar(myname|self.getvar(myname) + 1); } else { self.resetvar(myname); } if(self.getvar(myname) >= 3) { if(getstatusself(EXTRATURN) < 1) { inflictself(EXTRATURN); } self.resetvar(myname); e.onceperbattle = true; e.usedthisbattle = true; },Time Stop,NORMAL,,PINK,,,,none,0,NO,NO,cannotreuse,,,var myfixedeqlist = self.getvar(~fixedeqlist~); if(myfixedeqlist.length > 0) { var myname = ~platinumblade~ + myfixedeqlist.indexOf(e); self.resetvar(myname); } self.resetvar(~fixedeqlist~); self.setvar(~fixedeqlist~|self.equipment.copy());,var myfixedeqlist = self.getvar(~fixedeqlist~); if(myfixedeqlist.length > 0) { var myname = ~platinumblade~ + myfixedeqlist.indexOf(e); self.resetvar(myname); } self.resetvar(~fixedeqlist~); ,e.maintainfury = false; e.preventdefault = false;,,,trace(~here's me:~); trace(self.getvar(~fixedeqlist~).indexOf(e));,,,,
Platinum Blade_downgraded,Do [sword]<d6> damage. On three|6s in a row[;] start an extra|turn & take this out of play,2,var myfixedeqlist = self.getvar(~fixedeqlist~); var myname = ~platinumblade~ + myfixedeqlist.indexOf(e); attack(d); sfxdamage(target|d); if(d == 6) { sfx(~_plasma~); self.setvar(myname|self.getvar(myname) + 1); } else { self.resetvar(myname); } if(self.getvar(myname) >= 3) { if(getstatusself(EXTRATURN) < 1) { inflictself(EXTRATURN); } self.resetvar(myname); e.onceperbattle = true; e.usedthisbattle = true; self.endturnnow(); },Time Stop,REQUIRE6,,PINK,,,,none,0,NO,NO,cannotreuse,,,var myfixedeqlist = self.getvar(~fixedeqlist~); if(myfixedeqlist.length > 0) { var myname = ~platinumblade~ + myfixedeqlist.indexOf(e); self.resetvar(myname); } self.resetvar(~fixedeqlist~); self.setvar(~fixedeqlist~|self.equipment.copy());,var myfixedeqlist = self.getvar(~fixedeqlist~); if(myfixedeqlist.length > 0) { var myname = ~platinumblade~ + myfixedeqlist.indexOf(e); self.resetvar(myname); } self.resetvar(~fixedeqlist~); ,e.maintainfury = false; e.preventdefault = false;,,,trace(~here's me:~); trace(self.getvar(~fixedeqlist~).indexOf(e));,,,var myfixedeqlist = self.getvar(~fixedeqlist~); var myname = ~platinumblade~ + myfixedeqlist.indexOf(e); if(d == 6 && self.getvar(myname) >= 2) { e.maintainfury = true; e.preventdefault = true; },
Wrongo,Next enemy move applies|to both you and them,1,jinx(~Wrongo~|~next move applies to you as well~|~Next move applies to you as well~|~inflict(\~reversenexttarget\~); inflict(FURY); sfx(\~_fury\~);~|target|self|1|0);,Dramatic Pause,COUNTDOWN,12,RED,change_power,change_power,fury,none,0,NO,NO,,1,,,,,,,,,,e.preventdefault = true; e.maintainfury = true; /*reversenexttarget doesn't stack*/,
Wrongo_upgraded,Next enemy move applies|to both you and them,1,jinx(~Wrongo+~|~next move applies to you as well~|~Next move applies to you as well~|~inflict(\~reversenexttarget\~); inflict(FURY); sfx(\~_fury\~);~|target|self|1|0);,Dramatic Pause,COUNTDOWN,8,RED,,,,none,0,NO,NO,,,,,,,,,,,,e.preventdefault = true; e.maintainfury = true;,
Wrongo_downgraded,Next enemy move|applies twice,1,jinx(~Wrongo-~|~next move applies twice~|~Next move applies twice~|~inflict(FURY); sfx(\~_fury\~);~|target|self|1|0);,Dramatic Pause,COUNTDOWN,12,RED,,,,none,0,NO,NO,,,,,,,,,,,,e.preventdefault = true; e.maintainfury = true;,
Wrongo_weakened,Next enemy move|applies twice,1,jinx(~Wrongo-~|~next move applies twice~|~Next move applies twice~|~inflict(FURY); sfx(\~_fury\~);~|target|self|1|0);,Dramatic Pause,COUNTDOWN,8,RED,,,,none,0,NO,NO,,,,,,,,,,,,e.preventdefault = true; e.maintainfury = true;,
Wrongo?,Next enemy move applies|to both you and them[;] and|is unusable the turn after,1,jinx(~Wrongo?~|~next move applies to you as well[;] and is unusable the turn after~|~Next move applies to you as well[;] and is unusable the turn after~|~inflict(\~reversenexttarget\~); inflict(FURY); sfx(\~_fury\~);~|target|self|1|0);,Dramatic Pause,COUNTDOWN,12,RED,change_power,change_power,,none,0,NO,NO,alternateversion,1,,,,,,,,,,e.preventdefault = true; e.maintainfury = true;,
Wrongo?_upgraded,Next enemy move applies|to both you and them[;] and|is unusable the turn after,1,jinx(~Wrongo?+~|~next move applies to you as well[;] and is unusable the turn after~|~Next move applies to you as well[;] and is unusable the turn after~|~inflict(\~reversenexttarget\~); inflict(FURY); sfx(\~_fury\~);~|target|self|1|0);,Dramatic Pause,COUNTDOWN,8,RED,,,,none,0,NO,NO,alternateversion,,,,,,,,,,,e.preventdefault = true; e.maintainfury = true;,
Wrongo?_downgraded,Next enemy move|applies twice[;] but is|unusable the turn after,1,jinx(~Wrongo?-~|~next move applies twice[;] but is unusable the turn after~|~Next move applies twice[;] but is unusable the turn after~|~inflict(FURY); sfx(\~_fury\~);~|target|self|1|0);,Dramatic Pause,COUNTDOWN,12,RED,,,,none,0,NO,NO,alternateversion,,,,,,,,,,,e.preventdefault = true; e.maintainfury = true;,
Wrongo?_weakened,Next enemy move|applies twice[;] but is|unusable the turn after,1,jinx(~Wrongo?-~|~next move applies twice[;] but is unusable the turn after~|~Next move applies twice[;] but is unusable the turn after~|~inflict(FURY); sfx(\~_fury\~);~|target|self|1|0);,Dramatic Pause,COUNTDOWN,8,RED,,,,none,0,NO,NO,alternateversion,,,,,,,,,,,e.preventdefault = true; e.maintainfury = true;,
Revolver@ncrmod,Do damage equal to|2x excess value inserted,2,var myname = ~dicehistorytemp~ + self.getvar(~fixedeqlist~).indexOf(e); trace(~----~); trace(e.dicehistory.length); trace(e.dicehistory); trace(self.getvar(myname)); trace(self.getvar(myname).length); trace(~----~); if((e.dicehistory.length < 1) && self.getvar(myname).length >= e.dicehistory.length && self.getvar(myname).length != null) { trace(~thingdoing!~); e.dicehistory = self.getvar(myname).concat(e.dicehistory); } self.setvar(myname|e.dicehistory.copy()); var sum = 0; var i = 0; while(true) {  if(i > e.dicehistory.length - 1) { trace(~UHHHHHH~); break; }  sum = sum + e.dicehistory[i].basevalue;  trace(sum); trace(~i: ~ + i); i++;  if(sum >= e.countdown) break; } trace(~SPAM~); trace(sum); if (sum - e.countdown > 0) {  attack(2 * (sum - e.countdown)); sfx(~_fire~|~~|0.1);  /*sfxdamage(2 * (sum - e.countdown));*/ } else self.textparticle(~No effect!~); if(self.getvar(~furying~) < 1) { trace(~resetting!~); e.dicehistory = []; self.resetvar(myname); } self.setvar(~furying~|self.getvar(~furying~) - 1);,Dice Bash,COUNTDOWN,9,RED,change_power,change_power,,_damage,0,NO,NO,cannotreuse,,,var myfixedeqlist = self.getvar(~fixedeqlist~); if(myfixedeqlist.length > 0) { var myname = ~dicehistorytemp~ + myfixedeqlist.indexOf(e); self.resetvar(myname); } self.resetvar(~fixedeqlist~); self.setvar(~fixedeqlist~|self.equipment.copy());,var myfixedeqlist = self.getvar(~fixedeqlist~); if(myfixedeqlist.length > 0) { var myname = ~dicehistorytemp~ + myfixedeqlist.indexOf(e); self.resetvar(myname); } self.resetvar(~fixedeqlist~); ,if(e.timesused > 0) { var myname = ~dicehistorytemp~ + self.getvar(~fixedeqlist~).indexOf(e); e.dicehistory = []; self.resetvar(myname); } e.timesused = 0; /*kludge if this card gets cursed or is dodged*/,trace(~here's me:~); trace(self.getvar(~fixedeqlist~).indexOf(e));,,,,,self.setvar(~furying~|getstatusself(FURY)); trace(~fury!: ~ + self.getvar(~furying~));,trace(~here's me:~); trace(self.getvar(~fixedeqlist~).indexOf(e)); var myname = ~dicehistorytemp~ + self.getvar(~fixedeqlist~).indexOf(e); trace(e.dicehistory.length); trace(e.dicehistory); trace(self.getvar(myname)); trace(self.getvar(myname).length); if((e.dicehistory.length == 1) && self.getvar(myname).length >= e.dicehistory.length && self.getvar(myname).length != null) { trace(~thingdoing!~); e.dicehistory = self.getvar(myname).concat(e.dicehistory); } self.setvar(myname|e.dicehistory.copy());
Revolver@ncrmod_upgraded,Do damage equal to|2x excess value inserted,1,var myname = ~dicehistorytemp~ + self.getvar(~fixedeqlist~).indexOf(e); trace(~----~); trace(e.dicehistory.length); trace(e.dicehistory); trace(self.getvar(myname)); trace(self.getvar(myname).length); trace(~----~); if((e.dicehistory.length < 1) && self.getvar(myname).length >= e.dicehistory.length && self.getvar(myname).length != null) { trace(~thingdoing!~); e.dicehistory = self.getvar(myname).concat(e.dicehistory); } self.setvar(myname|e.dicehistory.copy()); var sum = 0; var i = 0; while(true) {  if(i > e.dicehistory.length - 1) { trace(~UHHHHHH~); break; }  sum = sum + e.dicehistory[i].basevalue;  trace(sum); trace(~i: ~ + i); i++;  if(sum >= e.countdown) break; } trace(~SPAM~); trace(sum); if (sum - e.countdown > 0) {  attack(2 * (sum - e.countdown)); sfx(~_fire~|~~|0.1);  /*sfxdamage(2 * (sum - e.countdown));*/ } else self.textparticle(~No effect!~); if(self.getvar(~furying~) < 1) { trace(~resetting!~); e.dicehistory = []; self.resetvar(myname); } self.setvar(~furying~|self.getvar(~furying~) - 1);,Dice Bash,COUNTDOWN,9,RED,,,,_damage,0,NO,NO,cannotreuse,,,var myfixedeqlist = self.getvar(~fixedeqlist~); if(myfixedeqlist.length > 0) { var myname = ~dicehistorytemp~ + myfixedeqlist.indexOf(e); self.resetvar(myname); } self.resetvar(~fixedeqlist~); self.setvar(~fixedeqlist~|self.equipment.copy());,var myfixedeqlist = self.getvar(~fixedeqlist~); if(myfixedeqlist.length > 0) { var myname = ~dicehistorytemp~ + myfixedeqlist.indexOf(e); self.resetvar(myname); } self.resetvar(~fixedeqlist~); ,if(e.timesused > 0) { var myname = ~dicehistorytemp~ + self.getvar(~fixedeqlist~).indexOf(e); e.dicehistory = []; self.resetvar(myname); } e.timesused = 0;,trace(~here's me:~); trace(self.getvar(~fixedeqlist~).indexOf(e));,,,,,self.setvar(~furying~|getstatusself(FURY)); trace(~fury!: ~ + self.getvar(~furying~));,trace(~here's me:~); trace(self.getvar(~fixedeqlist~).indexOf(e)); var myname = ~dicehistorytemp~ + self.getvar(~fixedeqlist~).indexOf(e); trace(e.dicehistory.length); trace(e.dicehistory); trace(self.getvar(myname)); trace(self.getvar(myname).length); if((e.dicehistory.length == 1) && self.getvar(myname).length >= e.dicehistory.length && self.getvar(myname).length != null) { trace(~thingdoing!~); e.dicehistory = self.getvar(myname).concat(e.dicehistory); } self.setvar(myname|e.dicehistory.copy());
Revolver@ncrmod_downgraded,Do [sword]5 damage,2,attack(5); sfx(~_fire~|~~|0.1); e.dicehistory = []; self.resetvar(~dicehistorytemp~ + self.getvar(~fixedeqlist~).indexOf(e));,Dice Bash,COUNTDOWN,9,RED,,,,_damage,0,NO,NO,cannotreuse,,,,var myfixedeqlist = self.getvar(~fixedeqlist~); if(myfixedeqlist.length > 0) { var myname = ~dicehistorytemp~ + myfixedeqlist.indexOf(e); self.resetvar(myname); } self.resetvar(~fixedeqlist~); ,if(e.timesused > 0) { var myname = ~dicehistorytemp~ + self.getvar(~fixedeqlist~).indexOf(e); e.dicehistory = []; self.resetvar(myname); } e.timesused = 0;,trace(~here's me:~); trace(self.getvar(~fixedeqlist~).indexOf(e));,,,,,,trace(~here's me:~); trace(self.getvar(~fixedeqlist~).indexOf(e)); var myname = ~dicehistorytemp~ + self.getvar(~fixedeqlist~).indexOf(e); trace(e.dicehistory.length); trace(e.dicehistory); trace(self.getvar(myname)); trace(self.getvar(myname).length); if((e.dicehistory.length == 1) && self.getvar(myname).length >= e.dicehistory.length && self.getvar(myname).length != null) { trace(~thingdoing!~); e.dicehistory = self.getvar(myname).concat(e.dicehistory); } self.setvar(myname|e.dicehistory.copy());
Revolver@ncrmod_weakened,Do [sword]5 damage,1,attack(5); sfx(~_fire~|~~|0.1); e.dicehistory = []; self.resetvar(~dicehistorytemp~ + self.getvar(~fixedeqlist~).indexOf(e));,Dice Bash,COUNTDOWN,9,RED,,,,_damage,0,NO,NO,cannotreuse,,,,var myfixedeqlist = self.getvar(~fixedeqlist~); if(myfixedeqlist.length > 0) { var myname = ~dicehistorytemp~ + myfixedeqlist.indexOf(e); self.resetvar(myname); } self.resetvar(~fixedeqlist~); ,if(e.timesused > 0) { var myname = ~dicehistorytemp~ + self.getvar(~fixedeqlist~).indexOf(e); e.dicehistory = []; self.resetvar(myname); } e.timesused = 0;,trace(~here's me:~); trace(self.getvar(~fixedeqlist~).indexOf(e));,,,,,,trace(~here's me:~); trace(self.getvar(~fixedeqlist~).indexOf(e)); var myname = ~dicehistorytemp~ + self.getvar(~fixedeqlist~).indexOf(e); trace(e.dicehistory.length); trace(e.dicehistory); trace(self.getvar(myname)); trace(self.getvar(myname).length); if((e.dicehistory.length == 1) && self.getvar(myname).length >= e.dicehistory.length && self.getvar(myname).length != null) { trace(~thingdoing!~); e.dicehistory = self.getvar(myname).concat(e.dicehistory); } self.setvar(myname|e.dicehistory.copy());
Cubby,Receive all dice|put into this,1,var myname = ~dicehistorytemp~ + self.getvar(~fixedeqlist~).indexOf(e); trace(~----~); trace(e.dicehistory.length); trace(e.dicehistory); trace(self.getvar(myname)); trace(self.getvar(myname).length); trace(~----~); if((e.dicehistory.length < 1) && self.getvar(myname).length >= e.dicehistory.length && self.getvar(myname).length != null) { trace(~thingdoing!~); e.dicehistory = self.getvar(myname).concat(e.dicehistory); } self.setvar(myname|e.dicehistory.copy()); givedice(e.dicehistory); if(self.getvar(~furying~) < 1) { trace(~resetting!~); e.dicehistory = []; self.resetvar(myname); } self.setvar(~furying~|self.getvar(~furying~) - 1); /*the actual code (givedice(e.dicehistory)) is wrapped around a template for making e.dicehistory stuff work with fury and handle being weakened*/,Magic Dice,COUNTDOWN,7,GREEN,change_power,change_power,,none,0,YES,NO,cannotreuse,1,,var myfixedeqlist = self.getvar(~fixedeqlist~); if(myfixedeqlist.length > 0) { var myname = ~dicehistorytemp~ + myfixedeqlist.indexOf(e); self.resetvar(myname); } self.resetvar(~fixedeqlist~); self.setvar(~fixedeqlist~|self.equipment.copy());,var myfixedeqlist = self.getvar(~fixedeqlist~); if(myfixedeqlist.length > 0) { var myname = ~dicehistorytemp~ + myfixedeqlist.indexOf(e); self.resetvar(myname); } self.resetvar(~fixedeqlist~); ,if(e.timesused > 0) { var myname = ~dicehistorytemp~ + self.getvar(~fixedeqlist~).indexOf(e); e.dicehistory = []; self.resetvar(myname); } e.timesused = 0;,,,,,/*var cubbymodulo = (e.remainingcountdown % 6); if(cubbymodulo == 0) { cubbymodulo = 6; } trace(~cubby modulo:~ + cubbymodulo); e.dicehistory.push(cubbymodulo); trace(~dicehistory:~ + e.dicehistory); var cubbysixes = ((e.remainingcountdown - cubbymodulo) / 6); trace(~cubby sixes:~ + cubbysixes); cubbysixes--; trace(~cubby sixes after being reduced:~ + cubbysixes); for(i in 0...cubbysixes) {e.dicehistory.push(6);} trace(~dicehistory:~ + e.dicehistory);*/,self.setvar(~furying~|getstatusself(FURY)); trace(~fury!: ~ + self.getvar(~furying~));,var myname = ~dicehistorytemp~ + self.getvar(~fixedeqlist~).indexOf(e); trace(e.dicehistory.length); trace(e.dicehistory); trace(self.getvar(myname)); trace(self.getvar(myname).length); if((e.dicehistory.length == 1) && self.getvar(myname).length >= e.dicehistory.length && self.getvar(myname).length != null) { trace(~thingdoing!~); e.dicehistory = self.getvar(myname).concat(e.dicehistory); } self.setvar(myname|e.dicehistory.copy());
Cubby_upgraded,Receive all dice|put into this,1,var myname = ~dicehistorytemp~ + self.getvar(~fixedeqlist~).indexOf(e); trace(~----~); trace(e.dicehistory.length); trace(e.dicehistory); trace(self.getvar(myname)); trace(self.getvar(myname).length); trace(~----~); if((e.dicehistory.length < 1) && self.getvar(myname).length >= e.dicehistory.length && self.getvar(myname).length != null) { trace(~thingdoing!~); e.dicehistory = self.getvar(myname).concat(e.dicehistory); } self.setvar(myname|e.dicehistory.copy()); givedice(e.dicehistory); if(self.getvar(~furying~) < 1) { trace(~resetting!~); e.dicehistory = []; self.resetvar(myname); } self.setvar(~furying~|self.getvar(~furying~) - 1);,Magic Dice,COUNTDOWN,13,GREEN,,,,none,0,YES,NO,cannotreuse,,,var myfixedeqlist = self.getvar(~fixedeqlist~); if(myfixedeqlist.length > 0) { var myname = ~dicehistorytemp~ + myfixedeqlist.indexOf(e); self.resetvar(myname); } self.resetvar(~fixedeqlist~); self.setvar(~fixedeqlist~|self.equipment.copy());,var myfixedeqlist = self.getvar(~fixedeqlist~); if(myfixedeqlist.length > 0) { var myname = ~dicehistorytemp~ + myfixedeqlist.indexOf(e); self.resetvar(myname); } self.resetvar(~fixedeqlist~); ,if(e.timesused > 0) { var myname = ~dicehistorytemp~ + self.getvar(~fixedeqlist~).indexOf(e); e.dicehistory = []; self.resetvar(myname); } e.timesused = 0;,,,,,,self.setvar(~furying~|getstatusself(FURY)); trace(~fury!: ~ + self.getvar(~furying~));,var myname = ~dicehistorytemp~ + self.getvar(~fixedeqlist~).indexOf(e); trace(e.dicehistory.length); trace(e.dicehistory); trace(self.getvar(myname)); trace(self.getvar(myname).length); if((e.dicehistory.length == 1) && self.getvar(myname).length >= e.dicehistory.length && self.getvar(myname).length != null) { trace(~thingdoing!~); e.dicehistory = self.getvar(myname).concat(e.dicehistory); } self.setvar(myname|e.dicehistory.copy());
Cubby_downgraded,Roll a new dice,1,givedice(); e.dicehistory = []; self.resetvar(~dicehistorytemp~ + self.getvar(~fixedeqlist~).indexOf(e));,Magic Dice,COUNTDOWN,7,GREEN,,,,none,0,YES,NO,cannotreuse,,,,var myfixedeqlist = self.getvar(~fixedeqlist~); if(myfixedeqlist.length > 0) { var myname = ~dicehistorytemp~ + myfixedeqlist.indexOf(e); self.resetvar(myname); } self.resetvar(~fixedeqlist~); ,if(e.timesused > 0) { var myname = ~dicehistorytemp~ + self.getvar(~fixedeqlist~).indexOf(e); e.dicehistory = []; self.resetvar(myname); } e.timesused = 0;,,,,,,,var myname = ~dicehistorytemp~ + self.getvar(~fixedeqlist~).indexOf(e); trace(e.dicehistory.length); trace(e.dicehistory); trace(self.getvar(myname)); trace(self.getvar(myname).length); if((e.dicehistory.length == 1) && self.getvar(myname).length >= e.dicehistory.length && self.getvar(myname).length != null) { trace(~thingdoing!~); e.dicehistory = self.getvar(myname).concat(e.dicehistory); } self.setvar(myname|e.dicehistory.copy());
Cubby_weakened,Roll a new dice,1,givedice(); e.dicehistory = []; self.resetvar(~dicehistorytemp~ + self.getvar(~fixedeqlist~).indexOf(e));,Magic Dice,COUNTDOWN,13,GREEN,,,,none,0,YES,NO,cannotreuse,,,,var myfixedeqlist = self.getvar(~fixedeqlist~); if(myfixedeqlist.length > 0) { var myname = ~dicehistorytemp~ + myfixedeqlist.indexOf(e); self.resetvar(myname); } self.resetvar(~fixedeqlist~); ,if(e.timesused > 0) { var myname = ~dicehistorytemp~ + self.getvar(~fixedeqlist~).indexOf(e); e.dicehistory = []; self.resetvar(myname); } e.timesused = 0;,,,,,,,var myname = ~dicehistorytemp~ + self.getvar(~fixedeqlist~).indexOf(e); trace(e.dicehistory.length); trace(e.dicehistory); trace(self.getvar(myname)); trace(self.getvar(myname).length); if((e.dicehistory.length == 1) && self.getvar(myname).length >= e.dicehistory.length && self.getvar(myname).length != null) { trace(~thingdoing!~); e.dicehistory = self.getvar(myname).concat(e.dicehistory); } self.setvar(myname|e.dicehistory.copy());
Warhammer,Do [shock]8 damage[;] if filled|perfectly[;] inflict [shock]3 shock,2,attack(8|SHOCK); var myname = ~dicehistorytemp~ + self.getvar(~fixedeqlist~).indexOf(e); trace(~----~); trace(e.dicehistory.length); trace(e.dicehistory); trace(self.getvar(myname)); trace(self.getvar(myname).length); trace(~----~); if((e.dicehistory.length < 1) && self.getvar(myname).length >= e.dicehistory.length && self.getvar(myname).length != null) { trace(~thingdoing!~); e.dicehistory = self.getvar(myname).concat(e.dicehistory); } self.setvar(myname|e.dicehistory.copy()); var sum = 0; for (i in 0...e.dicehistory.length) { sum = sum + e.dicehistory[i].basevalue; } if (sum == e.countdown) { inflict(SHOCK|3); sfx(~_shock~); } if(self.getvar(~furying~) < 1) { trace(~resetting!~); e.dicehistory = []; self.resetvar(myname); } self.setvar(~furying~|self.getvar(~furying~) - 1);,Electrify,COUNTDOWN,16,YELLOW,change_power,change_power,,_damage,0,NO,NO,cannotreuse,,,var myfixedeqlist = self.getvar(~fixedeqlist~); if(myfixedeqlist.length > 0) { var myname = ~dicehistorytemp~ + myfixedeqlist.indexOf(e); self.resetvar(myname); } self.resetvar(~fixedeqlist~); self.setvar(~fixedeqlist~|self.equipment.copy());,var myfixedeqlist = self.getvar(~fixedeqlist~); if(myfixedeqlist.length > 0) { var myname = ~dicehistorytemp~ + myfixedeqlist.indexOf(e); self.resetvar(myname); } self.resetvar(~fixedeqlist~); ,if(e.timesused > 0) { var myname = ~dicehistorytemp~ + self.getvar(~fixedeqlist~).indexOf(e); e.dicehistory = []; self.resetvar(myname); } e.timesused = 0;,,,,,,self.setvar(~furying~|getstatusself(FURY)); trace(~fury!: ~ + self.getvar(~furying~));,var myname = ~dicehistorytemp~ + self.getvar(~fixedeqlist~).indexOf(e); trace(e.dicehistory.length); trace(e.dicehistory); trace(self.getvar(myname)); trace(self.getvar(myname).length); if((e.dicehistory.length == 1) && self.getvar(myname).length >= e.dicehistory.length && self.getvar(myname).length != null) { trace(~thingdoing!~); e.dicehistory = self.getvar(myname).concat(e.dicehistory); } self.setvar(myname|e.dicehistory.copy());
Warhammer_upgraded,Do [shock]8 damage[;] if filled|perfectly[;] inflict [shock]3 shock,2,attack(8|SHOCK); var myname = ~dicehistorytemp~ + self.getvar(~fixedeqlist~).indexOf(e); trace(~----~); trace(e.dicehistory.length); trace(e.dicehistory); trace(self.getvar(myname)); trace(self.getvar(myname).length); trace(~----~); if((e.dicehistory.length < 1) && self.getvar(myname).length >= e.dicehistory.length && self.getvar(myname).length != null) { trace(~thingdoing!~); e.dicehistory = self.getvar(myname).concat(e.dicehistory); } self.setvar(myname|e.dicehistory.copy()); var sum = 0; for (i in 0...e.dicehistory.length) { sum = sum + e.dicehistory[i].basevalue; } if (sum == e.countdown) { inflict(SHOCK|3); sfx(~_shock~); } if(self.getvar(~furying~) < 1) { trace(~resetting!~); e.dicehistory = []; self.resetvar(myname); } self.setvar(~furying~|self.getvar(~furying~) - 1);,Electrify,COUNTDOWN,12,YELLOW,,,,_damage,0,NO,NO,cannotreuse,,,var myfixedeqlist = self.getvar(~fixedeqlist~); if(myfixedeqlist.length > 0) { var myname = ~dicehistorytemp~ + myfixedeqlist.indexOf(e); self.resetvar(myname); } self.resetvar(~fixedeqlist~); self.setvar(~fixedeqlist~|self.equipment.copy());,var myfixedeqlist = self.getvar(~fixedeqlist~); if(myfixedeqlist.length > 0) { var myname = ~dicehistorytemp~ + myfixedeqlist.indexOf(e); self.resetvar(myname); } self.resetvar(~fixedeqlist~); ,if(e.timesused > 0) { var myname = ~dicehistorytemp~ + self.getvar(~fixedeqlist~).indexOf(e); e.dicehistory = []; self.resetvar(myname); } e.timesused = 0;,,,,,,self.setvar(~furying~|getstatusself(FURY)); trace(~fury!: ~ + self.getvar(~furying~));,var myname = ~dicehistorytemp~ + self.getvar(~fixedeqlist~).indexOf(e); trace(e.dicehistory.length); trace(e.dicehistory); trace(self.getvar(myname)); trace(self.getvar(myname).length); if((e.dicehistory.length == 1) && self.getvar(myname).length >= e.dicehistory.length && self.getvar(myname).length != null) { trace(~thingdoing!~); e.dicehistory = self.getvar(myname).concat(e.dicehistory); } self.setvar(myname|e.dicehistory.copy());
Warhammer_downgraded,Do [shock]8 damage[;] if filled|perfectly[;] inflict [shock]1 shock,2,attack(8|SHOCK); var myname = ~dicehistorytemp~ + self.getvar(~fixedeqlist~).indexOf(e); trace(~----~); trace(e.dicehistory.length); trace(e.dicehistory); trace(self.getvar(myname)); trace(self.getvar(myname).length); trace(~----~); if((e.dicehistory.length < 1) && self.getvar(myname).length >= e.dicehistory.length && self.getvar(myname).length != null) { trace(~thingdoing!~); e.dicehistory = self.getvar(myname).concat(e.dicehistory); } self.setvar(myname|e.dicehistory.copy()); var sum = 0; for (i in 0...e.dicehistory.length) { sum = sum + e.dicehistory[i].basevalue; } if (sum == e.countdown) { inflict(SHOCK|1); sfx(~_shock~); } if(self.getvar(~furying~) < 1) { trace(~resetting!~); e.dicehistory = []; self.resetvar(myname); } self.setvar(~furying~|self.getvar(~furying~) - 1);,Electrify,COUNTDOWN,16,YELLOW,,,,_damage,0,NO,NO,cannotreuse,,,,var myfixedeqlist = self.getvar(~fixedeqlist~); if(myfixedeqlist.length > 0) { var myname = ~dicehistorytemp~ + myfixedeqlist.indexOf(e); self.resetvar(myname); } self.resetvar(~fixedeqlist~); ,if(e.timesused > 0) { var myname = ~dicehistorytemp~ + self.getvar(~fixedeqlist~).indexOf(e); e.dicehistory = []; self.resetvar(myname); } e.timesused = 0;,,,,,,self.setvar(~furying~|getstatusself(FURY)); trace(~fury!: ~ + self.getvar(~furying~));,var myname = ~dicehistorytemp~ + self.getvar(~fixedeqlist~).indexOf(e); trace(e.dicehistory.length); trace(e.dicehistory); trace(self.getvar(myname)); trace(self.getvar(myname).length); if((e.dicehistory.length == 1) && self.getvar(myname).length >= e.dicehistory.length && self.getvar(myname).length != null) { trace(~thingdoing!~); e.dicehistory = self.getvar(myname).concat(e.dicehistory); } self.setvar(myname|e.dicehistory.copy());
Warhammer_weakened,Do [shock]8 damage[;] if filled|perfectly[;] inflict [shock]1 shock,2,attack(8|SHOCK); var myname = ~dicehistorytemp~ + self.getvar(~fixedeqlist~).indexOf(e); trace(~----~); trace(e.dicehistory.length); trace(e.dicehistory); trace(self.getvar(myname)); trace(self.getvar(myname).length); trace(~----~); if((e.dicehistory.length < 1) && self.getvar(myname).length >= e.dicehistory.length && self.getvar(myname).length != null) { trace(~thingdoing!~); e.dicehistory = self.getvar(myname).concat(e.dicehistory); } self.setvar(myname|e.dicehistory.copy()); var sum = 0; for (i in 0...e.dicehistory.length) { sum = sum + e.dicehistory[i].basevalue; } if (sum == e.countdown) { inflict(SHOCK|1); sfx(~_shock~); } if(self.getvar(~furying~) < 1) { trace(~resetting!~); e.dicehistory = []; self.resetvar(myname); } self.setvar(~furying~|self.getvar(~furying~) - 1);,Electrify,COUNTDOWN,12,YELLOW,,,,_damage,0,NO,NO,cannotreuse,,,,var myfixedeqlist = self.getvar(~fixedeqlist~); if(myfixedeqlist.length > 0) { var myname = ~dicehistorytemp~ + myfixedeqlist.indexOf(e); self.resetvar(myname); } self.resetvar(~fixedeqlist~); ,if(e.timesused > 0) { var myname = ~dicehistorytemp~ + self.getvar(~fixedeqlist~).indexOf(e); e.dicehistory = []; self.resetvar(myname); } e.timesused = 0;,,,,,,self.setvar(~furying~|getstatusself(FURY)); trace(~fury!: ~ + self.getvar(~furying~));,var myname = ~dicehistorytemp~ + self.getvar(~fixedeqlist~).indexOf(e); trace(e.dicehistory.length); trace(e.dicehistory); trace(self.getvar(myname)); trace(self.getvar(myname).length); if((e.dicehistory.length == 1) && self.getvar(myname).length >= e.dicehistory.length && self.getvar(myname).length != null) { trace(~thingdoing!~); e.dicehistory = self.getvar(myname).concat(e.dicehistory); } self.setvar(myname|e.dicehistory.copy());
Warhammer 40K,Do [shock]40000 dmg[;] if filled|perfectly[;] inflict [shock]20000[],2,attack(40000|SHOCK); var myname = ~dicehistorytemp~ + self.getvar(~fixedeqlist~).indexOf(e); trace(~----~); trace(e.dicehistory.length); trace(e.dicehistory); trace(self.getvar(myname)); trace(self.getvar(myname).length); trace(~----~); if((e.dicehistory.length < 1) && self.getvar(myname).length >= e.dicehistory.length && self.getvar(myname).length != null) { trace(~thingdoing!~); e.dicehistory = self.getvar(myname).concat(e.dicehistory); } self.setvar(myname|e.dicehistory.copy()); var sum = 0; for (i in 0...e.dicehistory.length) { sum = sum + e.dicehistory[i].basevalue; } if (sum == e.countdown) { inflict(SHOCK|20000); sfx(~_shock~); } if(self.getvar(~furying~) < 1) { trace(~resetting!~); e.dicehistory = []; self.resetvar(myname); } self.setvar(~furying~|self.getvar(~furying~) - 1);,Electrify,COUNTDOWN,99,YELLOW,change_power,change_power,,_damage,0,NO,NO,cannotreuse,,,var myfixedeqlist = self.getvar(~fixedeqlist~); if(myfixedeqlist.length > 0) { var myname = ~dicehistorytemp~ + myfixedeqlist.indexOf(e); self.resetvar(myname); } self.resetvar(~fixedeqlist~); self.setvar(~fixedeqlist~|self.equipment.copy());,var myfixedeqlist = self.getvar(~fixedeqlist~); if(myfixedeqlist.length > 0) { var myname = ~dicehistorytemp~ + myfixedeqlist.indexOf(e); self.resetvar(myname); } self.resetvar(~fixedeqlist~); ,if(e.timesused > 0) { var myname = ~dicehistorytemp~ + self.getvar(~fixedeqlist~).indexOf(e); e.dicehistory = []; self.resetvar(myname); } e.timesused = 0;,,,,,,self.setvar(~furying~|getstatusself(FURY)); trace(~fury!: ~ + self.getvar(~furying~));,var myname = ~dicehistorytemp~ + self.getvar(~fixedeqlist~).indexOf(e); trace(e.dicehistory.length); trace(e.dicehistory); trace(self.getvar(myname)); trace(self.getvar(myname).length); if((e.dicehistory.length == 1) && self.getvar(myname).length >= e.dicehistory.length && self.getvar(myname).length != null) { trace(~thingdoing!~); e.dicehistory = self.getvar(myname).concat(e.dicehistory); } self.setvar(myname|e.dicehistory.copy());
Warhammer 40K_upgraded,Do [shock]40000 dmg[;] if filled|perfectly[;] inflict [shock]20000[],2,attack(40000|SHOCK); var myname = ~dicehistorytemp~ + self.getvar(~fixedeqlist~).indexOf(e); trace(~----~); trace(e.dicehistory.length); trace(e.dicehistory); trace(self.getvar(myname)); trace(self.getvar(myname).length); trace(~----~); if((e.dicehistory.length < 1) && self.getvar(myname).length >= e.dicehistory.length && self.getvar(myname).length != null) { trace(~thingdoing!~); e.dicehistory = self.getvar(myname).concat(e.dicehistory); } self.setvar(myname|e.dicehistory.copy()); var sum = 0; for (i in 0...e.dicehistory.length) { sum = sum + e.dicehistory[i].basevalue; } if (sum == e.countdown) { inflict(SHOCK|20000); sfx(~_shock~); } if(self.getvar(~furying~) < 1) { trace(~resetting!~); e.dicehistory = []; self.resetvar(myname); } self.setvar(~furying~|self.getvar(~furying~) - 1);,Electrify,COUNTDOWN,74,YELLOW,,,,_damage,0,NO,NO,cannotreuse,,,var myfixedeqlist = self.getvar(~fixedeqlist~); if(myfixedeqlist.length > 0) { var myname = ~dicehistorytemp~ + myfixedeqlist.indexOf(e); self.resetvar(myname); } self.resetvar(~fixedeqlist~); self.setvar(~fixedeqlist~|self.equipment.copy());,var myfixedeqlist = self.getvar(~fixedeqlist~); if(myfixedeqlist.length > 0) { var myname = ~dicehistorytemp~ + myfixedeqlist.indexOf(e); self.resetvar(myname); } self.resetvar(~fixedeqlist~); ,if(e.timesused > 0) { var myname = ~dicehistorytemp~ + self.getvar(~fixedeqlist~).indexOf(e); e.dicehistory = []; self.resetvar(myname); } e.timesused = 0;,,,,,,self.setvar(~furying~|getstatusself(FURY)); trace(~fury!: ~ + self.getvar(~furying~));,var myname = ~dicehistorytemp~ + self.getvar(~fixedeqlist~).indexOf(e); trace(e.dicehistory.length); trace(e.dicehistory); trace(self.getvar(myname)); trace(self.getvar(myname).length); if((e.dicehistory.length == 1) && self.getvar(myname).length >= e.dicehistory.length && self.getvar(myname).length != null) { trace(~thingdoing!~); e.dicehistory = self.getvar(myname).concat(e.dicehistory); } self.setvar(myname|e.dicehistory.copy());
Warhammer 40K_downgraded,Do [shock]40000 dmg[;] if filled|perfectly[;] inflict [shock]2000[],2,attack(40000|SHOCK); var myname = ~dicehistorytemp~ + self.getvar(~fixedeqlist~).indexOf(e); trace(~----~); trace(e.dicehistory.length); trace(e.dicehistory); trace(self.getvar(myname)); trace(self.getvar(myname).length); trace(~----~); if((e.dicehistory.length < 1) && self.getvar(myname).length >= e.dicehistory.length && self.getvar(myname).length != null) { trace(~thingdoing!~); e.dicehistory = self.getvar(myname).concat(e.dicehistory); } self.setvar(myname|e.dicehistory.copy()); var sum = 0; for (i in 0...e.dicehistory.length) { sum = sum + e.dicehistory[i].basevalue; } if (sum == e.countdown) { inflict(SHOCK|2000); sfx(~_shock~); } if(self.getvar(~furying~) < 1) { trace(~resetting!~); e.dicehistory = []; self.resetvar(myname); } self.setvar(~furying~|self.getvar(~furying~) - 1);,Electrify,COUNTDOWN,99,YELLOW,,,,_damage,0,NO,NO,cannotreuse,,,,var myfixedeqlist = self.getvar(~fixedeqlist~); if(myfixedeqlist.length > 0) { var myname = ~dicehistorytemp~ + myfixedeqlist.indexOf(e); self.resetvar(myname); } self.resetvar(~fixedeqlist~); ,if(e.timesused > 0) { var myname = ~dicehistorytemp~ + self.getvar(~fixedeqlist~).indexOf(e); e.dicehistory = []; self.resetvar(myname); } e.timesused = 0;,,,,,,self.setvar(~furying~|getstatusself(FURY)); trace(~fury!: ~ + self.getvar(~furying~));,var myname = ~dicehistorytemp~ + self.getvar(~fixedeqlist~).indexOf(e); trace(e.dicehistory.length); trace(e.dicehistory); trace(self.getvar(myname)); trace(self.getvar(myname).length); if((e.dicehistory.length == 1) && self.getvar(myname).length >= e.dicehistory.length && self.getvar(myname).length != null) { trace(~thingdoing!~); e.dicehistory = self.getvar(myname).concat(e.dicehistory); } self.setvar(myname|e.dicehistory.copy());
Warhammer 40K_weakened,Do [shock]40000 dmg[;] if filled|perfectly[;] inflict [shock]2000[],2,attack(40000|SHOCK); var myname = ~dicehistorytemp~ + self.getvar(~fixedeqlist~).indexOf(e); trace(~----~); trace(e.dicehistory.length); trace(e.dicehistory); trace(self.getvar(myname)); trace(self.getvar(myname).length); trace(~----~); if((e.dicehistory.length < 1) && self.getvar(myname).length >= e.dicehistory.length && self.getvar(myname).length != null) { trace(~thingdoing!~); e.dicehistory = self.getvar(myname).concat(e.dicehistory); } self.setvar(myname|e.dicehistory.copy()); var sum = 0; for (i in 0...e.dicehistory.length) { sum = sum + e.dicehistory[i].basevalue; } if (sum == e.countdown) { inflict(SHOCK|2000); sfx(~_shock~); } if(self.getvar(~furying~) < 1) { trace(~resetting!~); e.dicehistory = []; self.resetvar(myname); } self.setvar(~furying~|self.getvar(~furying~) - 1);,Electrify,COUNTDOWN,74,YELLOW,,,,_damage,0,NO,NO,cannotreuse,,,,var myfixedeqlist = self.getvar(~fixedeqlist~); if(myfixedeqlist.length > 0) { var myname = ~dicehistorytemp~ + myfixedeqlist.indexOf(e); self.resetvar(myname); } self.resetvar(~fixedeqlist~); ,if(e.timesused > 0) { var myname = ~dicehistorytemp~ + self.getvar(~fixedeqlist~).indexOf(e); e.dicehistory = []; self.resetvar(myname); } e.timesused = 0;,,,,,,self.setvar(~furying~|getstatusself(FURY)); trace(~fury!: ~ + self.getvar(~furying~));,var myname = ~dicehistorytemp~ + self.getvar(~fixedeqlist~).indexOf(e); trace(e.dicehistory.length); trace(e.dicehistory); trace(self.getvar(myname)); trace(self.getvar(myname).length); if((e.dicehistory.length == 1) && self.getvar(myname).length >= e.dicehistory.length && self.getvar(myname).length != null) { trace(~thingdoing!~); e.dicehistory = self.getvar(myname).concat(e.dicehistory); } self.setvar(myname|e.dicehistory.copy());
Baby's First Counting Book,Do [sword]5 damage[;]|on 1[;] 2[;] 3[;] 4[;] 5[;] do [sword]15,1,var myname = ~dicehistorytemp~ + self.getvar(~fixedeqlist~).indexOf(e); trace(~----~); trace(e.dicehistory.length); trace(e.dicehistory); trace(self.getvar(myname)); trace(self.getvar(myname).length); trace(~----~); if((e.dicehistory.length < 1) && self.getvar(myname).length >= e.dicehistory.length && self.getvar(myname).length != null) { trace(~thingdoing!~); e.dicehistory = self.getvar(myname).concat(e.dicehistory); } self.setvar(myname|e.dicehistory.copy()); var coolflag = true; if(e.dicehistory.length == 5) { for(i in 0...4) { if(e.dicehistory[i].basevalue != i + 1) { coolflag = false; break; } } } else { coolflag = false; } if(coolflag == true) { attack(15); } else { attack(5); } if(self.getvar(~furying~) < 1) { trace(~resetting!~); e.dicehistory = []; self.resetvar(myname); } self.setvar(~furying~|self.getvar(~furying~) - 1);,Double Whammy,COUNTDOWN,15,YELLOW,change_power,change_power,,_damage,0,NO,NO,cannotreuse,1,,var myfixedeqlist = self.getvar(~fixedeqlist~); if(myfixedeqlist.length > 0) { var myname = ~dicehistorytemp~ + myfixedeqlist.indexOf(e); self.resetvar(myname); } self.resetvar(~fixedeqlist~); self.setvar(~fixedeqlist~|self.equipment.copy());,var myfixedeqlist = self.getvar(~fixedeqlist~); if(myfixedeqlist.length > 0) { var myname = ~dicehistorytemp~ + myfixedeqlist.indexOf(e); self.resetvar(myname); } self.resetvar(~fixedeqlist~); ,if(e.timesused > 0) { var myname = ~dicehistorytemp~ + self.getvar(~fixedeqlist~).indexOf(e); e.dicehistory = []; self.resetvar(myname); } e.timesused = 0;,,,,,,self.setvar(~furying~|getstatusself(FURY)); trace(~fury!: ~ + self.getvar(~furying~));,var myname = ~dicehistorytemp~ + self.getvar(~fixedeqlist~).indexOf(e); trace(e.dicehistory.length); trace(e.dicehistory); trace(self.getvar(myname)); trace(self.getvar(myname).length); if((e.dicehistory.length == 1) && self.getvar(myname).length >= e.dicehistory.length && self.getvar(myname).length != null) { trace(~thingdoing!~); e.dicehistory = self.getvar(myname).concat(e.dicehistory); } self.setvar(myname|e.dicehistory.copy());
Baby's First Counting Book_upgraded,Do [sword]5 damage[;]|on 1[;] 2[;] 3[;] 4[;] 5[;] do [sword]20,1,var myname = ~dicehistorytemp~ + self.getvar(~fixedeqlist~).indexOf(e); trace(~----~); trace(e.dicehistory.length); trace(e.dicehistory); trace(self.getvar(myname)); trace(self.getvar(myname).length); trace(~----~); if((e.dicehistory.length < 1) && self.getvar(myname).length >= e.dicehistory.length && self.getvar(myname).length != null) { trace(~thingdoing!~); e.dicehistory = self.getvar(myname).concat(e.dicehistory); } self.setvar(myname|e.dicehistory.copy()); var coolflag = true; if(e.dicehistory.length == 5) { for(i in 0...4) { if(e.dicehistory[i].basevalue != i + 1) { coolflag = false; break; } } } else { coolflag = false; } if(coolflag == true) { attack(20); } else { attack(5); } if(self.getvar(~furying~) < 1) { trace(~resetting!~); e.dicehistory = []; self.resetvar(myname); } self.setvar(~furying~|self.getvar(~furying~) - 1);,Double Whammy,COUNTDOWN,15,YELLOW,,,,_damage,0,NO,NO,cannotreuse,,,var myfixedeqlist = self.getvar(~fixedeqlist~); if(myfixedeqlist.length > 0) { var myname = ~dicehistorytemp~ + myfixedeqlist.indexOf(e); self.resetvar(myname); } self.resetvar(~fixedeqlist~); self.setvar(~fixedeqlist~|self.equipment.copy());,var myfixedeqlist = self.getvar(~fixedeqlist~); if(myfixedeqlist.length > 0) { var myname = ~dicehistorytemp~ + myfixedeqlist.indexOf(e); self.resetvar(myname); } self.resetvar(~fixedeqlist~); ,if(e.timesused > 0) { var myname = ~dicehistorytemp~ + self.getvar(~fixedeqlist~).indexOf(e); e.dicehistory = []; self.resetvar(myname); } e.timesused = 0;,,,,,,self.setvar(~furying~|getstatusself(FURY)); trace(~fury!: ~ + self.getvar(~furying~));,var myname = ~dicehistorytemp~ + self.getvar(~fixedeqlist~).indexOf(e); trace(e.dicehistory.length); trace(e.dicehistory); trace(self.getvar(myname)); trace(self.getvar(myname).length); if((e.dicehistory.length == 1) && self.getvar(myname).length >= e.dicehistory.length && self.getvar(myname).length != null) { trace(~thingdoing!~); e.dicehistory = self.getvar(myname).concat(e.dicehistory); } self.setvar(myname|e.dicehistory.copy());
Baby's First Counting Book_downgraded,Do [sword]5 damage[;]|on 5[;] 4[;] 3[;] 2[;] 1[;] do [sword]15,1,var myname = ~dicehistorytemp~ + self.getvar(~fixedeqlist~).indexOf(e); trace(~----~); trace(e.dicehistory.length); trace(e.dicehistory); trace(self.getvar(myname)); trace(self.getvar(myname).length); trace(~----~); if((e.dicehistory.length < 1) && self.getvar(myname).length >= e.dicehistory.length && self.getvar(myname).length != null) { trace(~thingdoing!~); e.dicehistory = self.getvar(myname).concat(e.dicehistory); } self.setvar(myname|e.dicehistory.copy()); var coolflag = true; if(e.dicehistory.length == 5) { for(i in 0...4) { if(e.dicehistory[i].basevalue != 5 - i) { coolflag = false; break; } } } else { coolflag = false; } if(coolflag == true) { attack(15); } else { attack(5); } if(self.getvar(~furying~) < 1) { trace(~resetting!~); e.dicehistory = []; self.resetvar(myname); } self.setvar(~furying~|self.getvar(~furying~) - 1);,Double Whammy,COUNTDOWN,15,YELLOW,,,,_damage,0,NO,NO,cannotreuse,,,,var myfixedeqlist = self.getvar(~fixedeqlist~); if(myfixedeqlist.length > 0) { var myname = ~dicehistorytemp~ + myfixedeqlist.indexOf(e); self.resetvar(myname); } self.resetvar(~fixedeqlist~); ,if(e.timesused > 0) { var myname = ~dicehistorytemp~ + self.getvar(~fixedeqlist~).indexOf(e); e.dicehistory = []; self.resetvar(myname); } e.timesused = 0;,,,,,,self.setvar(~furying~|getstatusself(FURY)); trace(~fury!: ~ + self.getvar(~furying~));,var myname = ~dicehistorytemp~ + self.getvar(~fixedeqlist~).indexOf(e); trace(e.dicehistory.length); trace(e.dicehistory); trace(self.getvar(myname)); trace(self.getvar(myname).length); if((e.dicehistory.length == 1) && self.getvar(myname).length >= e.dicehistory.length && self.getvar(myname).length != null) { trace(~thingdoing!~); e.dicehistory = self.getvar(myname).concat(e.dicehistory); } self.setvar(myname|e.dicehistory.copy());
Gadsby Gun,Do [sword]2. If your gizmo's alias|lacks a particular common|Anglo-Saxon symbol[;] do [sword]6.,1,trace(Gadget.getcurrentgadget(self)); var g = Gadget.getcurrentgadget(self).toLowerCase().split(~e~); if(g.length == 1) { attack(6); } else { attack(2); } trace(g.length); trace(g); /*i wonder if you could mess with haxe enough to write this script without using the letter e as well*/,Plasma Gun,ODD,,YELLOW,change_power,change_power,,_damage,0,NO,NO,inventeronly|excludefromrandomlists,,,,,,,,,,,,
Gadsby Gun_upgraded,Deal [sword]3. When gadget|name features the formerly|forbidden letter[;] deal [sword]7.,1,trace(Gadget.getcurrentgadget(self)); var g = Gadget.getcurrentgadget(self).toLowerCase().split(~e~); if(g.length > 1) { attack(7); } else { attack(3); } trace(g.length); trace(g);,Vaporizer,EVEN,,YELLOW,,,,_damage,0,NO,NO,inventeronly|excludefromrandomlists,,,,,,,,,,,,
Gadsby Gun_downgraded,If your gizmo's alias lacks|a particular common Anglo-|Saxon symbol[;] do [sword]4.,1,trace(Gadget.getcurrentgadget(self)); var g = Gadget.getcurrentgadget(self).toLowerCase().split(~e~); if(g.length == 1) { attack(4); } else { self.textparticle(~No can-do!~); } trace(g.length); trace(g);,Plasma Gun,ODD,,YELLOW,,,,_damage,0,NO,NO,inventeronly|excludefromrandomlists,,,,,,,,,,,,
Dripping Yellow Madness,Do [sword]<d6> damage[;] on 6[;]|repaint an enemy card,1,attack(d); var cardlist = []; if(d == 6) { for(eq in target.equipment) { if (eq.equipmentcol != 4) { cardlist.push(eq); } } } if (cardlist.length > 0) { shuffle(cardlist); cardlist[0].changecolour(~YELLOW~); sfx(~_thinghappens~); },Zap,NORMAL,,YELLOW,change_power,change_power,,_damage,0,NO,NO,,1,,,,,,,,,,,
Dripping Yellow Madness_upgraded,Do [sword]<d6> damage[;] on even[;]|repaint an enemy card,1,attack(d); var cardlist = []; if(d % 2 == 0) { for(eq in target.equipment) { if (eq.equipmentcol != 4) { cardlist.push(eq); } } } if (cardlist.length > 0) { shuffle(cardlist); cardlist[0].changecolour(~YELLOW~); sfx(~_thinghappens~); },Zap,NORMAL,,YELLOW,,,,_damage,0,NO,NO,,,,,,,,,,,,,
Dripping Yellow Madness_downgraded,Do [sword]<d6> damage[;] on 6[;]|repaint one of your cards,1,attack(d); var cardlist = []; if(d == 6) { for(eq in self.equipment) { if (eq.equipmentcol != 4 && eq.ready) { cardlist.push(eq); } } } if(cardlist.length == 0) { for(eq in self.equipment) { if (eq.equipmentcol != 4) { cardlist.push(eq); } } } if (cardlist.length > 0) { shuffle(cardlist); if(cardlist[0].ready) { cardlist[0].animate(~flashandshake~); } cardlist[0].changecolour(~YELLOW~); sfx(~_thinghappens~); },Zap,NORMAL,,YELLOW,,,,_damage,0,NO,NO,,,,,,,,,,,,,
Going Really Fast,Take an extra turn. Resets if|you insert >1 dice this turn|[gray](once per battle),1,inflictself(EXTRATURN); self.endturnnow();,Time Stop,COUNTDOWN,18,YELLOW,change_power,change_power,,_fury,0,YES,YES,,1,,,,e.dicehistory = [];,,,,,if(e.remainingcountdown > 6) { roboterror(self| [e]); e.remainingcountdown = 18; },e.preventdefault = true; e.maintainfury = true;,if(e.dicehistory.length > 1 && e.ready) { e.destroydice(); e.animate(~flashandshake~); e.remainingcountdown = 18; e.dicehistory = []; }
Going Really Fast_upgraded,Gain an extra turn. Resets if|you insert >1 dice this turn|[gray](once per battle),1,inflictself(EXTRATURN);,Time Stop,COUNTDOWN,18,YELLOW,,,,_fury,0,YES,YES,,,,,,e.dicehistory = [];,,,,,if(e.remainingcountdown > 6) { roboterror(self| [e]); e.remainingcountdown = 18; },e.preventdefault = true; e.maintainfury = true;,if(e.dicehistory.length > 1 && e.ready) { e.destroydice(); e.animate(~flashandshake~); e.remainingcountdown = 18; e.dicehistory = []; }
Going Really Fast_downgraded,Get three new dice. Resets if|you insert >1 dice this turn|[gray](once per battle),1,givedice(rand([1|2|3|4|5|6])); givedice(rand([1|2|3|4|5|6])); givedice(rand([1|2|3|4|5|6]));,Time Stop,COUNTDOWN,18,YELLOW,,,,_fury,0,YES,YES,,,,,,e.dicehistory = [];,,,,,if(e.remainingcountdown > 6) { roboterror(self| [e]); e.remainingcountdown = 18; },e.preventdefault = true; e.maintainfury = true;,if(e.dicehistory.length > 1 && e.ready) { e.destroydice(); e.animate(~flashandshake~); e.remainingcountdown = 18; e.dicehistory = []; }
Paul of Mirrors,[]+1 dice this fight|(to Paul. Who's Paul?),1,if(self.name.toLowerCase() == ~paul~) self.extradice++; if(target.name.toLowerCase() == ~paul~) target.extradice++;,Plexiglass,REQUIRE6,,PURPLE,simplify,doublerequirements,,magic_gaindice,0,YES,NO,,1,,,,,,,,,,,
Operator,Do [sword]<d6> damage|In two turns[;] receive a <d6>,2,attack(d); jinx(~Operator~|~receive a %VAR%~|~Receive a %VAR%~|~inflict(\~stash\~+%VAR%); sfx(\~magic_gaindice\~); ~|self|self|2|d); sfx(~_thinghappens~);,Efficiency,MAX5,,PINK,simplify,complicate,,_damage,0,NO,NO,,,,,,,,,,,,,
Blind Justice,Do [sword]<d6> damage[;]|double if dice is obscured,1,if (actualdice[0].blind == true) { attack(d * 2); } else { attack(d); },Obfuscate,MAX5,,PURPLE,add1,change_power,,_damage,0,NO,NO,,,,,,,,,,,,,
Blind Justice_downgraded,Do [sword]<d6> damage|if dice is obscured,1,if (actualdice[0].blind == true) { attack(d); },Obfuscate,MAX5,,PURPLE,,,,_damage,0,NO,NO,,,,,,,,,,,,,
Mirrorang,[]+2 dice this fight[;]|+1 dice for enemy,1,if(!simulation) { self.extradice+= 2; target.extradice++; } else { bonus(1000); },Plexiglass,REQUIRE6,,PURPLE,simplify,change_power,,magic_gaindice,0,YES,NO,,,,,,,,,,,,,
Mirrorang_downgraded,[]+1 dice this fight[;]|+1 dice for enemy,1,if(!simulation) { self.extradice++; target.extradice++; } else { bonus(1000); },Plexiglass,REQUIRE6,,PURPLE,,,,magic_gaindice,0,YES,NO,,,,,,,,,,,,,
Combat,Do [sword]<d6> damage|(You take [sword]2 dmg each turn),2,attack(d);,Lucky Shot,NORMAL|FREE3,,GRAY,,,,_damage,0,NO,NO,skillcard,,,,,,attackself(2); e.animate(~flashandshake~);,,,,,,
Zombocombat,Do [sword]<d6> damage|(Get a debuff each turn),2,attack(d);,Lucky Shot,NORMAL|FREE3,,GRAY,,,,_damage,0,NO,NO,skillcard,,,,,var s = rand([0|1|2|2|2|2|3|3|3|3|4|4|4|5|5|5|6|6]); var statuspool = [CURSE|LOCK|FIRE|ICE|WEAKEN|SHOCK|POISON]; var soundpool = [~_curse~|~_lock~|~_fire~|~_ice~|~_weaken~|~_shock~|~_poison~]; inflictself(statuspool[s]); sfx(soundpool[s]);,,,,,,,
Sickle,Do [shock]<d6> damage[;]|on <d6>[;] inflict [shock]1 shock,2,attack(d|SHOCK); e.setvar(~test~|true); if(!e.getvar(~sicknum~) > 0) { e.setvar(~sicknum~|d); var j = e.fulldescription.split(~on <d6>~); e.fulldescription = j.join(~on ~ + e.getvar(~sicknum~)); for(eq in self.equipment) { if(e.getvar(~test~) == true && eq.getvar(~test~) == true && eq.ready) { if(eq.fulldescription.split(~on ~ + e.getvar(~sicknum~)).length == 1) { eq.fulldescription = j.join(~on ~ + e.getvar(~sicknum~)); eq.setvar(~sicknum~|e.getvar(~sicknum~)); eq.animate(~flash~); } eq.setvar(~test~|false); break; } } } sfxdamage(target|d); if((e.getvar(~sicknum~) != e.fulldescription.substr(28|1) - 0) && (e.fulldescription.substr(28|1) > 0)) { e.setvar(~sicknum~|e.fulldescription.substr(28|1) - 0); } trace(e.getvar(~sicknum~)); if(d == e.getvar(~sicknum~) # d == e.fulldescription.substr(28|1) - 0) { inflict(SHOCK); sfx(~_shock~|~~|0.2); } e.setvar(~test~|false);,Electrify,NORMAL,,YELLOW,reducesize,change_power,,none,0,NO,NO,,,,e.fulldescription = ~Do [shock]<d6> damage[~ + ~;]~ + ~#~.substr(0|1) + ~on <d6>[~ + ~;] inflict [shock]1 shock~; e.setvar(~sicknum~|0);,e.fulldescription = ~Do [shock]<d6> damage[~ + ~;]~ + ~#~.substr(0|1) + ~on <d6>[~ + ~;] inflict [shock]1 shock~; e.setvar(~sicknum~|0);,if(e.fulldescription.split(~on <d6>~).length > 1 && e.getvar(~sicknum~) > 0) { e.fulldescription = e.fulldescription.split(~on <d6>~).join(~on ~ + e.getvar(~sicknum~)); },e.setvar(~oldrow~|e.row); e.setvar(~oldcolumn~|e.column);,,e.setvar(~oldrow~|e.row); e.setvar(~oldcolumn~|e.column);,for(eq in self.equipment) { if(eq.name == e.name && eq.namemodifier == e.namemodifier && (eq.y + 10) >= e.y && (eq.y - 10) <= e.y && (eq.x + 10) >= e.x && (eq.x - 10) <= e.x) { eq.setvar(~test~|true); } },,,e.setvar(~oldrow~|e.row); e.setvar(~oldcolumn~|e.column);
Sickle_downgraded,Do [shock]<d6> damage,2,attack(d|SHOCK); sfxdamage(target|d);,Electrify,NORMAL,,YELLOW,,,,none,0,NO,NO,,,,,e.fulldescription = ~Do [shock]<d6> damage[~ + ~;]~ + ~#~.substr(0|1) + ~on <d6>[~ + ~;] inflict [shock]1 shock~; e.setvar(~sicknum~|0);,,,,,,,,
Sickle_weakened,Do [shock]<d6> damage,1,attack(d|SHOCK); sfxdamage(target|d);,Electrify,NORMAL,,YELLOW,,,,none,0,NO,NO,,,,,e.fulldescription = ~Do [shock]<d6> damage[~ + ~;]~ + ~#~.substr(0|1) + ~on <d6>[~ + ~;] inflict [shock]1 shock~; e.setvar(~sicknum~|0);,,,,,,,,
Sickle_deckupgrade,Do [shock]<d6> damage[;]|on <d6>[;] inflict [shock]2 shock,2,attack(d|SHOCK); e.setvar(~test~|true); if(!e.getvar(~sicknum~) > 0) { e.setvar(~sicknum~|d); var j = e.fulldescription.split(~on <d6>~); e.fulldescription = j.join(~on ~ + e.getvar(~sicknum~)); for(eq in self.equipment) { if(e.getvar(~test~) == true && eq.getvar(~test~) == true && eq.ready) { if(eq.fulldescription.split(~on ~ + e.getvar(~sicknum~)).length == 1) { eq.fulldescription = j.join(~on ~ + e.getvar(~sicknum~)); eq.setvar(~sicknum~|e.getvar(~sicknum~)); eq.animate(~flash~); } eq.setvar(~test~|false); break; } } } sfxdamage(target|d); if((e.getvar(~sicknum~) != e.fulldescription.substr(28|1) - 0) && (e.fulldescription.substr(28|1) > 0)) { e.setvar(~sicknum~|e.fulldescription.substr(28|1) - 0); } trace(e.getvar(~sicknum~)); if(d == e.getvar(~sicknum~) # d == e.fulldescription.substr(28|1) - 0) { inflict(SHOCK|2); sfx(~_shock~|~~|0.2); } e.setvar(~test~|false);,Electrify,NORMAL,,YELLOW,,,,none,0,NO,NO,,,,e.fulldescription = ~Do [shock]<d6> damage[~ + ~;]~ + ~#~.substr(0|1) + ~on <d6>[~ + ~;] inflict [shock]1 shock~; e.setvar(~sicknum~|0);,e.fulldescription = ~Do [shock]<d6> damage[~ + ~;]~ + ~#~.substr(0|1) + ~on <d6>[~ + ~;] inflict [shock]1 shock~; e.setvar(~sicknum~|0);,if(e.fulldescription.split(~on <d6>~).length > 1 && e.getvar(~sicknum~) > 0) { e.fulldescription = e.fulldescription.split(~on <d6>~).join(~on ~ + e.getvar(~sicknum~)); },e.setvar(~oldrow~|e.row); e.setvar(~oldcolumn~|e.column);,,e.setvar(~oldrow~|e.row); e.setvar(~oldcolumn~|e.column);,for(eq in self.equipment) { if(eq.name == e.name && eq.namemodifier == e.namemodifier && (eq.y + 10) >= e.y && (eq.y - 10) <= e.y && (eq.x + 10) >= e.x && (eq.x - 10) <= e.x) { eq.setvar(~test~|true); } },,,e.setvar(~oldrow~|e.row); e.setvar(~oldcolumn~|e.column);
Retroreflector,Roll one dice per|extra dice this fight,1,var dicelist = []; if(self.extradice > 0) for (i in 0...self.extradice) { dicelist.push(rand([1|2|3|4|5|6])); } if (dicelist.length == 0) { self.textparticle(~No effect!~); } else { givedice(dicelist); },Mirror Smash,COUNTDOWN,6,PURPLE,change_power,change_function,,magic_gaindice,0,YES,NO,,2,,,,,,,,,,,
Retroreflector_upgraded,Roll one dice per|extra dice this fight[;]|+1 this fight if this fails,1,var dicelist = []; if(self.extradice > 0) for (i in 0...self.extradice) { dicelist.push(rand([1|2|3|4|5|6])); } if (dicelist.length == 0) { self.extradice++; } else { givedice(dicelist); },Mirror Smash,COUNTDOWN,6,PURPLE,,,,magic_gaindice,0,YES,NO,,,,,,,,,,,,,
Retroreflector_downgraded,Roll one dice per|extra dice this fight[;]|-1 this fight if this works,1,var dicelist = []; if(self.extradice > 0) for (i in 0...self.extradice) { dicelist.push(rand([1|2|3|4|5|6])); } if (dicelist.length == 0) { self.textparticle(~No effect!~); } else { self.extradice--; givedice(dicelist); },Mirror Smash,COUNTDOWN,6,PURPLE,,,,magic_gaindice,0,YES,NO,,,,,,,,,,,,,
Golden Gun,Pay [gold]<d6>[;] do [sword]<double>|Return dice if unaffordable,2,if (self.gold >= d) { self.gold -= d; attack(d * 2); sfxdamage(target|d * 2); sfx(~pickupgold~); } else { givedice(d); },Harvest,NORMAL,,YELLOW,change_power,complicate,,none,0,NO,NO,showgold,,,,,,,,,,,,
Golden Gun_upgraded,Pay [gold]<d6>-1[;] do [sword]<double>|Return dice if unaffordable,2,if (self.gold >= d - 1) { self.gold -= (d - 1); attack(d * 2); sfxdamage(target|d * 2); sfx(~pickupgold~); } else {givedice(d); },Harvest,NORMAL,,YELLOW,,,,none,0,NO,NO,showgold,,,,,,,,,,,,
Snake Oil,Pay [gold]<d6>[;] inflict [poison]<d6>|Return dice if unaffordable,2,if (self.gold >= d) { self.gold -= d; inflict(POISON|d); sfx(~_poison~); sfx(~pickupgold~); } else { givedice(d); },Acid Arrow,MAX4,,PURPLE,increaserange,decreaserange,,none,0,NO,NO,showgold,,,,,,,,,,,,
Wall Street Shuffle,Get [gold]<d6> gold[;] tighten|slot by <d6> for this fight|(disappears at max 0),2,var maxes = [~ODD~|~REQUIRE1~|~MAX2~|~MAX3~|~MAX4~|~MAX5~|~NORMAL~]; var m = maxes.indexOf(e.getslots()[0]); trace(m); trace(d); if(m < d) { m = 0; } else { m = m - d; } trace(m); if(m == 0) { e.changeslots([]); } else { e.changeslots([maxes[m]]); } self.gold += d; if(m == 0) { self.setvar(~wallstreet~|null); } else { self.setvar(~wallstreet~|maxes[m]); },Hustle,NORMAL,,YELLOW,,,,pickupgold,0,YES,NO,showgold|excludefromrandomlists|cannotsteal|weakenavoid|curseavoid,,,,,if(e.getslots()[0] != self.getvar(~wallstreet~)) { e.changeslots([self.getvar(~wallstreet~)]); },,,,var maxes = [~ODD~|~REQUIRE1~|~MAX2~|~MAX3~|~MAX4~|~MAX5~|~NORMAL~]; var m = maxes.indexOf(e.getslots()[0]); if (d == m) { e.onceperbattle = true; },,,
Winds of Christmas,Do [sword]1 damage per [gold]1[;]|then halve your gold|[gray](once per battle),1,if(self.gold > 0) {attack(self.gold); var newgold = self.gold / 2; if(newgold % 1 != 0) newgold += 0.5; self.gold = newgold; sfx(~pickupgold~); },Harvest,EVEN,,YELLOW,simplify,complicate,,_damage,0,NO,YES,showgold,,,,,,,,,,,,
See No Evil,[Blind]Blind all your dice|on the next turn,1,jinx(~See No Evil~|~[blind]blind all your dice~|~[blind]Blind all your dice~|~inflict(BLIND|ALL); sfx(\~_blind\~);~|self|self|1|0); sfx(~_thinghappens~);,Science,NORMAL,,GRAY,,,blind,_blind,0,YES,NO,,,,,,,,,,,,,
See No Evil?,[Confuse]Confuse yourself|on the next turn,1,jinx(~See No Evil?~|~[confuse]confuse yourself~|~[confuse]Confuse yourself~|~inflict(CONFUSE); sfx(\~_confuse\~);~|self|self|1|0); sfx(~_thinghappens~);,Science,NORMAL,,GRAY,,,,_blind,0,YES,NO,alternateversion,,,,,,,,,,,,
Whipcrack,Do [fire]<d6> damage[;] on 6[;]|next use inflicts [fire]2 burn,2,sfxdamage(target|d); e.setvar(~test~|true); var readystring = ~#~.substr(0|1) + ~[red](ready)~; attack(d|FIRE); if(e.fulldescription.split(readystring).length > 1) { inflict(FIRE|2); } if(d == 6 && e.fulldescription.split(readystring).length == 1) { trace(~hi 1~); e.fulldescription = e.fulldescription + readystring; for(eq in self.equipment) { if(e.getvar(~test~) == true && eq.getvar(~test~) == true && eq.ready) { trace(~hi 2~); if(eq.fulldescription.split(readystring).length == 1) { trace(~hi 3~); eq.fulldescription = eq.fulldescription + readystring; eq.animate(~flash~); } eq.setvar(~test~|false); break; } } } if(d != 6 && e.fulldescription.split(readystring).length > 1) { e.fulldescription = e.fulldescription.split(readystring)[0]; for(eq in self.equipment) { if(e.getvar(~test~) == true && eq.getvar(~test~) == true && eq.ready) { eq.fulldescription = eq.fulldescription.split(readystring)[0]; eq.animate(~flash~); eq.setvar(~test~|false); break; } } } e.setvar(~test~|false);,Hellfire,NORMAL,,RED,reducesize,change_function,,_fire,0,NO,NO,excludefromrandomlists,,,var readystring = ~#~.substr(0|1) + ~[red](ready)~; if(e.fulldescription.split(readystring).length > 1) { e.fulldescription = e.fulldescription.split(readystring)[0]; },var readystring = ~#~.substr(0|1) + ~[red](ready)~; if(e.fulldescription.split(readystring).length > 1) { e.fulldescription = e.fulldescription.split(readystring)[0]; },,,,,for(eq in self.equipment) { if(eq.name == e.name && eq.namemodifier == e.namemodifier && (eq.y + 10) >= e.y && (eq.y - 10) <= e.y && (eq.x + 10) >= e.x && (eq.x - 10) <= e.x) { eq.setvar(~test~|true); } },,,
Whipcrack_downgraded,Do [fire]<d6> damage,2,sfxdamage(target|d); attack(d|FIRE);,Hellfire,NORMAL,,RED,,,,_fire,0,NO,NO,excludefromrandomlists,,,,,,,,,,,,
Whipcrack_weakened,Do [fire]<d6> damage,1,sfxdamage(target|d); attack(d|FIRE);,Hellfire,NORMAL,,RED,,,,_fire,0,NO,NO,excludefromrandomlists,,,,,,,,,,,,
Whipcrack_deckupgrade,Do [fire]<d6> damage[;] on 4-6[;]|next use inflicts [fire]2 burn,2,sfxdamage(target|d); e.setvar(~test~|true); var readystring = ~#~.substr(0|1) + ~[red](ready)~; attack(d|FIRE); if(e.fulldescription.split(readystring).length > 1) { inflict(FIRE|2); } if(d > 3 && e.fulldescription.split(readystring).length == 1) { trace(~hi 1~); e.fulldescription = e.fulldescription + readystring; for(eq in self.equipment) { if(e.getvar(~test~) == true && eq.getvar(~test~) == true && eq.ready) { trace(~hi 2~); if(eq.fulldescription.split(readystring).length == 1) { trace(~hi 3~); eq.fulldescription = eq.fulldescription + readystring; eq.animate(~flash~); } eq.setvar(~test~|false); break; } } } if(d < 4 && e.fulldescription.split(readystring).length > 1) { e.fulldescription = e.fulldescription.split(readystring)[0]; for(eq in self.equipment) { if(e.getvar(~test~) == true && eq.getvar(~test~) == true && eq.ready) { eq.fulldescription = eq.fulldescription.split(readystring)[0]; eq.animate(~flash~); eq.setvar(~test~|false); break; } } } e.setvar(~test~|false);,Hellfire,NORMAL,,RED,,,,_fire,0,NO,NO,excludefromrandomlists,,,var readystring = ~#~.substr(0|1) + ~[red](ready)~; if(e.fulldescription.split(readystring).length > 1) { e.fulldescription = e.fulldescription.split(readystring)[0]; },var readystring = ~#~.substr(0|1) + ~[red](ready)~; if(e.fulldescription.split(readystring).length > 1) { e.fulldescription = e.fulldescription.split(readystring)[0]; },,,,,for(eq in self.equipment) { if(eq.name == e.name && eq.namemodifier == e.namemodifier && (eq.y + 10) >= e.y && (eq.y - 10) <= e.y && (eq.x + 10) >= e.x && (eq.x - 10) <= e.x) { eq.setvar(~test~|true); } },,,
Gyrate Hook,Do [sword]<d6> damage[;] on|a random number (X)[;]|you can re-use this,2,sfxdamage(target|d); attack(d);,Efficiency,NORMAL,,YELLOW,reducesize,change_function,reequipnext,_damage,0,NO,NO,,,,,,var desc = ~~ + e.fulldescription; var replacesymbols = [~(X)~|~(1)~|~(2)~|~(3)~|~(4)~|~(5)~|~(6)~]; for(s in replacesymbols) { if(desc.split(s).length > 1) { e.fulldescription = desc.split(~~ + s).join(~(~ + rand([1|2|3|4|5|6]) + ~)~); } },,,,var desccheck = e.fulldescription.split(~<d6>~); if(desccheck[1].indexOf(~~ + d) > 0) { inflictself(REEQUIPNEXT); sfx(~_recycle~|~~|0.2); e.animate(~flash~); var desc = ~~ + e.fulldescription; var replacesymbols = [~(X)~|~(1)~|~(2)~|~(3)~|~(4)~|~(5)~|~(6)~]; for(s in replacesymbols) { if(desc.split(s).length > 1) { e.fulldescription = desc.split(~~ + s).join(~(~ + rand([1|2|3|4|5|6]) + ~)~); } } },,,
Gyrate Hook_downgraded,Do [sword]<d6> damage[;] on|a random number (5)[;]|you can re-use this,2,sfxdamage(target|d); attack(d);,Efficiency,MAX5,,YELLOW,,,,_damage,0,NO,NO,,,,,,var desc = ~~ + e.fulldescription; var replacesymbols = [~(X)~|~(1)~|~(2)~|~(3)~|~(4)~|~(5)~|~(6)~]; for(s in replacesymbols) { if(desc.split(s).length > 1) { e.fulldescription = desc.split(~~ + s).join(~(~ + rand([1|2|3|4|5|6]) + ~)~); } },,,,var desccheck = e.fulldescription.split(~<d6>~); if(desccheck[1].indexOf(~~ + d) > 0) { inflictself(REEQUIPNEXT); sfx(~_recycle~|~~|0.2); e.animate(~flash~); var desc = ~~ + e.fulldescription; var replacesymbols = [~(X)~|~(1)~|~(2)~|~(3)~|~(4)~|~(5)~|~(6)~]; for(s in replacesymbols) { if(desc.split(s).length > 1) { e.fulldescription = desc.split(~~ + s).join(~(~ + rand([1|2|3|4|5|6]) + ~)~); } } },,,
Gyrate Hook_weakened,Do [sword]<d6> damage[;] on|a random number (5)[;]|you can re-use this,1,sfxdamage(target|d); attack(d);,Efficiency,MAX5,,YELLOW,,,,_damage,0,NO,NO,,,,,,var desc = ~~ + e.fulldescription; var replacesymbols = [~(X)~|~(1)~|~(2)~|~(3)~|~(4)~|~(5)~|~(6)~]; for(s in replacesymbols) { if(desc.split(s).length > 1) { e.fulldescription = desc.split(~~ + s).join(~(~ + rand([1|2|3|4|5|6]) + ~)~); } },,,,var desccheck = e.fulldescription.split(~<d6>~); if(desccheck[1].indexOf(~~ + d) > 0) { inflictself(REEQUIPNEXT); sfx(~_recycle~|~~|0.2); e.animate(~flash~); var desc = ~~ + e.fulldescription; var replacesymbols = [~(X)~|~(1)~|~(2)~|~(3)~|~(4)~|~(5)~|~(6)~]; for(s in replacesymbols) { if(desc.split(s).length > 1) { e.fulldescription = desc.split(~~ + s).join(~(~ + rand([1|2|3|4|5|6]) + ~)~); } } },,,
Gyrate Hook_deckupgrade,Do [sword]<d6> damage[;] on|a random number (X)[;]|you can re-use this,2,sfxdamage(target|d); attack(d);,Efficiency,NORMAL|FREE1,,YELLOW,,,,_damage,0,NO,NO,,,,,,var desc = ~~ + e.fulldescription; var replacesymbols = [~(X)~|~(1)~|~(2)~|~(3)~|~(4)~|~(5)~|~(6)~]; for(s in replacesymbols) { if(desc.split(s).length > 1) { e.fulldescription = desc.split(~~ + s).join(~(~ + rand([1|2|3|4|5|6]) + ~)~); } },,,,var desccheck = e.fulldescription.split(~<d6>~); if(desccheck[1].indexOf(~~ + (d - 1)) > 0) { inflictself(REEQUIPNEXT); sfx(~_recycle~|~~|0.2); e.animate(~flash~); var desc = ~~ + e.fulldescription; var replacesymbols = [~(X)~|~(1)~|~(2)~|~(3)~|~(4)~|~(5)~|~(6)~]; for(s in replacesymbols) { if(desc.split(s).length > 1) { e.fulldescription = desc.split(~~ + s).join(~(~ + rand([1|2|3|4|5|6]) + ~)~); } } },,,
Glacial Blade,Do [ice]<d6> damage[;] on 6[;]|next use inflicts [ice]2 freeze,2,sfxdamage(target|d); e.setvar(~test~|true); var readystring = ~#~.substr(0|1) + ~[blue](ready)~; attack(d|ICE); if(e.fulldescription.split(readystring).length > 1) { inflict(ICE|2); } if(d == 6 && e.fulldescription.split(readystring).length == 1) { trace(~hi 1~); e.fulldescription = e.fulldescription + readystring; for(eq in self.equipment) { if(e.getvar(~test~) == true && eq.getvar(~test~) == true && eq.ready) { trace(~hi 2~); if(eq.fulldescription.split(readystring).length == 1) { trace(~hi 3~); eq.fulldescription = eq.fulldescription + readystring; eq.animate(~flash~); } eq.setvar(~test~|false); break; } } } if(d != 6 && e.fulldescription.split(readystring).length > 1) { e.fulldescription = e.fulldescription.split(readystring)[0]; for(eq in self.equipment) { if(e.getvar(~test~) == true && eq.getvar(~test~) == true && eq.ready) { eq.fulldescription = eq.fulldescription.split(readystring)[0]; eq.animate(~flash~); eq.setvar(~test~|false); break; } } } e.setvar(~test~|false);,Arctic Storm,NORMAL,,BRIGHTCYAN,reducesize,change_function,,_ice,0,NO,NO,excludefromrandomlists,,,var readystring = ~#~.substr(0|1) + ~[blue](ready)~; if(e.fulldescription.split(readystring).length > 1) { e.fulldescription = e.fulldescription.split(readystring)[0]; },var readystring = ~#~.substr(0|1) + ~[blue](ready)~; if(e.fulldescription.split(readystring).length > 1) { e.fulldescription = e.fulldescription.split(readystring)[0]; },,,,,for(eq in self.equipment) { if(eq.name == e.name && eq.namemodifier == e.namemodifier && (eq.y + 10) >= e.y && (eq.y - 10) <= e.y && (eq.x + 10) >= e.x && (eq.x - 10) <= e.x) { eq.setvar(~test~|true); } },,,
Glacial Blade_downgraded,Do [ice]<d6> damage,2,sfxdamage(target|d); attack(d|ICE);,Arctic Storm,NORMAL,,BRIGHTCYAN,,,,_ice,0,NO,NO,excludefromrandomlists,,,,,,,,,,,,
Glacial Blade_weakened,Do [ice]<d6> damage,1,sfxdamage(target|d); attack(d|ICE);,Arctic Storm,NORMAL,,BRIGHTCYAN,,,,_ice,0,NO,NO,excludefromrandomlists,,,,,,,,,,,,
Glacial Blade_deckupgrade,Do [ice]<d6> damage[;] on 4-6[;]|next use inflicts [ice]2 freeze,2,sfxdamage(target|d); e.setvar(~test~|true); var readystring = ~#~.substr(0|1) + ~[blue](ready)~; attack(d|ICE); if(e.fulldescription.split(readystring).length > 1) { inflict(ICE|2); } if(d > 3 && e.fulldescription.split(readystring).length == 1) { trace(~hi 1~); e.fulldescription = e.fulldescription + readystring; for(eq in self.equipment) { if(e.getvar(~test~) == true && eq.getvar(~test~) == true && eq.ready) { trace(~hi 2~); if(eq.fulldescription.split(readystring).length == 1) { trace(~hi 3~); eq.fulldescription = eq.fulldescription + readystring; eq.animate(~flash~); } eq.setvar(~test~|false); break; } } } if(d < 4 && e.fulldescription.split(readystring).length > 1) { e.fulldescription = e.fulldescription.split(readystring)[0]; for(eq in self.equipment) { if(e.getvar(~test~) == true && eq.getvar(~test~) == true && eq.ready) { eq.fulldescription = eq.fulldescription.split(readystring)[0]; eq.animate(~flash~); eq.setvar(~test~|false); break; } } } e.setvar(~test~|false);,Arctic Storm,NORMAL,,BRIGHTCYAN,,,,_ice,0,NO,NO,excludefromrandomlists,,,var readystring = ~#~.substr(0|1) + ~[blue](ready)~; if(e.fulldescription.split(readystring).length > 1) { e.fulldescription = e.fulldescription.split(readystring)[0]; },var readystring = ~#~.substr(0|1) + ~[blue](ready)~; if(e.fulldescription.split(readystring).length > 1) { e.fulldescription = e.fulldescription.split(readystring)[0]; },,,,,for(eq in self.equipment) { if(eq.name == e.name && eq.namemodifier == e.namemodifier && (eq.y + 10) >= e.y && (eq.y - 10) <= e.y && (eq.x + 10) >= e.x && (eq.x - 10) <= e.x) { eq.setvar(~test~|true); } },,,
Ashley Bat,Gain [fury]Fury (just 1) on 5[;]|then do [sword]<d6> damage,2,attack(d); e.setvar(~ashleyuses~|e.getvar(~ashleyuses~) + 1); if ( e.getvar(~ashleycheck~) == true ) { e.setvar(~ashleyuses~|0); e.setvar(~ashleycheck~|false); } if(getstatusself(FURY) == 0) { e.setvar(~ashleycheck~|true); }  /*i don't feel comfortable fucking around with e.timesused for this*/,Fury,MAX5,,RED,change_power,change_function,,_damage,0,NO,NO,,,,,,e.setvar(~ashleyuses~|0);,,,,if(d == 5 && e.getvar(~ashleyuses~) == 0) { inflictself(FURY); sfx(~_fury~|~~|0.2); },,donothing(); /*what happens if you use ashley while you have fury is handled in ashley's script*/,
Ashley Bat_upgraded,Do [sword]<d6> damage[;] then|gain [fury]Fury (just 1) on 5,2,attack(d); if(d == 5 && e.getvar(~ashleyuses~) == 0) { inflictself(FURY); sfx(~_fury~|~~|0.2); } e.setvar(~ashleyuses~|e.getvar(~ashleyuses~) + 1); if(e.preventdefault == true) { e.maintainfury = false; e.preventdefault = false; e.setvar(~ashleyuses~|0); } if(getstatusself(FURY) == 1) { e.maintainfury = true; e.preventdefault = true; },Fury,MAX5,,RED,,,,_damage,0,NO,NO,,,,,,e.setvar(~ashleyuses~|0);,,,,,,donothing();,
Ashley Bat_downgraded,Gain [fury]Fury (just 1) on 3[;]|then do [sword]<d6> damage,2,attack(d); e.setvar(~ashleyuses~|e.getvar(~ashleyuses~) + 1); if ( e.getvar(~ashleycheck~) == true ) { e.setvar(~ashleyuses~|0); e.setvar(~ashleycheck~|false); } if(getstatusself(FURY) == 0) { e.setvar(~ashleycheck~|true); },Fury,MAX3,,RED,,,,_damage,0,NO,NO,,,,,,e.setvar(~ashleyuses~|0);,,,,if(d == 3 && e.getvar(~ashleyuses~) == 0) { inflictself(FURY); sfx(~_fury~|~~|0.2); },,donothing();,
Heat Pump,Remove up to [fire]1 from you|Inflict [fire] equal to excess,1,,Reset Button,,,RED,change_power,noeffect,,none,0,NO,NO,,,,,,e.setvar(~pumpactions~|1 - getstatusself(FIRE)); removestatusself(FIRE|1);,e.animate(~flashandshake~); if(e.getvar(~pumpactions~) > 0) { inflict(FIRE|e.getvar(~pumpactions~)); sfx(~_fire~); } /*e.animate(~flashandshake~); var burnt = []; for (mydice in self.dicepool){ if (mydice.available() && mydice.burn == true){ burnt.push(mydice); } } while(burnt.length > 2) { burnt.shift(); } if(burnt.length = 2) { for (mydice in burnt) { var val = mydice.basevalue; mydice.removedice(self.screenposition()); givedice(val); } } else { inflict(FIRE|2); sfx(~_fire~); }*/,,,,,,
Heat Pump_upgraded,Remove up to [fire]2 from you|Inflict [fire] equal to excess,1,,Reset Button,,,RED,,,,none,0,NO,NO,,,,,,e.setvar(~pumpactions~|2 - getstatusself(FIRE)); removestatusself(FIRE|2);,e.animate(~flashandshake~); if(e.getvar(~pumpactions~) > 0) { inflict(FIRE|e.getvar(~pumpactions~)); sfx(~_fire~); },,,,,,
Berliner,Set a random dice to the|last dice you put in[;] and|recover [heart]4 health,1,var myname = ~dicehistorytemp~ + self.getvar(~fixedeqlist~).indexOf(e); trace(~----~); trace(e.dicehistory.length); trace(e.dicehistory); trace(self.getvar(myname)); trace(self.getvar(myname).length); trace(~----~); if((e.dicehistory.length < 1) && self.getvar(myname).length >= e.dicehistory.length && self.getvar(myname).length != null) { trace(~thingdoing!~); e.dicehistory = self.getvar(myname).concat(e.dicehistory); } self.setvar(myname|e.dicehistory.copy()); var berlin = e.dicehistory[e.dicehistory.length - 1].basevalue; attackself(-4); var dicelist = []; for (mydice in self.dicepool){ if (mydice.available() && mydice.basevalue != berlin){ dicelist.push(mydice); } } if(dicelist.length > 0) { shuffle(dicelist); dicelist[0].animatereroll(berlin| self.screenposition()); } if(self.getvar(~furying~) < 1) { trace(~resetting!~); e.dicehistory = []; self.resetvar(myname); } self.setvar(~furying~|self.getvar(~furying~) - 1);,Regenerate,COUNTDOWN,7,PINK,change_power,change_function,,_heal,0,YES,NO,cannotreuse,1,,var myfixedeqlist = self.getvar(~fixedeqlist~); if(myfixedeqlist.length > 0) { var myname = ~dicehistorytemp~ + myfixedeqlist.indexOf(e); self.resetvar(myname); } self.resetvar(~fixedeqlist~); self.setvar(~fixedeqlist~|self.equipment.copy());,var myfixedeqlist = self.getvar(~fixedeqlist~); if(myfixedeqlist.length > 0) { var myname = ~dicehistorytemp~ + myfixedeqlist.indexOf(e); self.resetvar(myname); } self.resetvar(~fixedeqlist~); ,if(e.timesused > 0) { var myname = ~dicehistorytemp~ + self.getvar(~fixedeqlist~).indexOf(e); e.dicehistory = []; self.resetvar(myname); } e.timesused = 0;,,,,,,self.setvar(~furying~|getstatusself(FURY)); trace(~fury!: ~ + self.getvar(~furying~));,var myname = ~dicehistorytemp~ + self.getvar(~fixedeqlist~).indexOf(e); trace(e.dicehistory.length); trace(e.dicehistory); trace(self.getvar(myname)); trace(self.getvar(myname).length); if((e.dicehistory.length == 1) && self.getvar(myname).length >= e.dicehistory.length && self.getvar(myname).length != null) { trace(~thingdoing!~); e.dicehistory = self.getvar(myname).concat(e.dicehistory); } self.setvar(myname|e.dicehistory.copy());
Berliner_upgraded,Set two random dice to the|last dice you put in[;] and|recover [heart]4 health,1,var myname = ~dicehistorytemp~ + self.getvar(~fixedeqlist~).indexOf(e); trace(~----~); trace(e.dicehistory.length); trace(e.dicehistory); trace(self.getvar(myname)); trace(self.getvar(myname).length); trace(~----~); if((e.dicehistory.length < 1) && self.getvar(myname).length >= e.dicehistory.length && self.getvar(myname).length != null) { trace(~thingdoing!~); e.dicehistory = self.getvar(myname).concat(e.dicehistory); } self.setvar(myname|e.dicehistory.copy()); var berlin = e.dicehistory[e.dicehistory.length - 1].basevalue; attackself(-4); var dicelist = []; for (mydice in self.dicepool){ if (mydice.available() && mydice.basevalue != berlin){ dicelist.push(mydice); } } if(dicelist.length > 0) { shuffle(dicelist); dicelist[0].animatereroll(berlin| self.screenposition()); } if(dicelist.length > 1) { dicelist[1].animatereroll(berlin| self.screenposition()); } if(self.getvar(~furying~) < 1) { trace(~resetting!~); e.dicehistory = []; self.resetvar(myname); } self.setvar(~furying~|self.getvar(~furying~) - 1);,Regenerate,COUNTDOWN,7,PINK,,,,_heal,0,YES,NO,cannotreuse,,,var myfixedeqlist = self.getvar(~fixedeqlist~); if(myfixedeqlist.length > 0) { var myname = ~dicehistorytemp~ + myfixedeqlist.indexOf(e); self.resetvar(myname); } self.resetvar(~fixedeqlist~); self.setvar(~fixedeqlist~|self.equipment.copy());,var myfixedeqlist = self.getvar(~fixedeqlist~); if(myfixedeqlist.length > 0) { var myname = ~dicehistorytemp~ + myfixedeqlist.indexOf(e); self.resetvar(myname); } self.resetvar(~fixedeqlist~); ,if(e.timesused > 0) { var myname = ~dicehistorytemp~ + self.getvar(~fixedeqlist~).indexOf(e); e.dicehistory = []; self.resetvar(myname); } e.timesused = 0;,,,,,,self.setvar(~furying~|getstatusself(FURY)); trace(~fury!: ~ + self.getvar(~furying~));,var myname = ~dicehistorytemp~ + self.getvar(~fixedeqlist~).indexOf(e); trace(e.dicehistory.length); trace(e.dicehistory); trace(self.getvar(myname)); trace(self.getvar(myname).length); if((e.dicehistory.length == 1) && self.getvar(myname).length >= e.dicehistory.length && self.getvar(myname).length != null) { trace(~thingdoing!~); e.dicehistory = self.getvar(myname).concat(e.dicehistory); } self.setvar(myname|e.dicehistory.copy());
Berliner_downgraded,Recover [heart]4 health,1,var myname = ~dicehistorytemp~ + self.getvar(~fixedeqlist~).indexOf(e); attackself(-4); var dicelist = []; self.resetvar(myname);,Regenerate,COUNTDOWN,7,PINK,,,,none,0,YES,NO,cannotreuse,,,var myfixedeqlist = self.getvar(~fixedeqlist~); if(myfixedeqlist.length > 0) { var myname = ~dicehistorytemp~ + myfixedeqlist.indexOf(e); self.resetvar(myname); } self.resetvar(~fixedeqlist~); self.setvar(~fixedeqlist~|self.equipment.copy());,var myfixedeqlist = self.getvar(~fixedeqlist~); if(myfixedeqlist.length > 0) { var myname = ~dicehistorytemp~ + myfixedeqlist.indexOf(e); self.resetvar(myname); } self.resetvar(~fixedeqlist~); ,if(e.timesused > 0) { var myname = ~dicehistorytemp~ + self.getvar(~fixedeqlist~).indexOf(e); e.dicehistory = []; self.resetvar(myname); } e.timesused = 0;,,,,,,,var myname = ~dicehistorytemp~ + self.getvar(~fixedeqlist~).indexOf(e); trace(e.dicehistory.length); trace(e.dicehistory); trace(self.getvar(myname)); trace(self.getvar(myname).length); if((e.dicehistory.length == 1) && self.getvar(myname).length >= e.dicehistory.length && self.getvar(myname).length != null) { trace(~thingdoing!~); e.dicehistory = self.getvar(myname).concat(e.dicehistory); } self.setvar(myname|e.dicehistory.copy());
Ping,Return last dice inserted,1,givedice(e.dicehistory[e.dicehistory.length - 1].basevalue); e.dicehistory = [];,Replicate,COUNTDOWN,8,GREEN,change_power,change_function,,none,0,YES,NO,excludefromrandomlists,,,,,,,,,,,,
Ping_upgraded,Return last dice inserted,1,givedice(e.dicehistory[e.dicehistory.length - 1].basevalue); e.dicehistory = [];,Replicate,COUNTDOWN,6,GREEN,,,,none,0,YES,NO,excludefromrandomlists,,,,,,,,,,,,
Ping_downgraded,Return excess inserted,1,var sum = 0; for (i in 0...e.dicehistory.length) { sum = sum + e.dicehistory[i].basevalue; } if (sum - e.countdown > 0) { givedice(sum - e.countdown); } else { self.textparticle(~No effect!~); } e.dicehistory = []; ,Replicate,COUNTDOWN,8,GREEN,,,,none,0,YES,NO,excludefromrandomlists,,,,,,,,,,,,
Ping_weakened,Return excess inserted,1,var sum = 0; for (i in 0...e.dicehistory.length) { sum = sum + e.dicehistory[i].basevalue; } if (sum - e.countdown > 0) { givedice(sum - e.countdown); } else { self.textparticle(~No effect!~); } e.dicehistory = []; ,Replicate,COUNTDOWN,6,GREEN,,,,none,0,YES,NO,excludefromrandomlists,,,,,,,,,,,,
Thermostat,Remove up to [ice]1 from you|Inflict [ice] equal to excess,1,,Reset Button,,,BRIGHTCYAN,change_power,noeffect,,none,0,NO,NO,,,,,,e.setvar(~thermoactions~|1 - getstatusself(ICE)); removestatusself(ICE);,e.animate(~flashandshake~); if(e.getvar(~thermoactions~) > 0) { inflict(ICE|e.getvar(~thermoactions~)); sfx(~_ice~); },,,,,,
Thermostat_upgraded,Remove up to [ice]2 from you|Inflict [ice] equal to excess,1,,Reset Button,,,BRIGHTCYAN,,,,none,0,NO,NO,,,,,,e.setvar(~thermoactions~|2 - getstatusself(ICE)); removestatusself(ICE|2);,e.animate(~flashandshake~); if(e.getvar(~thermoactions~) > 0) { inflict(ICE|e.getvar(~thermoactions~)); sfx(~_ice~); },,,,,,
Aries Card,If this is never put into|the backpack[;] this will|turn into something good,1,,Tantrum,,,RED,,,,none,0,NO,NO,excludefromrandomlists|unfinished,,,var bosses = [~Madison~|~Buster~|~Audrey~|~Aoife~|~Drake~|~Scathach~|~Beatrice~]; if(bosses[bosses.indexOf(target.name)] != null) { sfx(~music_aries_card~); },,,,,,,,,
Sacrificial Blade@3,Do [sword]<d6> damage|Can be scrapped 3 times,1,attack(d);,Scabbard (1/2),MAX3,,GRAY,change_power,change_function,,_damage,0,NO,NO,excludefromrandomlists|inventoronly,,,,,,,,,,,,
Sacrificial Blade@3_upgraded,Do [sword]<d6> damage|Can be scrapped 5 times,1,attack(d);,Scabbard+ (1/4),MAX5,,GRAY,,,,_damage,0,NO,NO,excludefromrandomlists|inventoronly,,,,,,,,,,,,
Sacrificial Blade@3_downgraded,Do [sword]<d6> damage|Can be scrapped 3 times,1,attack(d);,Scabbard (1/2),REQUIRE3,,GRAY,,,,_damage,0,NO,NO,excludefromrandomlists|inventoronly,,,,,,,,,,,,
Sacrificial Blade@3_weakened,Do [sword]<d6> damage|Can be scrapped 5 times,1,attack(d);,Scabbard+ (1/4),REQUIRE5,,GRAY,,,,_damage,0,NO,NO,excludefromrandomlists|inventoronly,,,,,,,,,,,,
Sacrificial Blade@2,Do [sword]<d6> damage|Can be scrapped twice,1,attack(d);,Scabbard (2/2),MAX2,,GRAY,change_power,change_function,,_damage,0,NO,NO,excludefromrandomlists|inventoronly,,,,,,,,,,,,
Sacrificial Blade@2_upgraded,Do [sword]<d6> damage|Can be scrapped 4 times,1,attack(d);,Scabbard+ (2/4),MAX4,,GRAY,,,,_damage,0,NO,NO,excludefromrandomlists|inventoronly,,,,,,,,,,,,
Sacrificial Blade@2_downgraded,Do [sword]<d6> damage|Can be scrapped twice,1,attack(d);,Scabbard (2/2),REQUIRE2,,GRAY,,,,_damage,0,NO,NO,excludefromrandomlists|inventoronly,,,,,,,,,,,,
Sacrificial Blade@2_weakened,Do [sword]<d6> damage|Can be scrapped 4 times,1,attack(d);,Scabbard+ (2/4),REQUIRE4,,GRAY,,,,_damage,0,NO,NO,excludefromrandomlists|inventoronly,,,,,,,,,,,,
Sacrificial Blade@1,Do [sword]<d6> damage|Scraps to Plasma Gun,1,attack(d);,Plasma Gun,REQUIRE1,,GRAY,change_power,change_function,,_damage,0,NO,NO,excludefromrandomlists|inventoronly,,,,,,,,,,,,
Sacrificial Blade@1_upgraded,Do [sword]<d6> damage|Can be scrapped 3 times,1,attack(d);,Scabbard+ (3/4),MAX3,,GRAY,,,,_damage,0,NO,NO,excludefromrandomlists|inventoronly,,,,,,,,,,,,
Sacrificial Blade@1_downgraded,No effect|Scraps to Plasma Gun,1,attack(d);,Plasma Gun,,,GRAY,,,,_damage,0,NO,NO,excludefromrandomlists|inventoronly,,,,,,,,,,,,
Sacrificial Blade@1_weakened,Do [sword]<d6> damage|Can be scrapped 3 times,1,attack(d);,Scabbard+ (3/4),REQUIRE3,,GRAY,,,,_damage,0,NO,NO,excludefromrandomlists|inventoronly,,,,,,,,,,,,
Sacrificial Blade@0,You shouldn't be seeing this,1,inflictself(VANISH); sfx(~_vanish~); target.textparticle(~Go shout at ncrecc!~);,Less Fluff,,,GRAY,change_power,change_function,,_damage,0,NO,NO,inventoronly|internal|excludefromrandomlists,,,,,,,,,,,,
Sacrificial Blade@0_upgraded,Do [sword]<d6> damage|Can be scrapped twice,1,attack(d);,Scabbard+ (4/4),MAX2,,GRAY,,,,_damage,0,NO,NO,inventoronly|internal|excludefromrandomlists,,,,,,,,,,,,
Sacrificial Blade@0_downgraded,You shouldn't be seeing this|either,1,inflictself(VANISH); sfx(~_vanish~); target.textparticle(~Really[;] go shout at ncrecc!~);,Less Fluff,,,GRAY,,,,_damage,0,NO,NO,inventoronly|internal|excludefromrandomlists,,,,,,,,,,,,
Sacrificial Blade@0_weakened,Do [sword]<d6> damage|Can be scrapped twice,1,attack(d);,Scabbard+ (4/4),REQUIRE2,,GRAY,,,,_damage,0,NO,NO,inventoronly|internal|excludefromrandomlists,,,,,,,,,,,,
Sacrificial Blade@X,You definitely shouldn't be|seeing this,1,inflictself(VANISH); sfx(~_vanish~); target.textparticle(~Go shout at ncrecc!~);,Less Fluff,,,GRAY,change_power,change_function,,_damage,0,NO,NO,inventoronly|internal|excludefromrandomlists,,,,,,,,,,,,
Sacrificial Blade@X_upgraded,Do [sword]<d6> damage|Scraps to Plasma Gun,1,attack(d);,Plasma Gun,REQUIRE1,,GRAY,,,,_damage,0,NO,NO,inventoronly|internal|excludefromrandomlists,,,,,,,,,,,,
Sacrificial Blade@X_downgraded,You really[;] definitely|shouldn't be seeing this,1,inflictself(VANISH); sfx(~_vanish~); target.textparticle(~Really[;] go shout at ncrecc!~);,Less Fluff,,,GRAY,,,,_damage,0,NO,NO,inventoronly|internal|excludefromrandomlists,,,,,,,,,,,,
Sacrificial Blade@X_weakened,No effect|Scraps to Plasma Gun,1,attack(d);,Plasma Gun,,,GRAY,,,,_damage,0,NO,NO,inventoronly|internal|excludefromrandomlists,,,,,,,,,,,,
Virtue Grip,Get sum twice. Overflow|only returns excess dice,1,var s = (actualdice[0].basevalue + actualdice[1].basevalue) % 6; if(s == 0) { s = 6; } givedice([s|s]);,Battle Wrench,NORMAL|NORMAL,,GREEN,change_power,change_function,,none,0,YES,NO,,1,,,,,,,,,,,
Virtue Grip_upgraded,Get sum thrice. Overflow|only returns excess dice,1,var s = (actualdice[0].basevalue + actualdice[1].basevalue) % 6; if(s == 0) { s = 6; } givedice([s|s|s]);,Battle Wrench,NORMAL|NORMAL,,GREEN,,,,none,0,YES,NO,,,,,,,,,,,,,
Virtue Grip_downgraded,Get sum twice. Overflow|only returns excess dice,1,var s = (actualdice[0].basevalue + actualdice[1].basevalue) % 6; if(s == 0) { s = 6; } givedice([s|s]);,Battle Wrench,DOUBLES|DOUBLES,,GREEN,,,,none,0,YES,NO,,,,,,,,,,,,,
Tear Down This Wall,Do [sword]<d6> damage. On even[;]|set a random dice to <d6>,2,attack(d); if(d % 2 == 0) { var dicelist = []; for (mydice in self.dicepool){ if (mydice.available() && mydice.basevalue != d){ dicelist.push(mydice); } } if(dicelist.length > 0) { shuffle(dicelist); dicelist[0].animatereroll(d| self.screenposition()); } },Perfectionism,NORMAL,,PINK,change_power,change_function,,_damage,0,NO,NO,,,,,,,,,,,,,
Tear Down This Wall_upgraded,Do [sword]<d6> damage[;]|set a random dice to <d6>,2,attack(d); var dicelist = []; for (mydice in self.dicepool){ if (mydice.available() && mydice.basevalue != d){ dicelist.push(mydice); } } if(dicelist.length > 0) { shuffle(dicelist); dicelist[0].animatereroll(d| self.screenposition()); },Perfectionism,NORMAL,,PINK,,,,_damage,0,NO,NO,,,,,,,,,,,,,
Tear Down This Wall_downgraded,Do [sword]<d6> damage. On even[;]|set a random dice to <d6>-1,2,attack(d); if(d % 2 == 0) { var dicelist = []; for (mydice in self.dicepool){ if (mydice.available() && mydice.basevalue != d - 1){ dicelist.push(mydice); } } if(dicelist.length > 0) { shuffle(dicelist); dicelist[0].animatereroll(d - 1| self.screenposition()); } } /*i am so original it is crazy!*/,Perfectionism,NORMAL,,PINK,,,,_damage,0,NO,NO,,,,,,,,,,,,,
Two Handed Spike,Even total: Do [sword]<d6>|Odd total: Gain [shield]<d6>|[gray](once per battle),1,if(d%2 == 0){ attack(d); sfx(~_shield~); } else { inflictself(SHIELD| d); sfx(~_shield~); },Pillow Fort,NORMAL|NORMAL,,RED,change_power,complicate,,none,0,YES,YES,,,,,,,,,,if(d % 2 == 0) { e.castdirection = 1; } else { e.castdirection = -1; },,,
Two Handed Spike_upgraded,Even total: Gain [shield]<d6>|Odd total: Do [sword]<d6>|[gray](once per battle),1,if(d%2 == 1){ attack(d); sfx(~_shield~); } else { inflictself(SHIELD| d); sfx(~_shield~); },Pillow Fort,NORMAL|NORMAL,,RED,,,,none,0,YES,YES,,,,,,,,,,if(d % 2 == 1) { e.castdirection = 1; } else { e.castdirection = -1; },,,
Rifle,Do 2x last dice value as dmg|Take 2x excess value as dmg,2,attack(2 * e.dicehistory[e.dicehistory.length - 1].basevalue); var sum = 0; for (i in 0...e.dicehistory.length) { sum = sum + e.dicehistory[i].basevalue; } if (sum - e.countdown > 0) { attackself(2 * (sum - e.countdown)); } e.dicehistory = [],Dice Bash,COUNTDOWN,13,RED,change_power,change_function,,_damage,0,NO,NO,excludefromrandomlists|cannotreuse,,,,,if(e.timesused > 0) { var myname = ~dicehistorytemp~ + self.getvar(~fixedeqlist~).indexOf(e); e.dicehistory = []; self.resetvar(myname); } e.timesused = 0;,,,,,,e.preventdefault = true; e.maintainfury = true;,
Rifle_upgraded,Do 2x last dice value as dmg|Take [sword]3 damage,2,attack(2 * e.dicehistory[e.dicehistory.length - 1].basevalue); var sum = 0; for (i in 0...e.dicehistory.length) { sum = sum + e.dicehistory[i].basevalue; } if (sum - e.countdown > 0) { attackself(3); } e.dicehistory = [],Dice Bash,COUNTDOWN,13,RED,,,,_damage,0,NO,NO,excludefromrandomlists|cannotreuse,,,,,if(e.timesused > 0) { var myname = ~dicehistorytemp~ + self.getvar(~fixedeqlist~).indexOf(e); e.dicehistory = []; self.resetvar(myname); } e.timesused = 0;,,,,,,e.preventdefault = true; e.maintainfury = true;,
Rifle_downgraded,Do last dice value as dmg|Take excess value as dmg,2,attack(e.dicehistory[e.dicehistory.length - 1].basevalue); var sum = 0; for (i in 0...e.dicehistory.length) { sum = sum + e.dicehistory[i].basevalue; } if (sum - e.countdown > 0) { attackself(sum - e.countdown); } e.dicehistory = [],Dice Bash,COUNTDOWN,13,RED,,,,_damage,0,NO,NO,excludefromrandomlists|cannotreuse,,,,,if(e.timesused > 0) { var myname = ~dicehistorytemp~ + self.getvar(~fixedeqlist~).indexOf(e); e.dicehistory = []; self.resetvar(myname); } e.timesused = 0;,,,,,,e.preventdefault = true; e.maintainfury = true;,
Dice Control,Excess value put into any|countdown will be returned,1,,Turbo Boost,,,GREEN,,,,none,0,NO,NO,excludefromrandomlists,,,,,,,,if(e.shockedsetting == 0 && e.isready()) { var lasteq = self.lastequipmentused; if(lasteq != null && lasteq.dicehistory != null && lasteq.countdown > 0 && lasteq.dicehistory.length > 0) { var dh = self.lastequipmentused.dicehistory; var sum = 0; var dhc = dh.copy(); for(dice in dhc) { sum += dice.basevalue; if(sum > lasteq.countdown) break; } if(sum - lasteq.countdown > 0) { givedice(sum - lasteq.countdown); } } } /*small note: when robot uses calculate; that is counted as an equipment use but does *not* set self.lastequipmentused to itself. i don't think this will mess things up but leaving this note just in case it does and some edgy edgecase gets really out of control*/,,,,
Look and Say,Describe these numbers,1,var a1 = actualdice[0].basevalue; var a2 = actualdice[1].basevalue; var a3 = actualdice[2].basevalue; if (a1 == a2) { if (a1 == a3) { givedice([3|a3]); } else { givedice([2|a1]); givedice([1|a3]); } } else { givedice([1|a1]); if (a2 == a3) { givedice([2|a2]); } else { givedice([1|a2]); givedice([1|a3]); } } /*this item is ultra-niche and i cannot think of why anyone would want to use it. except maybe getting 3 extra pips on a countdown.*/,Magic Dice,NORMAL|NORMAL|NORMAL,,GREEN,change_power,change_function,,,0,YES,NO,,,,,,,,,,,,,
Look and Say_upgraded,Describe these numbers|,1,var a1 = actualdice[0].basevalue; var a2 = actualdice[1].basevalue; var a3 = actualdice[2].basevalue; if (a1 == a2) { if (a1 == a3) { givedice([3|a3]); } else { givedice([2|a1]); givedice([1|a3]); } } else { givedice([1|a1]); if (a2 == a3) { givedice([2|a2]); } else { givedice([1|a2]); givedice([1|a3]); } },Magic Dice,NORMAL|NORMAL|NORMAL,,GREEN,,,,,2,YES,NO,,,,,,,,,,,,,
Look and Say_downgraded,Describe these numbers,1,var a1 = actualdice[0].basevalue; var a2 = actualdice[1].basevalue; var a3 = actualdice[2].basevalue; if (a1 == a2) { if (a1 == a3) { givedice([3|a3]); } else { givedice([2|a1]); givedice([1|a3]); } } else { givedice([1|a1]); if (a2 == a3) { givedice([2|a2]); } else { givedice([1|a2]); givedice([1|a3]); } },Magic Dice,MAX4|MAX4|MAX4,,GREEN,,,,,0,YES,NO,,,,,,,,,,,,,
Bumpbomb,Do [sword]<d6> damage. On 6[;]|bump all dice below 6,2,attack(d); if(d == 6) { var c = 0; for(mydice in self.dicepool){ if(mydice.available() && !mydice.intween() && mydice.basevalue != 6) { mydice.animatereroll(mydice.basevalue + 1|self.screenposition()|c * 0.05); } } } /*if(d == 6) { var c = 0; var extradice = []; for (mydice in self.dicepool){ if (mydice.available()){ if (mydice.basevalue >= 6){ extradice.push(1); mydice.animatereroll(6| self.screenposition()| c * 0.05); } else { mydice.animatereroll((mydice.basevalue + 1)| self.screenposition()| c * 0.05); } c++; } } givedice(extradice); } yeah i literally just copypasted megabump into here. NO fear; baby! */,Megabump,NORMAL,,GREEN,change_power,change_function,,_damage,0,NO,NO,,,,,,,,,,,,,
Bumpbomb_upgraded,Do [sword]<d6> damage. On 5 or 6[;]|bump all dice below 6,2,attack(d); if(d == 6 # d == 5) { var c = 0; for(mydice in self.dicepool){ if(mydice.available() && !mydice.intween() && mydice.basevalue != 6) { mydice.animatereroll(mydice.basevalue + 1|self.screenposition()|c * 0.05); } } },Megabump,NORMAL,,GREEN,,,,_damage,0,NO,NO,,,,,,,,,,,,,
Bumpbomb_downgraded,Do [sword]<d6> damage. On 6[;]|bump highest non-6 dice,2,attack(d); if(d == 6 && self.dicepool.length > 0) { var max = 0; for (mydice in self.dicepool){ if (mydice.available() && !mydice.intween() && mydice.basevalue > max && mydice.basevalue != 6) { max = mydice.basevalue; } } for (mydice in self.dicepool){ if(mydice.available() && mydice.basevalue == max) { mydice.animatereroll(mydice.basevalue + 1); break; } } } /*if(d == 6 && self.dicepool.length > 0) { var max = 0; for (mydice in self.dicepool){ if (mydice.available() && mydice.basevalue > max) { max = mydice.basevalue; } } for (mydice in self.dicepool){ if(mydice.available() && mydice.basevalue == max) { if(mydice.basevalue != 6) { mydice.animatereroll(mydice.basevalue + 1); break; } else { mydice.animatereroll(6); givedice(1); break; } } } }*/,Megabump,NORMAL,,GREEN,,,,_damage,0,NO,NO,,,,,,,,,,,,,
Scrap Crystal,Recover [heal]3 health|(Always offered as scrap),1,attackself(-3);,Rejuvenate,MIN4,,GRAY,change_power,complicate,,_heal,0,YES,NO,appearsforparts,,,,,,,,,,,,
Scrap Crystal_upgraded,Recover [heal]3 health|(Always offered as scrap)|,1,attackself(-3);,Rejuvenate,MIN4,,GRAY,,,,_heal,2,YES,NO,appearsforparts,,,,,,,,,,,,
Scrap Crystal_downgraded,Recover [heal]3 health|(Always offered as scrap),1,attackself(-3);,Rejuvenate,REQUIRE5,,GRAY,,,,_heal,0,YES,NO,appearsforparts,,,,,,,,,,,,
Gyrate Hook?,Do [sword]<d6> damage[;] on|a random number (X)[;]|keep the dice,2,attack(d);,Efficiency,NORMAL,,YELLOW,reducesize,change_function,,_damage,0,NO,NO,alternateversion,,,,,var desc = ~~ + e.fulldescription; var replacesymbols = [~(X)~|~(1)~|~(2)~|~(3)~|~(4)~|~(5)~|~(6)~]; for(s in replacesymbols) { if(desc.split(s).length > 1) { e.fulldescription = desc.split(~~ + s).join(~(~ + rand([1|2|3|4|5|6]) + ~)~); } },,,,var desccheck = e.fulldescription.split(~<d6>~); if(desccheck[1].indexOf(~~ + d) > 0) { inflictself(REEQUIPNEXT); sfx(~_recycle~|~~|0.2); e.animate(~flash~); var desc = ~~ + e.fulldescription; var replacesymbols = [~(X)~|~(1)~|~(2)~|~(3)~|~(4)~|~(5)~|~(6)~]; for(s in replacesymbols) { if(desc.split(s).length > 1) { e.fulldescription = desc.split(~~ + s).join(~(~ + rand([1|2|3|4|5|6]) + ~)~); } } },,,
Gyrate Hook?_downgraded,Do [sword]<d6> damage[;] on|a random number (5)[;]|keep the dice,2,attack(d);,Efficiency,MAX5,,YELLOW,,,,_damage,0,NO,NO,alternateversion,,,,,var desc = ~~ + e.fulldescription; var replacesymbols = [~(X)~|~(1)~|~(2)~|~(3)~|~(4)~|~(5)~|~(6)~]; for(s in replacesymbols) { if(desc.split(s).length > 1) { e.fulldescription = desc.split(~~ + s).join(~(~ + rand([1|2|3|4|5|6]) + ~)~); } },,,,var desccheck = e.fulldescription.split(~<d6>~); if(desccheck[1].indexOf(~~ + d) > 0) { inflictself(REEQUIPNEXT); sfx(~_recycle~|~~|0.2); e.animate(~flash~); var desc = ~~ + e.fulldescription; var replacesymbols = [~(X)~|~(1)~|~(2)~|~(3)~|~(4)~|~(5)~|~(6)~]; for(s in replacesymbols) { if(desc.split(s).length > 1) { e.fulldescription = desc.split(~~ + s).join(~(~ + rand([1|2|3|4|5|6]) + ~)~); } } },,,
Gyrate Hook?_weakened,Do [sword]<d6> damage[;] on|a random number (5)[;]|keep the dice,1,attack(d);,Efficiency,MAX5,,YELLOW,,,,_damage,0,NO,NO,alternateversion,,,,,var desc = ~~ + e.fulldescription; var replacesymbols = [~(X)~|~(1)~|~(2)~|~(3)~|~(4)~|~(5)~|~(6)~]; for(s in replacesymbols) { if(desc.split(s).length > 1) { e.fulldescription = desc.split(~~ + s).join(~(~ + rand([1|2|3|4|5|6]) + ~)~); } },,,,var desccheck = e.fulldescription.split(~<d6>~); if(desccheck[1].indexOf(~~ + d) > 0) { inflictself(REEQUIPNEXT); sfx(~_recycle~|~~|0.2); e.animate(~flash~); var desc = ~~ + e.fulldescription; var replacesymbols = [~(X)~|~(1)~|~(2)~|~(3)~|~(4)~|~(5)~|~(6)~]; for(s in replacesymbols) { if(desc.split(s).length > 1) { e.fulldescription = desc.split(~~ + s).join(~(~ + rand([1|2|3|4|5|6]) + ~)~); } } },,,
Gyrate Hook?_deckupgrade,Do [sword]<d6> damage[;] on|a random number (X)[;]|keep the dice,2,attack(d);,Efficiency,NORMAL|FREE1,,YELLOW,,,,_damage,0,NO,NO,alternateversion,,,,,var desc = ~~ + e.fulldescription; var replacesymbols = [~(X)~|~(1)~|~(2)~|~(3)~|~(4)~|~(5)~|~(6)~]; for(s in replacesymbols) { if(desc.split(s).length > 1) { e.fulldescription = desc.split(~~ + s).join(~(~ + rand([1|2|3|4|5|6]) + ~)~); } },,,,var desccheck = e.fulldescription.split(~<d6>~); if(desccheck[1].indexOf(~~ + (d - 1)) > 0) { inflictself(REEQUIPNEXT); sfx(~_recycle~|~~|0.2); e.animate(~flash~); var desc = ~~ + e.fulldescription; var replacesymbols = [~(X)~|~(1)~|~(2)~|~(3)~|~(4)~|~(5)~|~(6)~]; for(s in replacesymbols) { if(desc.split(s).length > 1) { e.fulldescription = desc.split(~~ + s).join(~(~ + rand([1|2|3|4|5|6]) + ~)~); } } },,,
Cactus[],Needle|Gain [thorns]1 thorns,2,inflictself(THORNS|1);,Needle,,,GREEN,,change_function,,_thorns,0,YES,NO,powercard,,,,,,,,,,,,
Cactus[]_downgraded,Poke|Do [sword]2 damage,2,attack(2); sfxdamage(target|2); sfx(~_thorns~|~~|0.2);,Needle,,,GREEN,,,,,,,,powercard,,,,,,,,,,,,
Debate Ender,Convert Ultima to Buster|On jackpot[;] vice versa,1,,Lucky Shot,,,GRAY,,change_function,,none,0,NO,NO,,,,,,/*for(eq in self.equipment) { if((eq.name == ~Ultima Weapon~ # eq.name == ~Buster Sword~) && eq.namemodifier == ~+~) { eq.setvar(~yeppiamupgraded~|true); } }*/,for(eq in self.equipment) { if(eq.name == ~Ultima Weapon~ && (eq.namemodifier == ~+~ # eq.originallyupgraded == true)) { var wknme = false; if(eq.namemodifier == ~-~) { wknme = true; } var oldx = eq.x; var oldy = eq.y; eq.create(~Buster Sword~|true); eq.x = oldx; eq.y = oldy; if(wknme == true) { eq.downgrade(); } eq.animate(~flashandshake~); e.setvar(~flashflag~|true); } else if(eq.name == ~Ultima Weapon~) { var wknme = false; if(eq.namemodifier == ~-~) { wknme = true; } var oldx = eq.x; var oldy = eq.y; eq.create(~Buster Sword~|false); eq.x = oldx; eq.y = oldy; if(wknme == true) { eq.downgrade(); } eq.animate(~flashandshake~); e.setvar(~flashflag~|true); } } if(e.getvar(~flashflag~) == true) { e.animate(~flashandshake~); sfx(~openchest~); if(e.col != 0) { e.changecolour(~GRAY~); } e.setvar(~flashflag~|false); },/*if(e.col != 0) { e.changecolour(~GRAY~); }*/,if(self.roll_jackpot > 0) { for(eq in self.equipment) { if(eq.name == ~Buster Sword~ && (eq.namemodifier == ~+~ # eq.originallyupgraded == true)) { var wknme = false; if(eq.namemodifier == ~-~) { wknme = true; } var oldx = eq.x; var oldy = eq.y; eq.create(~Ultima Weapon+~|true); eq.x = oldx; eq.y = oldy; if(wknme == true) { eq.downgrade(); } eq.animate(~flashandshake~); e.setvar(~flashflag~|true); } else if(eq.name == ~Buster Sword~) { var wknme = false; if(eq.namemodifier == ~-~) { wknme = true; } var oldx = eq.x; var oldy = eq.y; eq.create(~Ultima Weapon~|false); eq.x = oldx; eq.y = oldy; if(wknme == true) { eq.downgrade(); } eq.animate(~flashandshake~); e.setvar(~flashflag~|true); } } if(e.getvar(~flashflag~) == true) { e.animate(~flashandshake~); if(e.col != 4) { e.changecolour(~YELLOW~); } sfx(~openchest~); e.setvar(~flashflag~|false); } },,,,
Debate Ender_downgraded,Convert Ultima to Buster|[80%][gray]''Ultima's only useful in ER where[]|[80%][gray]you have to kill enemies faster''[],1,/*this is a compelling argument i sometimes hear on the dicecord from people who swear by buster: ultima is normally a shiny newbie trap intentionally designed as such; but it's surprisingly good in ER. that's because the enemies in ER do more damage to you; which means when you get hit by them you have to do more damage to them faster to kill them before they kill you. we all know that robot's limit break never charges outside of ER for some reason; and also cheat code isn't real and has no significant increase on jackpot probability.*/,Lucky Shot,,,GRAY,,,,none,0,NO,NO,,,,,,/*for(eq in self.equipment) { if((eq.name == ~Ultima Weapon~ # eq.name == ~Buster Sword~) && eq.namemodifier == ~+~) { eq.setvar(~yeppiamupgraded~|true); } }*/,for(eq in self.equipment) { if(eq.name == ~Ultima Weapon~ && (eq.namemodifier == ~+~ # eq.originallyupgraded == true)) { var wknme = false; if(eq.namemodifier == ~-~) { wknme = true; } var oldx = eq.x; var oldy = eq.y; eq.create(~Buster Sword~|true); eq.x = oldx; eq.y = oldy; if(wknme == true) { eq.animate(~weaken~); } else { eq.animate(~flashandshake~); } e.setvar(~flashflag~|true); } else if(eq.name == ~Ultima Weapon~) { var wknme = false; if(eq.namemodifier == ~-~) { wknme = true; } var oldx = eq.x; var oldy = eq.y; eq.create(~Buster Sword~|false); eq.x = oldx; eq.y = oldy; if(wknme == true) { eq.animate(~weaken~); } else { eq.animate(~flashandshake~); } e.setvar(~flashflag~|true); } } if(e.getvar(~flashflag~) == true) { e.animate(~flashandshake~); sfx(~openchest~); if(e.col != 0) { e.changecolour(~GRAY~); } e.setvar(~flashflag~|false); },/*if(e.col != 0) { e.changecolour(~GRAY~); }*/,,,,,
AWESOMESWORD,[300%]DO LIKE|[300%]A BUNCH|[300%]OF DAMAGE|[300%]HOLY CRAP,2,attack(2); sfxdamage(target|999);,THE [200%]GASDGFET,NORMAL,,RED,,,,_damage,0,NO,NO,,,,,,,,,,,,,
Swing Me Another 6,Do [sword]<d6> damage[;] roll a 6|[gray](once per battle),1,attack(d); givedice(6);,Magic Six,MAX5,,RED,change_power,change_function,,_damage,0,NO,YES,,1,,,,,,,,,,,
Swing Me Another 6_upgraded,Do [sword]<d6> damage[;] roll two 6s|[gray](once per battle),1,attack(d); givedice([6|6]);,Magic Six,MAX5|MAX5,,RED,,,,_damage,0,NO,YES,,,,,,,,,,,,,
Swing Me Another 6_downgraded,Do [sword]<d6>[;] set a dice to 6|[gray](once per battle),1,attack(d); var dicelist = []; for (mydice in self.dicepool){ if (mydice.available() && mydice.basevalue != 6){ dicelist.push(mydice); } } if(dicelist.length > 0) { shuffle(dicelist); dicelist[0].animatereroll(6| self.screenposition()); } givedice(6);,Magic Six,MAX5,,RED,,,,_damage,0,NO,YES,,,,,,,,,,,,,
Combat Slam,Reroll|Reroll unused dice,2,,Reroll,,,GRAY,,,,none,0,YES,NO,excludefromrandomlists|powercard,,,,,,,,,var c = 0; for (mydice in self.dicepool){ if (mydice.available()){ mydice.animatereroll(rand([1|2|3|4|5|6])| self.screenposition()| c * 0.05); c++; } },,,
Combat Key,Set a dice to <d6>[;] return dice|,2,var dicelist = []; for (mydice in self.dicepool){ if (mydice.available() && mydice.basevalue != d){ dicelist.push(mydice); } } if(dicelist.length > 0) { shuffle(dicelist); dicelist[0].animatereroll(d| self.screenposition()| 0); } givedice(d);,Conformity,NORMAL,,GRAY,,,,none,2,YES,NO,excludefromrandomlists,,,,,,,,,,,,
Combat Bump,Dice value +1|,2,if(d >= 6){ givedice([6| 1]); } else { givedice(d + 1); },Megabump,NORMAL,,GRAY,,,,none,3,YES,NO,excludefromrandomlists,,,,,,,,,,,,
Combat Tweak,First dice value +1|Second dice value -1|,2,var dicearray = []; dicearray.push(actualdice[0].basevalue + 1); if(actualdice[1].basevalue - 1 > 0) { dicearray.push(actualdice[1].basevalue - 1);} if(dicearray[0] == 7) { dicearray[0] = 6; dicearray.push(1); }givedice(dicearray);,Meganudge,NORMAL|NORMAL,,GRAY,,,,none,3,YES,NO,excludefromrandomlists,,,,,,,,,,,,
Combat Bulb,Get 2x<d6>s next turn[;]|reroll the dice,2,inflictself(~stash~+d|2); inflictself(~illuminate~); givedice();,Magic Dice,NORMAL,,GRAY,,,,_magic,0,YES,NO,excludefromrandomlists,,,,,,,,,,,,
Combat Grip,Get sum twice. Overflow|only returns excess dice|,2,var s = (actualdice[0].basevalue + actualdice[1].basevalue) % 6; if(s == 0) { s = 6; } givedice([s|s]);,Battle Wrench,NORMAL|NORMAL,,GRAY,,,,none,2,YES,NO,excludefromrandomlists,,,,,,,,,,,,
Combat Doppel,Double dice value|,2,givedice(d * 2| ~combinedice~);,Clone Device,MAX3,,GRAY,,,,none,2,YES,NO,excludefromrandomlists,,,,,,,,,,,,
Combat Mirror,Reroll dice[;] on even[;]|get +1 dice this fight,2,if(d % 2 == 0) { sfx(~magic_gaindice~); if(simulation) { bonus(1000); } else{ self.extradice++; } } givedice();,Focus,NORMAL,,GRAY,,,,none,0,YES,NO,excludefromrandomlists,,,,,,,,,,,,
Combat Dice,Here's a 6,2,,Magic Six,SPARE6,,GRAY,,,,none,0,YES,NO,excludefromrandomlists,,,,,e.fulldescription = ~Here's a 6~; if(chance(2)) e.fulldescription += ~#~.substr(0|1) + ~[80%][gray]You're welcome![]~; /*string concatenation via += is beautiful... i wish you could do the same thing for arrays*/,,,,,,,
Combat Gumball,Heal [heal]1[;] reroll dice|,2,attackself(-1); givedice();,Regenerate,MAX3,,GRAY,,,,_heal,3,YES,NO,excludefromrandomlists,,,,,,,,,,,,
Combat Gold,Roll an even dice|(3 uses),2,givedice(rand([2|4|6]));,Random Roll,NORMAL,,GRAY,,,,none,3,YES,NO,excludefromrandomlists,,,,,,,,,,,,
Combat Silver,Roll an odd dice|(3 uses),2,givedice(rand([1|3|5]));,Random Roll,NORMAL,,GRAY,,,,none,3,YES,NO,excludefromrandomlists,,,,,,,,,,,,
Combat Flip,Megaflip|Flip all dice upside down,2,,Megaflip,,,GRAY,,,,none,0,YES,NO,powercard|excludefromrandomlists,,,,,,,,,var c = 0; for (mydice in self.dicepool){ if (mydice.available()){ mydice.animatereroll((7 - mydice.basevalue)| self.screenposition()| c * 0.05); c++; } },,,
Combat Ungerade,Double dice value[;]|then subtract 1|(2 uses),2,givedice(((d * 2) - 1)| ~combinedice~);,Clone Device,MAX4,,GRAY,,,,none,2,YES,NO,excludefromrandomlists,,,,,,,,,,,,
Combat Spanner,Combine dice|(3 uses),2,for(ad in actualdice) { if(ad.basevalue == 6) bonus(-1000); } if(d >= 1) givedice(d| ~combinedice~);,Battle Wrench,NORMAL|NORMAL,,GRAY,,,,none,3,YES,NO,excludefromrandomlists,,,,,,,,,,,,
Combat Calculate,Autoroll|Roll a random amount|of dice that add up to 9,2,/*jacke suggested this card; cool guy*/,Magic Dice,,,GRAY,,,,none,0,YES,NO,powercard|excludefromrandomlists,,,,,,,,,var rolls = []; var left = 9; while(left > 0) { var r = rand([1|2|3|4|5|6]); if(r > left) { r = left; } rolls.push(r); left -= r; } givedice(rolls); sfx(~jackpot_autoroll~);,,,
Combat Keyhole,Flip & split[;] flip results,2,var s = split(7-d); givedice([7-s[0]|7-s[1]]);,Clone Device,MAX3,,GRAY,,,,splitdice,0,YES,NO,excludefromrandomlists,,,,,,,,,,,,
Combat Scroll,Bump dice under 6 when|you use any equipment|or reduce any countdowns,2,,Megabump,,,GRAY,,,,none,0,YES,NO,excludefromrandomlists,,,,,,,,if(!onlimit && e.equipalpha == 1.0 && !self.lastequipmentused.countdown > 0) { if(e.shockedsetting == 0) { var c = 0; for (mydice in self.dicepool){ if (mydice.available() && !mydice.intween()){ if (mydice.basevalue < 6){ mydice.animatereroll((mydice.basevalue + 1)| self.screenposition()| c * 0.05); } c++; } } } },,,,if(e.shockedsetting == 0) { var c = 0; for (mydice in self.dicepool){ if (mydice.available() && !mydice.intween()){ if (mydice.basevalue < 6){ mydice.animatereroll((mydice.basevalue + 1)| self.screenposition()| c * 0.05); } c++; } } }
Combat Innovate,Get a dice you don't have|(2 uses),2,var notseen = [1|2|3|4|5|6]; notseen.remove(d); for (mydice in self.dicepool){ if (mydice.available() && notseen[notseen.indexOf(mydice.basevalue)] != null) {notseen.remove(mydice.basevalue);} } if (notseen.length == 0) {givedice(d); self.textparticle(~You've got all dice!~);} else { shuffle(notseen); givedice(notseen[0]); },Conformity,NORMAL,,GRAY,,,,none,2,YES,NO,excludefromrandomlists,,,,,,,,,,,,
Vanity Mirror,Turn start: roll an extra dice|Turn end: take [sword]4 if unused,1,e.setvar(~vmirrorused~|true);,Magic Dice,ODD,,PURPLE,simplify,change_power,,_thinghappens,0,YES,NO,cannotreuse|curseavoid,1,,,,e.resetvar(~vmirrorused~);,e.animate(~flashandshake~); givedice(); ,if(target.hp > 0) { e.animate(~flashandshake~); if(e.getvar(~vmirrorused~) != true) { attackself(4); } } e.resetvar(~vmirrorused~);,,,,e.preventdefault = true; e.maintainfury = true;,
Vanity Mirror_downgraded,Turn start: roll an extra dice|Turn end: take [sword]6 if unused,1,e.setvar(~vmirrorused~|true);,Magic Dice,ODD,,PURPLE,,,,_thinghappens,0,YES,NO,cannotreuse|curseavoid,,,,,e.resetvar(~vmirrorused~);,e.animate(~flashandshake~); givedice(); ,if(target.hp > 0) { e.animate(~flashandshake~); if(e.getvar(~vmirrorused~) != true) { attackself(4); } } e.resetvar(~vmirrorused~);,,,,e.preventdefault = true; e.maintainfury = true;,
Combat Crucible,Roll four new burning dice,2,inflictself(FIRE| 4); givedice([rand([1|2|3|4|5|6])|rand([1|2|3|4|5|6])|rand([1|2|3|4|5|6])|rand([1|2|3|4|5|6])]);,Random Roll,NORMAL,,GRAY,,,,none,0,YES,NO,excludefromrandomlists,,,,,,,,,,,,
Combat Murk,Roll four new blind dice,2,var oldblind = 0; var oldaltblind = 0; if(self.status.length > 0) { for(stat in self.status) { if(stat.type == ~blind~) { oldblind = stat.value; } if(stat.type == ~alternate_blind~) { oldaltblind = stat.value; } } } inflictself(BLIND| 4); givedice([rand([1|2|3|4|5|6])|rand([1|2|3|4|5|6])|rand([1|2|3|4|5|6])|rand([1|2|3|4|5|6])]); for(stat in self.status) { if(stat.type == ~alternate_blind~ && stat.value > oldaltblind) { for(i in 1...(getstatusself(~alternate_blind~) - oldblind) + 1) { if(self.dicepool.length - i < 0) break; else self.dicepool[self.dicepool.length - i].blind = true; } } removestatusself(BLIND|getstatusself(~alternate_blind~) - oldblind); },Obfuscate,NORMAL,,GRAY,,,,none,0,YES,NO,excludefromrandomlists,,,,,,,,,,,,
Steel Sword,Do [sword]<d6> damage[;] on 6[;]|this can kill vampires,2,if(d == 6 && target.hp <= 6 && getstatus(VAMPIRE) > 0) { removestatus(VAMPIRE| ALL); } attack(d);,Heat Ray,NORMAL,,GRAY,change_power,change_power,vampire,_damage,0,NO,NO,,,,if(target.innate.indexOf(~vampire~) != -1 && !Rules.hasalternate(~vampire~)) { for(i in 0...target.innate.length) { if(target.innate[i] == ~vampire~) { target.innate[i] = ~can only be killed with a ~ + e.displayname.toLowerCase(); } } } inflict(VAMPIRE);,,,,,,,,,
Steel Sword_downgraded,Do [sword]<d6> damage[;] on 6[;]|this can kill vampires,2,if(d == 6 && target.hp <= 6 && getstatus(VAMPIRE) > 0) { removestatus(VAMPIRE| ALL); } attack(d);,Heat Ray,MIN4,,GRAY,,,,_damage,0,NO,NO,,,,if(target.innate.indexOf(~vampire~) != -1 && !Rules.hasalternate(~vampire~)) { for(i in 0...target.innate.length) { if(target.innate[i] == ~vampire~) { target.innate[i] = ~can only be killed with a ~ + e.displayname.toLowerCase(); } } } inflict(VAMPIRE);,,,,,,,,,
Steel Sword_upgraded,Do [sword]<d6> damage[;] on 6[;]|this can kill vampires,2,if(d == 8 && target.hp <= 8 && getstatus(VAMPIRE) > 0) { removestatus(VAMPIRE| ALL); } attack(d);,Heat Ray,NORMAL|FREE2,,GRAY,,,,_damage,0,NO,NO,,,,if(target.innate.indexOf(~vampire~) != -1 && !Rules.hasalternate(~vampire~)) { for(i in 0...target.innate.length) { if(target.innate[i] == ~vampire~) { target.innate[i] = ~can only be killed with a ~ + e.displayname.toLowerCase(); } } } inflict(VAMPIRE);,,,,,,,,,
Steel Sword?,Do [sword]<d6> damage,2,attack(d);,Heat Ray,NORMAL|FREE6,,GRAY,change_power,change_power,,_damage,0,NO,NO,alternateversion,,,,,,,,,,,,
Steel Sword?_downgraded,Do [sword]<d6> damage,2,attack(d);,Heat Ray,NORMAL|FREE3,,GRAY,,,,_damage,0,NO,NO,alternateversion,,,,,,,,,,,,
Steel Sword?_upgraded,Do [sword]<d6> damage,2,attack(d);,Heat Ray,NORMAL|FREE3|FREE3|FREE3,,GRAY,,,,_damage,0,NO,NO,alternateversion,,,,,,,,,,,,
Rusty Key,Do [sword]<d6> damage[;]|split your highest dice,2,attack(d); sfxdamage(target|d); var dicelist = []; var max = 0; if(self.dicepool.length > 0) { for (mydice in self.dicepool){ if (mydice.available()){ dicelist.push(mydice);  if (mydice.basevalue > max) { max = mydice.basevalue; } } } if(dicelist.length > 0 && max > 0) { var backupdicelist = dicelist.copy(); for(mydice in backupdicelist) { if(mydice.basevalue == max) { dicelist.remove(mydice); } } if(dicelist.length > 0) { shuffle(dicelist); dicelist[0].removedice(self.screenposition()); givedice(split(dicelist[0].basevalue)|~splitdice~); } else { shuffle(backupdicelist); backupdicelist[0].removedice(self.screenposition()); givedice(split(backupdicelist[0].basevalue)|~splitdice~); } } },Magic Lockpick,NORMAL,,ORANGE,change_power,change_function,,none,0,NO,NO,,,var dicelist = []; var max = 0; if(self.dicepool.length > 0) { for (mydice in self.dicepool){ if (mydice.available()){ dicelist.push(mydice);  if (mydice.basevalue > max) { max = mydice.basevalue; } } } if(dicelist.length > 0 && max > 0) { var backupdicelist = dicelist.copy(); for(mydice in backupdicelist) { if(mydice.basevalue == max) { dicelist.remove(mydice); } } if(dicelist.length > 0) { shuffle(dicelist); dicelist[0].removedice(self.screenposition()); givedice(split(dicelist[0].basevalue)|~splitdice~); } else { shuffle(backupdicelist); backupdicelist[0].removedice(self.screenposition()); givedice(split(backupdicelist[0].basevalue)|~splitdice~); } } },,,,,,,,,,
Rusty Key_upgraded,Do [sword]<d6> damage[;]|split your highest dice|On 6[;] split in 3 instead,2,attack(d); sfxdamage(target|d); var dicelist = []; var max = 0; if(self.dicepool.length > 0) { for (mydice in self.dicepool){ if (mydice.available()){ dicelist.push(mydice);  if (mydice.basevalue > max) { max = mydice.basevalue; } } } if(dicelist.length > 0 && max > 0) { var backupdicelist = dicelist.copy(); for(mydice in backupdicelist) { if(mydice.basevalue == max) { dicelist.remove(mydice); } } if(dicelist.length > 0) { shuffle(dicelist); dicelist[0].removedice(self.screenposition()); if(d != 6) givedice(split(dicelist[0].basevalue)|~splitdice~); else givedice(split(dicelist[0].basevalue|3)~splitdice~); } else { shuffle(backupdicelist); backupdicelist[0].removedice(self.screenposition()); if(d != 6) givedice(split(backupdicelist[0].basevalue)|~splitdice~); else givedice(split(backupdicelist[0].basevalue|3)~splitdice~); } } },Magic Lockpick,NORMAL,,ORANGE,,,,none,0,NO,NO,,,var dicelist = []; var max = 0; if(self.dicepool.length > 0) { for (mydice in self.dicepool){ if (mydice.available()){ dicelist.push(mydice);  if (mydice.basevalue > max) { max = mydice.basevalue; } } } if(dicelist.length > 0 && max > 0) { var backupdicelist = dicelist.copy(); for(mydice in backupdicelist) { if(mydice.basevalue == max) { dicelist.remove(mydice); } } if(dicelist.length > 0) { shuffle(dicelist); dicelist[0].removedice(self.screenposition()); if(d != 6) givedice(split(dicelist[0].basevalue)|~splitdice~); else givedice(split(dicelist[0].basevalue|3)~splitdice~); } else { shuffle(backupdicelist); backupdicelist[0].removedice(self.screenposition()); if(d != 6) givedice(split(backupdicelist[0].basevalue)|~splitdice~); else givedice(split(backupdicelist[0].basevalue|3)~splitdice~); } } },,,,,,,,,,
Rusty Key_downgraded,Do [sword]<d6> damage[;]|split your lowest dice,2,attack(d); sfxdamage(target|d); var dicelist = []; var min = 7; if(self.dicepool.length > 0) { for (mydice in self.dicepool){ if (mydice.available()){ dicelist.push(mydice);  if (mydice.basevalue < min) { min = mydice.basevalue; } } } if(dicelist.length > 0 && min < 7) { var backupdicelist = dicelist.copy(); for(mydice in backupdicelist) { if(mydice.basevalue == min) { dicelist.remove(mydice); } } if(dicelist.length > 0) { shuffle(dicelist); dicelist[0].removedice(self.screenposition()); givedice(split(dicelist[0].basevalue)|~splitdice~); } else { shuffle(backupdicelist); backupdicelist[0].removedice(self.screenposition()); givedice(split(backupdicelist[0].basevalue)|~splitdice~); } } },Magic Lockpick,NORMAL,,ORANGE,,,,none,0,NO,NO,,,var dicelist = []; var min = 7; if(self.dicepool.length > 0) { for (mydice in self.dicepool){ if (mydice.available()){ dicelist.push(mydice);  if (mydice.basevalue < min) { min = mydice.basevalue; } } } if(dicelist.length > 0 && min < 7) { var backupdicelist = dicelist.copy(); for(mydice in backupdicelist) { if(mydice.basevalue == min) { dicelist.remove(mydice); } } if(dicelist.length > 0) { shuffle(dicelist); dicelist[0].removedice(self.screenposition()); givedice(split(dicelist[0].basevalue)|~splitdice~); } else { shuffle(backupdicelist); backupdicelist[0].removedice(self.screenposition()); givedice(split(backupdicelist[0].basevalue)|~splitdice~); } } },,,,,,,,,,
Pyrite,Gain [gold]12[;] lose it after fight|Delete this if you'd have debt|[gray](once per battle),2,self.gold += 12;,Harvest,COUNTDOWN,12,PINK,change_power,change_function,,pickupgold,0,YES,YES,excludefromrandomlists|showgold,,,,if(self.gold < 12) { e.setvar(~ncrsaysgetridofpyrite~|true); if(self.layout == ~DECK~) { var cardlist = Deck.getcards(~all~); for(c in cardlist){ if(c.equipment.getvar(~ncrsaysgetridofpyrite~) == true) { c.delete(); } } } else { self.gold -= 12; } } else { self.gold -= 12; e.name = ~removemeblah~; removeequipment(~removemeblah~); },,,,,,,,
Pyrite_upgraded,Gain [gold]12[;] lose 10 after fight|Delete this if you'd have debt|[gray](once per battle),2,self.gold += 12;,Harvest,COUNTDOWN,12,PINK,,,,pickupgold,0,YES,YES,excludefromrandomlists|showgold,,,,if(self.gold < 10) { e.setvar(~ncrsaysgetridofpyrite~|true); if(self.layout == ~DECK~) { var cardlist = Deck.getcards(~all~); for(c in cardlist){ if(c.equipment.getvar(~ncrsaysgetridofpyrite~) == true) { c.delete(); } } } else { self.gold -= 10; } } else { self.gold -= 10; e.name = ~removemeblah~; removeequipment(~removemeblah~); },,,,,,,,
Pyrite_downgraded,Gain [gold]10[;] lose 12 after fight|Delete this if you'd have debt|[gray](once per battle),2,self.gold += 10;,Harvest,COUNTDOWN,12,PINK,,,,pickupgold,0,YES,YES,excludefromrandomlists|showgold,,,,if(self.gold < 12) { e.setvar(~ncrsaysgetridofpyrite~|true); if(self.layout == ~DECK~) { var cardlist = Deck.getcards(~all~); for(c in cardlist){ if(c.equipment.getvar(~ncrsaysgetridofpyrite~) == true) { c.delete(); } } } else { self.gold -= 12; } } else { self.gold -= 12; e.name = ~removemeblah~; removeequipment(~removemeblah~); },,,,,,,,
Pyrite_weakened,Gain [gold]10[;] lose it after fight|Delete this if you'd have debt|[gray](once per battle),2,self.gold += 10;,Harvest,COUNTDOWN,12,PINK,,,,pickupgold,0,YES,YES,excludefromrandomlists|showgold,,,,if(self.gold < 10) { e.setvar(~ncrsaysgetridofpyrite~|true); if(self.layout == ~DECK~) { var cardlist = Deck.getcards(~all~); for(c in cardlist){ if(c.equipment.getvar(~ncrsaysgetridofpyrite~) == true) { c.delete(); } } } else { self.gold -= 10; } } else { self.gold -= 10; e.name = ~removemeblah~; removeequipment(~removemeblah~); },,,,,,,,
Distort,Reroll this dice|Lose [heart]<d6> health,1,if(self.hp > d) { bonus(d * 10000); } givedice(); pierceattackself(d);,Delude,NORMAL,,PURPLE,change_power,change_function,,_heal,0,YES,NO,,1,,,,,,,,,,,
Distort_upgraded,Reroll this dice|Lose [heart]<d6> health|,1,if(self.hp > d) { bonus(d * 10000); } givedice(); pierceattackself(d);,Delude,NORMAL,,PURPLE,,,,_heal,2,YES,NO,,,,,,,,,,,,,
Distort_downgraded,Reroll this dice|Lose [heart]<d6>x0.5 health,1,if(self.hp > d/2) { bonus(d * 5000);  } givedice(); pierceattackself(d/2);,Delude,NORMAL,,PURPLE,,,,_heal,0,YES,NO,,,,,,,,,,,,,
Spite,Heal [heal]<charge>[;] discharge [sword]<charge>|Damage yourself to charge,2,if(e.charge == 0) { bonus(-990000); } else { bonus(e.charge * 10000); } attack(e.charge); sfxdamage(e.charge); attackself(-e.charge); e.charge = 0; if(!simulation) { self.setvar(~selfdmg~|0); },Deep Breath,DOUBLES|DOUBLES,,PURPLE,change_power,change_function,,_heal,0,NO,NO,,,,self.setvar(~selfdmg~|0); e.charge = 0;,var l = e.fulldescription.split(self.getvar(~selfdmg~)); if(l.length > 1) { e.fulldescription = l.join(~<charge>~); } self.setvar(~selfdmg~|0); e.charge = 0;,var l = e.fulldescription.split(self.getvar(~selfdmg~)); if(l.length > 1) { e.fulldescription = l.join(~<charge>~); } e.charge = self.getvar(~selfdmg~);,,var l = e.fulldescription.split(~<charge>~); if(l.length > 1) { e.fulldescription = l.join(e.charge); } self.setvar(~selfdmg~|e.charge);,,,,,
Spite_downgraded,Heal and discharge[;] but|do zero damage,2,if(e.charge < 6) { bonus(-990000); } attackself(-e.charge); e.charge = 0; if(!simulation) { self.setvar(~selfdmg~|0); },Deep Breath,DOUBLES|DOUBLES,,PURPLE,,,,_heal,0,NO,NO,,,,self.setvar(~selfdmg~|0); e.charge = 0;,var l = e.fulldescription.split(self.getvar(~selfdmg~)); if(l.length > 1) { e.fulldescription = l.join(~<charge>~); } self.setvar(~selfdmg~|0); e.charge = 0;,var l = e.fulldescription.split(self.getvar(~selfdmg~)); if(l.length > 1) { e.fulldescription = l.join(~<charge>~); } e.charge = self.getvar(~selfdmg~);,,var l = e.fulldescription.split(~<charge>~); if(l.length > 1) { e.fulldescription = l.join(e.charge); } self.setvar(~selfdmg~|e.charge);,,,,,
Spite_upgraded,Heal [heal]1.5x<charge>[;] discharge [sword]<charge>|Damage yourself to charge,2,if(e.charge == 0) { bonus(-990000); } else { bonus(e.charge * 10000); } attack(e.charge); sfxdamage(e.charge); attackself(-(e.charge * 1.5)); e.charge = 0; if(!simulation) { self.setvar(~selfdmg~|0); },Deep Breath,DOUBLES|DOUBLES,,PURPLE,,,,_heal,0,NO,NO,,,,self.setvar(~selfdmg~|0); e.charge = 0;,var l = e.fulldescription.split(self.getvar(~selfdmg~)); if(l.length > 1) { e.fulldescription = l.join(~<charge>~); } self.setvar(~selfdmg~|0); e.charge = 0;,var l = e.fulldescription.split(self.getvar(~selfdmg~)); if(l.length > 1) { e.fulldescription = l.join(~<charge>~); } e.charge = self.getvar(~selfdmg~);,,var l = e.fulldescription.split(~<charge>~); if(l.length > 1) { e.fulldescription = l.join(e.charge); } self.setvar(~selfdmg~|e.charge);,,,,,
Folly,Do [sword]<d6> damage|to both enemy and you,1,if(self.hp > d) { bonus(d * 10000); } else { bonus(-990000); } attack(d); attackself(d); sfxdamage(target|d);,Dramatic Pause,MAX4,,PURPLE,change_power,change_function,,none,0,NO,NO,,1,,,,,,,,,,,
Folly_downgraded,Do [sword]<d6> damage|to both enemy and you,1,if(self.hp > d) { bonus(d * 10000); } else { bonus(-990000); } attack(d); attackself(d); sfxdamage(target|d); /*originally folly downgraded was this; which i thought was kinda clever; but it doesn't make sense for jester since jester doesn't have fire resistance (this was originally for super wisp): if(self.hp > ((d/2) % 1 == 0 ? d/2 : d/2 + 0.5)) { bonus(d * 5000); } else { bonus(-990000); } attack(d|FIRE); attackself(d|FIRE); help how do i ceiling*/,Dramatic Pause,MAX3,,PURPLE,,,,none,0,NO,NO,,,,,,,,,,,,,
Folly_upgraded,Do [sword]<d6> damage|to both enemy and you[;]|and get a new dice,1,if(self.hp > d) { bonus(d * 10000); } else { bonus(-990000); } attack(d); attackself(d); sfxdamage(target|d); givedice();,Dramatic Pause,MAX4,,PURPLE,,,,none,0,NO,NO,,,,,,,,,,,,,
Flicker,Vanish [vanish]1 duplicate dice,1,inflict(~ncr_vanish~); /*still owe a lot to matz for making this remotely practical to implement back before runscript existed (specifically by introducing new elements.Skill)*/,Delude,EVEN,,PINK,simplify,complicate,,_vanish,0,NO,NO,,1,,,,,,,,,,,
Fastball,Do [sword]<triple> damage[;] but|lose 3 dice this fight|(no effect if you'd have 0),2,if(self.dice + self.extradice > 3) { attack(d * 3); sfxdamage(target|d * 3); self.extradice -= 3; } else self.textparticle(~No effect!~);,Infinity Mirror,MAX5,,PURPLE,simplify,change_function,,magic_gaindice,0,NO,NO,,,,,,,,,,,,,
Fastball_downgraded,Do [sword]<triple> damage[;] but|lose 4 dice this fight|(no effect if you'd have 0),2,if(self.dice + self.extradice > 4) { attack(d * 3); sfxdamage(target|d * 3); self.extradice -= 4; } else self.textparticle(~No effect!~);,Infinity Mirror,MAX5,,PURPLE,,,,magic_gaindice,0,NO,NO,,,,,,,,,,,,,
Respite,Heal [heal]0.5x<charge>[;] return dice|Take self-damage to charge,2,attackself(-e.charge * 0.5); givedice([d|d]);,Regenerate,DOUBLES|DOUBLES,,RED,change_power,complicate,,_heal,0,NO,NO,,,,self.setvar(~selfdmg_music~|0); e.charge = 0;,var l = e.fulldescription.split(self.getvar(~selfdmg~)); if(l.length > 1) { e.fulldescription = l.join(~<charge>~); } self.setvar(~selfdmg~|0); e.charge = 0;,var l = e.fulldescription.split(self.getvar(~selfdmg_music~)); if(l.length > 1) { e.fulldescription = l.join(~<charge>~); } e.charge = self.getvar(~selfdmg_music~);,,var l = e.fulldescription.split(~<charge>~); if(l.length > 1) { e.fulldescription = l.join(e.charge); } self.setvar(~selfdmg_music~|e.charge);,,,,,
Respite_upgraded,Heal [heal]0.5x<charge>[;] return dice|Take self-damage to charge,2,attackself(-e.charge * 0.5); givedice(d);,Regenerate,EVEN,,RED,,,,_heal,0,NO,NO,,,,self.setvar(~selfdmg_music~|0); e.charge = 0;,var l = e.fulldescription.split(self.getvar(~selfdmg~)); if(l.length > 1) { e.fulldescription = l.join(~<charge>~); } self.setvar(~selfdmg~|0); e.charge = 0;,var l = e.fulldescription.split(self.getvar(~selfdmg_music~)); if(l.length > 1) { e.fulldescription = l.join(~<charge>~); } e.charge = self.getvar(~selfdmg_music~);,,var l = e.fulldescription.split(~<charge>~); if(l.length > 1) { e.fulldescription = l.join(e.charge); } self.setvar(~selfdmg_music~|e.charge);,,,,,
Welder,Combine with a random|dice[;] return this dice,1,var c = 0; var extradice = []; var dicelist = []; if(self.dicepool.length > 0) { for (mydice in self.dicepool){ if (mydice.available() && !mydice.intween()) { dicelist.push(mydice); } } if(dicelist.length > 0) { var thisdice = rand(dicelist); if (thisdice.basevalue + d > 6){ extradice.push((thisdice.basevalue + d) % 6); if(extradice[extradice.length - 1] == 0) { extradice[extradice.length - 1] = 6; } thisdice.animatereroll(6| self.screenposition()| c * 0.05); } else { thisdice.animatereroll((thisdice.basevalue + d)| self.screenposition()| c * 0.05); c++; } givedice(extradice); } } givedice(d); sfx(~combinedice~);,Conformity,MAX4,,GREEN,change_power,change_function,,none,0,YES,NO,,1,,,,,,,,,,,
Welder_upgraded,Combine dice[;] and|return one of them,1,var randice = rand(actualdice); if(d > 0) givedice(d|~combinedice~); givedice(randice.basevalue);,Conformity,MAX4|NORMAL,,GREEN,,,,none,0,YES,NO,,,,,,,,,,,,,
Welder_downgraded,Combine with a|random dice,1,var c = 0; var extradice = []; var dicelist = []; if(self.dicepool.length > 0) { for (mydice in self.dicepool){ if (mydice.available() && !mydice.intween()) { dicelist.push(mydice); } } if(dicelist.length > 0) { var thisdice = rand(dicelist); if (thisdice.basevalue + d > 6){ extradice.push((thisdice.basevalue + d) % 6); if(extradice[extradice.length - 1] == 0) { extradice[extradice.length - 1] = 6; } thisdice.animatereroll(6| self.screenposition()| c * 0.05); } else { thisdice.animatereroll((thisdice.basevalue + d)| self.screenposition()| c * 0.05); c++; } givedice(extradice); } } sfx(~combinedice~);,Conformity,MAX4,,GREEN,,,,none,0,YES,NO,,,,,,,,,,,,,
Third Place Cauldron,Get a different dice[;] do [sword]3|,1,givedice(rand([1|2|4|5|6])); attack(3);,Magic Dice,REQUIRE3,,ORANGE,change_power,change_function,,_damage,3,NO,NO,,1,,,,,,,,,,,
Third Place Cauldron_upgraded,Get a higher dice[;] do [sword]3|,1,givedice(rand([4|5|6])); attack(3);,Magic Dice,REQUIRE3,,ORANGE,,,,_damage,3,NO,NO,,,,,,,,,,,,,
Third Place Cauldron_downgraded,Do [sword]3 damage|,1,attack(3);,Magic Dice,REQUIRE3,,ORANGE,,,,_damage,3,NO,NO,,,,,,,,,,,,,
Holy Water,Recover [heal]<d6> health|[gray](once per battle),1,attackself(-d);,Health Pack,MAX4|MAX4,,GREEN,change_power,decreaserange,,_heal,0,YES,YES,,,,,,,,,,,,,
Holy Water_upgraded,Recover [heal]<d6> health|[gray](once per battle),2,attackself(-d);,Health Pack,MAX4|MAX4|MAX4|MAX4,,GREEN,,,,_heal,0,YES,YES,,,,,,,,,,,,,
Ultra Spanner,Combine dice. On doubles[;]|recover [heal]<slotdoubles> health,1,if(actualdice[0].basevalue == actualdice[1].basevalue) { attackself(-actualdice[0].basevalue); sfx(~_heal~); } if(d >= 1) givedice(d| ~combinedice~);,Battle Wrench,MAX3|MAX3,,GREEN,increaserange,,,_heal,0,YES,NO,,1,,,,,,,,,,,
Ultra Spanner_downgraded,Combine dice. On doubles[;]|recover [heal]<slotdoubles> health instead,1,if(actualdice[0].basevalue == actualdice[1].basevalue) { attackself(-actualdice[0].basevalue); sfx(~_heal~); } else { if(d >= 1) givedice(d| ~combinedice~); },Battle Wrench,MAX3|MAX3,,GREEN,,,,_heal,0,YES,NO,,,,,,,,,,,,,
Freeze,Error your skillcard[;]|roll two new dice|[gray](errors on jackpot),1,self.getskillcard().animate(~error~); givedice([rand([1|2|3|4|5|6])|rand([1|2|3|4|5|6])]);,Magic Dice,ODD,,BRIGHTCYAN,simplify,doublerequirements,,roboterror,0,YES,NO,,,,,,,,,if(self.roll_jackpot > 0) { roboterror(self| [e]); },,,,
Junk Sword,Do [sword]<d6> damage. On 5[;]|if this is the last turn[;] this|is guaranteed for scrap,1,attack(d); if(d == 5) { sfx(~_thinghappens~); e.addtag(~appearsforparts~); },Less Fluff,MAX5,,GRAY,change_power,change_power,,_damage,0,NO,NO,excludefromrandomlists|inventoronly,,,,,e.removetag(~appearsforparts~);,e.removetag(~appearsforparts~);,,,,,,
Junk Sword_upgraded,Do [sword]<d6> damage|[gray](Always offered as scrap),1,attack(d);,Less Fluff,MAX5,,GRAY,,,,_damage,0,NO,NO,excludefromrandomlists|inventoronly|appearsforparts,,,,,,,,,,,,
Junk Sword_downgraded,Do [sword]<d6> damage. On 5[;]|if this is the last turn[;] this|is guaranteed for scrap,1,attack(d); if(d == 5) { sfx(~_thinghappens~); e.addtag(~appearsforparts~); },Less Fluff,ODD,,GRAY,,,,_damage,0,NO,NO,excludefromrandomlists|inventoronly,,,,,e.removetag(~appearsforparts~);,e.removetag(~appearsforparts~);,,,,,,
Manual Turret,Deal [sword]3 damage[;]|spare 3 provided,1,attack(3);,Dice Bash,COUNTDOWN|SPARE3,3,RED,change_power,burnsparedice,,_damage,0,NO,NO,,,,,,,,,,,,,
Manual Turret_upgraded,Deal [sword]4 damage[;]|spare 4 provided,1,attack(4);,Dice Bash,COUNTDOWN|SPARE4,4,RED,,,,_damage,0,NO,NO,,,,,,,,,,,,,
Smartwatch,At start of turn[;] get a dice|equal to turn number|(max 6),1,,Mirror Smash,,,GRAY,change_power,change_power,,none,0,YES,NO,cannotreuse|shockavoid|altpoisonavoid,,,,,,e.animate(~flash~); /*var gd = turn % 6; if(gd == 0) { gd = 6; }*/ var gd = turn; if(gd > 6) { gd = 6; } var mynewdice = new elements.Dice(); mynewdice.basevalue = gd; self.dicepool.push(mynewdice); mynewdice.x = e.x + 280; mynewdice.y = e.y + 192; sfx(~jackpot_rolldice~); e.doequipmentaction(self|target|-e.castdirection|[]|0.5|true);,,, ,,e.preventdefault = true; e.maintainfury = true;,
Smartwatch_upgraded,At start of turn[;] get a dice|equal to turn number[;]|(max 6[;]) then do [sword]2,1,attack(2);,Mirror Smash,,,GRAY,,,,_damage,0,NO,NO,cannotreuse|shockavoid|altpoisonavoid,,,,,,e.animate(~flash~); /*var gd = turn % 6; if(gd == 0) { gd = 6; }*/ var gd = turn; if(gd > 6) { gd = 6; } var mynewdice = new elements.Dice(); mynewdice.basevalue = gd; self.dicepool.push(mynewdice); mynewdice.x = e.x + 280; mynewdice.y = e.y + 192; sfx(~jackpot_rolldice~); e.doequipmentaction(self|target|e.castdirection|[]|0.5|false);,,,,,e.preventdefault = true; e.maintainfury = true;,
Smartwatch_downgraded,At start of turn[;] get a dice|equal to turn number[;]|(max 6[;]) but take [sword]2,1,attackself(2);,Mirror Smash,,,GRAY,,,,_damage,0,YES,NO,cannotreuse|shockavoid|altpoisonavoid,,,,,,e.animate(~flash~); /*var gd = turn % 6; if(gd == 0) { gd = 6; }*/ var gd = turn; if(gd > 6) { gd = 6; } var mynewdice = new elements.Dice(); mynewdice.basevalue = gd; self.dicepool.push(mynewdice); mynewdice.x = e.x + 280; mynewdice.y = e.y + 192; sfx(~jackpot_rolldice~); e.doequipmentaction(self|target|-e.castdirection|[]|0.5|false);,,,,,e.preventdefault = true; e.maintainfury = true;,
Bronze Dagger,Odd: do [sword]<d6> damage|Even: get an odd dice[;] reuse,2,if(d % 2 == 0) { givedice(rand([1|3|5])); } else { attack(d); sfxdamage(target|d); },Gadget Roll,NORMAL,,ORANGE,change_power,change_power,,none,-1,YES,NO,hidereuseable,,,,,,,,,if(d % 2 == 1) { e.usesleft = 0; e.castdirection = 1; } else { e.castdirection = -1; },,,
Bronze Dagger_upgraded,Even: do [sword]<d6> damage|Odd: get an even dice[;] reuse,2,if(d % 2 == 1) { givedice(rand([2|4|6])); } else { attack(d); sfxdamage(target|d); } /*if(d % 2 == 1) { if(e.getvar(~oddused~) == true) { e.timesused -= 1; self.equipmentused--; } else {e.setvar(~oddused~|true); } givedice(rand([1|3|5])); } else { attack(d); sfxdamage(target|d); e.playcharactervoice(target.name); } */,Gadget Roll,NORMAL,,ORANGE,,,,none,-1,YES,NO,hidereuseable,,,,,/*e.setvar(~oddused~|false);*/,,/*e.setvar(~oddused~|false);*/,,if(d % 2 == 0) { e.usesleft = 0; e.castdirection = 1; } else { e.castdirection = -1; },,,
Bronze Dagger_downgraded,Odd: do [sword]<d6> damage|Even: get an odd dice,2,if(d % 2 == 0) { givedice(rand([1|3|5])); } else { attack(d); sfxdamage(target|d); },Gadget Roll,NORMAL,,ORANGE,,,,none,0,YES,NO,hidereuseable,,,,,,,,,if(d % 2 == 1) { e.castdirection = 1; } else { e.castdirection = -1; },,,
Jester,Marotte|Pick lowest dice[;] do|[sword]<d6> and reroll it,2,var dicelist = []; if(self.dicepool.length > 0) { for(mydice in self.dicepool) { if(mydice.available()) { dicelist.push(mydice); } } dicelist.sort(function(a|b) return a.basevalue - b.basevalue); for(mydice in dicelist) { if(mydice.basevalue > dicelist[0].basevalue) { dicelist.remove(mydice); } } var dicelistcopy = dicelist.copy(); for(mydice in dicelist) { if(mydice.burn) { dicelist.remove(mydice); } } for(mydice in dicelist) { if(mydice.blind) { dicelist.remove(mydice); } } if(dicelist.length > 0) { attack(dicelist[0].basevalue); dicelist[0].animatereroll(rand([1|2|3|4|5|6])|self.screenposition()); } else { dicelist = dicelistcopy.copy(); for(mydice in dicelist) { if(mydice.blind) { dicelist.remove(mydice); } } if(dicelist.length > 0) { attack(dicelist[0].basevalue); dicelist[0].animatereroll(rand([1|2|3|4|5|6])|self.screenposition()); } else { dicelist = dicelistcopy.copy(); for(mydice in dicelist) { if(mydice.burn) { dicelist.remove(mydice); } } if(dicelist.length > 0) { attack(dicelist[0].basevalue); dicelist[0].animatereroll(rand([1|2|3|4|5|6])|self.screenposition()); } else { dicelist = dicelistcopy.copy(); if(dicelist.length > 0) { attack(dicelist[0].basevalue); dicelist[0].animatereroll(rand([1|2|3|4|5|6])|self.screenposition()); } } } } } else { self.textparticle(~No dice!~); },Dice Bash,,,RED,,,,_damage,0,NO,NO,powercard,,,,,,,,,var dicelist = []; for (mydice in self.dicepool) { if (mydice.available()){ dicelist.push(mydice); } } dicelist.sort(function(a|b) { return a.basevalue - b.basevalue; } ); d = dicelist[0].basevalue;,,,
Ice Nine,Inflict [ice]<timesused> freeze[;]|+1 each turn,1,inflict(ICE|turn); e.timesused -= 1;,Arctic Storm,NORMAL|NORMAL,9,BRIGHTCYAN,change_power,change_power,,_ice,0,NO,NO,,1,e.timesused -= 1;,,,,,e.timesused += 1;,,,,,
Ice Nine_downgraded,Inflict [ice]<timesused> freeze[;]|+1 each turn,1,inflict(ICE|turn); e.timesused -= 1;,Arctic Storm,REQUIRE6|REQUIRE3,,BRIGHTCYAN,,,,_ice,0,NO,NO,,,e.timesused -= 1;,,,,,e.timesused += 1;,,,,,
Ice Nine_upgraded,Inflict [ice]<timesused> freeze[;]|+1 each turn,1,inflict(ICE|turn); e.timesused -= 1;,Arctic Storm,COUNTDOWN,9,BRIGHTCYAN,,,,_ice,0,NO,NO,,,e.timesused -= 1;,,,,,e.timesused += 1;,,,,,
PyrotechnIX,Inflict [fire]<timesused> burn[;]|+1 each turn,1,inflict(FIRE|turn); e.timesused -= 1;,Hellfire,NORMAL|NORMAL,9,RED,change_power,change_power,,_fire,0,NO,NO,,1,e.timesused -= 1;,,,,,e.timesused += 1;,,,,,
PyrotechnIX_downgraded,Inflict [fire]<timesused> burn[;]|+1 each turn,1,inflict(FIRE|turn); e.timesused -= 1;,Hellfire,REQUIRE6|REQUIRE3,,RED,,,,_fire,0,NO,NO,,,e.timesused -= 1;,,,,,e.timesused += 1;,,,,,
PyrotechnIX_upgraded,Inflict [fire]<timesused> burn[;]|+1 each turn,1,inflict(FIRE|turn); e.timesused -= 1;,Hellfire,COUNTDOWN,9,RED,,,,_fire,0,NO,NO,,,e.timesused -= 1;,,,,,e.timesused += 1;,,,,,
Octobar,Reduce countdowns by 10,1,boostcountdowns(actualdice[0].basevalue); boostcountdowns(actualdice[1].basevalue);,Accelerate,NORMAL|NORMAL,10,ORANGE,change_power,change_power,,none,0,YES,NO,,,,,,,,,,,,,
Metacrowbar,Reduce countdowns by|the last dice inserted,1,boostcountdowns(e.dicehistory[e.dicehistory.length - 1].basevalue);,Accelerate,COUNTDOWN,8,GREEN,change_power,change_power,,none,0,YES,NO,,,,,,,,,,,,,
Nail Bar,Boost countdowns by <d6>|(You lose [heart]2 hp each turn),1,boostcountdowns(3); boostcountdowns(actualdice[0].basevalue);,Accelerate,NORMAL|FREE3,,RED,change_power,change_power,,none,0,YES,NO,,,,,,,e.animate(~flashandshake~); pierceattackself(2); sfx(~_damage~);,,,,,,
Wolf Puppy[],Bark Bark Bark|Everyone gets [fury]Fury,2,inflictself(FURY); inflict(FURY); /*name is weird so it does not replace the actual wolf puppy card in backstage*/,Fury,,,RED,,change_power,,_fury,0,YES,NO,powercard,,,,,,,,,,,e.preventdefault = true; e.maintainfury = true;,
Wolf Puppy[]_downgraded,Scratch Scratch Scratch|Everyone takes [sword]2 dmg,2,attack(2); attackself(2); sfxdamage(self|2); sfxdamage(target|2);,Fury,,,RED,,,,_fury,0,YES,NO,powercard,,,,,,,,,,,e.preventdefault = true; e.maintainfury = true;,
Wolf Puppy?,Injection|Next card use also|deals [d6] damage,2,inflictself(~ncr_injection~); sfx(~_cure~); var cardlist = Deck.getcards(~all~); var injectstring = ~if(getstatusself(\~ncr_injection\~) > 0 && d > 0) { attack(d); sfxdamage(target|d); removestatusself(\~ncr_injection\~|1); } ~; for(c in cardlist) { if(c.equipment.script.indexOf(injectstring) == -1) { c.equipment.scriptrunner = null; c.equipment.script = injectstring + c.equipment.script; } } /*purposefully not doing it the more obvious way with statuseffects.csv - cody pioneered script injection*/,Efficiency,,,RED,,change_power,,none,0,YES,NO,alternateversion|powercard,,,,,,,,,,,,
Wolf Puppy?_downgraded,Popular Request|Gain [recycle]Re-Equip[],2,inflictself(REEQUIPNEXT);,Efficiency,,,RED,,,,_recycle,0,YES,NO,alternateversion|powercard,,,,,,,,,,,,
Wisp[],Spirit Bomb|Do [sword]2 damage|per duplicate dice,2,var dicelist = []; for(mydice in self.dicepool) { if(mydice.available()) { dicelist.push(mydice); } } for(i in 1...7) { for(mydice in self.dicepool) { if(mydice.basevalue == i) { dicelist.remove(mydice); break; } } } if(dicelist.length == 0) { self.textparticle(~No effect!~); } else { attack(dicelist.length * 2); sfxdamage(target|dicelist.length * 2); },Dice Bash,,,PURPLE,,change_power,,none,0,NO,NO,powercard,,var dicelist = []; var t = 0; for(mydice in self.dicepool) { if(mydice.available()) { dicelist.push(mydice); } } for(i in 1...7) { for(mydice in self.dicepool) { if(mydice.basevalue == i) { dicelist.remove(mydice); break; } } } if(dicelist.length == 0) { self.textparticle(~No effect!~); } else { for(mydice in dicelist) { mydice.animate(~disappear~|t); t += 0.1; } },,,,,,,,,,
Wisp[]_downgraded,Fool's Fool's Fire|Do [sword]4[;] get [vanish]Vanish_ALL,2,attack(4); inflictself(VANISH);,Dice Bash,,,PURPLE,,,,none,0,NO,NO,powercard,,inflictself(VANISH);,,,,,,,,,,
Wisp?,Signed Portrait|Get a brilliant and|creative item,2,//$replacemewith(rand([~Keyhole~|~Ashley Bat~|~Sacred Grounds~|~Drill~|~Virtue Grip~|~new elements.Equipment(null);~|~Tap~])| -1);$ /*readd hammer up! once https://github.com/TerryCavanagh/diceydungeons.com/issues/1840 is addressed*/,THE [200%]GASDGFET,,,PURPLE,,change_power,,_vanish,0,YES,NO,alternateversion|powercard|cannotreuse,,,self.setvar(~hammers~|0);,/*this is meant to be here; wisp? can summon hammer up*/ var cardlist = Deck.getcards(~all~); var ham = self.getvar(~hammers~); if(ham < 0) { while(ham < 0) { addjestercard(~Rubber Mallet~); ham++; } } if(ham > 0) { while(ham > 0) { for(mycard in cardlist) { if(mycard.equipment.name == ~Rubber Mallet~ && mycard.equipment.equipmentcol == 2) { mycard.delete(); ham--; break; } } } },,,,,,,,
Wisp?_downgraded,Eternal Damnation|Install and instantly activate|the worst mod imaginable,2,self.textparticle(~Too late~);,THE [200%]GASDGFET,,,PURPLE,,,,_vanish,0,YES,NO,alternateversion|powercard,,,,,,,,,,,,
Uberbump,+<d6> to all dice[;]|won't bump above 6,1,var c = 0; var extradice = []; for (mydice in self.dicepool){ if (mydice.available()){ if(mydice.basevalue == 6) continue; else { if(mydice.basevalue + d > 6){ mydice.animatereroll(6| self.screenposition()| c * 0.05); } else { mydice.animatereroll((mydice.basevalue + d)| self.screenposition()| c * 0.05); } c++; } } },Double Whammy,MAX2,,GREEN,increaserange,decreaserange,,diceroll,0,YES,NO,,1,,,,,,,,,,,
Freeze Frame,Get a 6[;] but [ice]freeze|yourself twice each turn,1,/*former ignore reequip method*/,Mirror Smash,,,BRIGHTCYAN,change_power,change_power,,none,0,YES,NO,cannotreuse|shockavoid|altpoisonavoid,,,,,inflictself(ICE|2);,e.animate(~flash~); var mynewdice = new elements.Dice(); mynewdice.basevalue = 6; self.dicepool.push(mynewdice); mynewdice.x = e.x + 280; mynewdice.y = e.y + 192; sfx(~jackpot_rolldice~); e.doequipmentaction(self|target|-e.castdirection|[]|0.5|true);,,,,,e.preventdefault = true; e.maintainfury = true;,
Freeze Frame_upgraded,Get a 6[;] but [ice]freeze|yourself once each turn,1,/*former ignore reequip method*/,Mirror Smash,,,BRIGHTCYAN,,,,none,0,YES,NO,cannotreuse|shockavoid|altpoisonavoid,,,,,inflictself(ICE);,e.animate(~flash~); var mynewdice = new elements.Dice(); mynewdice.basevalue = 6; self.dicepool.push(mynewdice); mynewdice.x = e.x + 280; mynewdice.y = e.y + 192; sfx(~jackpot_rolldice~); e.doequipmentaction(self|target|-e.castdirection|[]|0.5|true);,,,,,e.preventdefault = true; e.maintainfury = true;,
Freeze Frame_downgraded,Get a 5[;] but [ice]freeze|yourself twice each turn,1,/*former ignore reequip method*/,Mirror Smash,,,BRIGHTCYAN,,,,none,0,YES,NO,cannotreuse|shockavoid|altpoisonavoid,,,,,inflictself(ICE|2);,e.animate(~flash~); var mynewdice = new elements.Dice(); mynewdice.basevalue = 5; self.dicepool.push(mynewdice); mynewdice.x = e.x + 280; mynewdice.y = e.y + 192; sfx(~jackpot_rolldice~); e.doequipmentaction(self|target|-e.castdirection|[]|0.5|true);,,,,,e.preventdefault = true; e.maintainfury = true;,
Freeze Frame_weakened,Get a 5[;] but [ice]freeze|yourself once each turn,1,/*former ignore reequip method*/,Mirror Smash,,,BRIGHTCYAN,,,,none,0,YES,NO,cannotreuse|shockavoid|altpoisonavoid,,,,,inflictself(ICE);,e.animate(~flash~); var mynewdice = new elements.Dice(); mynewdice.basevalue = 5; self.dicepool.push(mynewdice); mynewdice.x = e.x + 280; mynewdice.y = e.y + 192; sfx(~jackpot_rolldice~); e.doequipmentaction(self|target|-e.castdirection|[]|0.5|true);,,,,,e.preventdefault = true; e.maintainfury = true;,
Blockbuster,Turn start: make any card|but this error-immune[;]|it will not be indicated,1,/*Blockbuster Video offers a great selection of restricted movies inappropriate for viewers under seventeen and provides computerized enforcement. You decide what kind of videos you want to watch and Blockbuster Video enforces your wishes.*/,Efficiency,,,GRAY,change_power,,,none,0,NO,NO,robotonly,,,,,,for(eq in self.equipment) { if(eq.hastag(~removeerrorimmune~)) { eq.removetag(~errorimmune~); } } e.animate(~flashandshake~); var eqlist = []; for(eq in self.equipment) { if(!eq.hastag(~errorimmune~) && eq.skillcard == ~~ && eq != e && !eq.hastag(~nevererrorimmune~)) { eqlist.push(eq); } } if(eqlist.length > 0) { var eq = rand(eqlist); eq.addtag(~errorimmune~); eq.addtag(~removeerrorimmune~); },,,,,,
Blockbuster_upgraded,Turn start: make any card|but this error-immune[;]|indicate it with a flash,1,,Efficiency,,,GRAY,,,,none,0,NO,NO,robotonly,,,,,,for(eq in self.equipment) { if(eq.hastag(~removeerrorimmune~)) { eq.removetag(~errorimmune~); } } e.animate(~flashandshake~); var eqlist = []; for(eq in self.equipment) { if(!eq.hastag(~errorimmune~) && eq.skillcard == ~~ && eq != e && !eq.hastag(~nevererrorimmune~)) { eqlist.push(eq); } } if(eqlist.length > 0) { var eq = rand(eqlist); eq.addtag(~errorimmune~); eq.animate(~flashandshake~); eq.addtag(~removeerrorimmune~); },,,,,,
Icebox,Do [ice]<d6> damage[;] on 4[;]|get an Icecube for this turn,1,attack(d|ICE); if(d == 4 && getstatusself(FURY) < 1) { if(self.getvar(~marshkludge~) == 0) { giveequipment(~Icecube~|true); } else { giveequipment(~Matchstick~|true); } sfx(~_thinghappens~); } /*icebox actually came before matchbox; mainly because matchstick isnt very good except in pu*/,Flash Freeze,MAX4,,BRIGHTCYAN,change_power,change_power,,_damage,0,NO,NO,excludefromrandomlists,,,,,,,,,,,donothing();,
Icebox_upgraded,Do [ice]<d6> damage[;] on 4[;]|get an Icecube pemanently,1,attack(d|ICE); if(d == 4 && getstatusself(FURY) < 1) { if(self.getvar(~marshkludge~) == 0) { giveequipment(~Icecube~|true|false|e); } else { giveequipment(~Matchstick~|true|false|e); } sfx(~openchest~); },Flash Freeze,MAX4,,BRIGHTCYAN,,,,_damage,0,NO,NO,excludefromrandomlists,,,,,,,,,,,donothing();,
Icebox_downgraded,Do [ice]<d6> damage[;] on 4[;]|inflict [ice]freeze,1,attack(d|ICE); if(d == 4) { inflict(ICE); },Flash Freeze,MAX4,,BRIGHTCYAN,,,,_damage,0,NO,NO,excludefromrandomlists,,,,,,,,,,,donothing();,
Matchbox,Do [fire]<d6> damage[;] on 4[;]|get Matchstick for this turn,1,attack(d|FIRE); if(d == 4 && getstatusself(FURY) < 1) { if(self.getvar(~marshkludge~) == 0) { giveequipment(~Matchstick~|true); } else { giveequipment(~Icecube~|true); } sfx(~_thinghappens~); },Blowtorch,MAX4,,RED,change_power,change_power,,_damage,0,NO,NO,excludefromrandomlists,,,,,,,,,,,donothing();,
Matchbox_upgraded,Do [fire]<d6> damage[;] on 4[;]|get Matchstick permanently,1,attack(d|FIRE); if(d == 4 && getstatusself(FURY) < 1) { if(self.getvar(~marshkludge~) == 0) { giveequipment(~Matchstick~|true|false|e); } else { giveequipment(~Icecube~|true|false|e); } sfx(~openchest~); },Blowtorch,MAX4,,RED,,,,_damage,0,NO,NO,excludefromrandomlists,,,,,,,,,,,donothing();,
Matchbox_downgraded,Do [fire]<d6> damage[;] on 4[;]|inflict [fire]burn,1,attack(d|FIRE); if(d == 4) { inflict(FIRE); },Blowtorch,MAX4,,RED,,,,_damage,0,NO,NO,excludefromrandomlists,,,,,,,,,,,donothing();,
Hot Table,Get a 6[;] but [fire]burn|yourself twice each turn,1,/*'hot table' is craps terminology for a particular table with a very good winning streak*/,Mirror Smash,,,RED,change_power,change_power,,none,0,YES,NO,cannotreuse|shockavoid|altpoisonavoid,,,,,inflictself(FIRE|2);,e.animate(~flash~); var mynewdice = new elements.Dice(); mynewdice.basevalue = 6; self.dicepool.push(mynewdice); mynewdice.x = e.x + 280; mynewdice.y = e.y + 192; sfx(~jackpot_rolldice~); e.doequipmentaction(self|target|-e.castdirection|[]|0.5|true);,,,,,e.preventdefault = true; e.maintainfury = true;,
Hot Table_upgraded,Get a 6[;] but [fire]burn|yourself once each turn,1,/*former ignore reequip method*/,Mirror Smash,,,RED,,,,none,0,YES,NO,cannotreuse|shockavoid|altpoisonavoid,,,,,inflictself(FIRE);,e.animate(~flash~); var mynewdice = new elements.Dice(); mynewdice.basevalue = 6; self.dicepool.push(mynewdice); mynewdice.x = e.x + 280; mynewdice.y = e.y + 192; sfx(~jackpot_rolldice~); e.doequipmentaction(self|target|-e.castdirection|[]|0.5|true);,,,,,e.preventdefault = true; e.maintainfury = true;,
Hot Table_downgraded,Get a 5[;] but [fire]burn|yourself twice each turn,1,/*former ignore reequip method*/,Mirror Smash,,,RED,,,,none,0,YES,NO,cannotreuse|shockavoid|altpoisonavoid,,,,,inflictself(FIRE|2);,e.animate(~flash~); var mynewdice = new elements.Dice(); mynewdice.basevalue = 5; self.dicepool.push(mynewdice); mynewdice.x = e.x + 280; mynewdice.y = e.y + 192; sfx(~jackpot_rolldice~); e.doequipmentaction(self|target|-e.castdirection|[]|0.5|true);,,,,,e.preventdefault = true; e.maintainfury = true;,
Hot Table_weakened,Get a 5[;] but [fire]burn|yourself once each turn,1,/*former ignore reequip method*/,Mirror Smash,,,RED,,,,none,0,YES,NO,cannotreuse|shockavoid|altpoisonavoid,,,,,inflictself(FIRE);,e.animate(~flash~); var mynewdice = new elements.Dice(); mynewdice.basevalue = 5; self.dicepool.push(mynewdice); mynewdice.x = e.x + 280; mynewdice.y = e.y + 192; sfx(~jackpot_rolldice~); e.doequipmentaction(self|target|-e.castdirection|[]|0.5|true);,,,,,e.preventdefault = true; e.maintainfury = true;,
Hunting Knife@large,Do [sword]<d6> damage[;] flip slot|,2,var swapto = ~Hunting Knife@small~;  attack(d);  sfxdamage(target|d);    if(getstatusself(FURY) < 1) {   var eqtoreplace = ~~;   var onscreenreplace = false;   for(eq in self.equipment) {    /* determine if e is a copy of an equipment that is multiuse or had re-equip used on it; and if it is; store the original variable as eqtoreplace and enable the flag that tells us we're replacing an item already on screen. there's probably an easier way to do this but idk */    if(    e.name == eq.name &&     e.namemodifier == eq.namemodifier &&     (eq.x + 100) >= e.x &&     (eq.x - 100) <= e.x &&     eq != e) {      eqtoreplace = eq; onscreenreplace = true; break;    }   }   if(onscreenreplace) {    var neweq = new elements.Equipment(swapto);    neweq.x = eqtoreplace.x;    neweq.y = eqtoreplace.y;    neweq.row = eqtoreplace.row;    neweq.column = eqtoreplace.column;    if(self.equipment.indexOf(eqtoreplace) != -1) { /*dumb safeguard*/     self.equipment[self.equipment.indexOf(eqtoreplace)] = neweq; /*i don't know why this is necessary but it is; you're just not allowed to refer to equipment through variables when overwriting it with another equipment*/     neweq.animate(~flashandshake~); /*also two variables can't point to the same equipment i guess; doing eqtoreplace.animate(~flashandshake~) has no effect*/    }   } else {    var neweq = new elements.Equipment(swapto);    neweq.column = e.column;    neweq.row = e.row;    neweq.x = -9999;    neweq.y = -9999;    neweq.show = false;    neweq.availablethisturn = false;    if(self.equipment.indexOf(e) != -1) { /*dumb safeguard*/     self.equipment[self.equipment.indexOf(e)] = neweq;    }   }  },Steal,MIN5,,RED,change_power,change_power,,none,-1,NO,NO,excludefromrandomlists,,var swapto = ~Hunting Knife@small~;      if(getstatusself(FURY) < 1) {   var eqtoreplace = ~~;   var onscreenreplace = false;   for(eq in self.equipment) {    /* determine if e is a copy of an equipment that is multiuse or had re-equip used on it; and if it is; store the original variable as eqtoreplace and enable the flag that tells us we're replacing an item already on screen. there's probably an easier way to do this but idk */    if(    e.name == eq.name &&     e.namemodifier == eq.namemodifier &&     (eq.x + 100) >= e.x &&     (eq.x - 100) <= e.x &&     eq != e) {      eqtoreplace = eq; onscreenreplace = true; break;    }   }   if(onscreenreplace) {    var neweq = new elements.Equipment(swapto);    neweq.x = eqtoreplace.x;    neweq.y = eqtoreplace.y;    neweq.row = eqtoreplace.row;    neweq.column = eqtoreplace.column;    if(self.equipment.indexOf(eqtoreplace) != -1) { /*dumb safeguard*/     self.equipment[self.equipment.indexOf(eqtoreplace)] = neweq; /*i don't know why this is necessary but it is; you're just not allowed to refer to equipment through variables when overwriting it with another equipment*/     neweq.animate(~flashandshake~); /*also two variables can't point to the same equipment i guess; doing eqtoreplace.animate(~flashandshake~) has no effect*/    }   } else {    var neweq = new elements.Equipment(swapto);    neweq.column = e.column;    neweq.row = e.row;    neweq.x = -9999;    neweq.y = -9999;    neweq.show = false;    neweq.availablethisturn = false;    if(self.equipment.indexOf(e) != -1) { /*dumb safeguard*/     self.equipment[self.equipment.indexOf(e)] = neweq;    }   }  },,,e.countdown = 0;,,,,e.countdown = 7; /*glitch abuse! this breaks the card so you can't insert another dice after your first dice until the card is replaced. with hunting this prevents you from cramming in more high/low dice than you should be able to; with whisplikes this prevents you from getting the same effect on 5 twice (if you have reequip). perhaps doing this will lead to some obscure and strange cornercase bug that will take me days to track down... affected by crowbar? triggers on any countdown reduce?*/,,donothing();,
Hunting Knife@small,Do [sword]<d6> damage[;] flip slot|,2,var swapto = ~Hunting Knife@large~;  attack(d);  sfxdamage(target|d);    if(getstatusself(FURY) < 1) {   var eqtoreplace = ~~;   var onscreenreplace = false;   for(eq in self.equipment) {    /* determine if e is a copy of an equipment that is multiuse or had re-equip used on it; and if it is; store the original variable as eqtoreplace and enable the flag that tells us we're replacing an item already on screen. there's probably an easier way to do this but idk */    if(    e.name == eq.name &&     e.namemodifier == eq.namemodifier &&     (eq.x + 100) >= e.x &&     (eq.x - 100) <= e.x &&     eq != e) {      eqtoreplace = eq; onscreenreplace = true; break;    }   }   if(onscreenreplace) {    var neweq = new elements.Equipment(swapto);    neweq.x = eqtoreplace.x;    neweq.y = eqtoreplace.y;    neweq.row = eqtoreplace.row;    neweq.column = eqtoreplace.column;    if(self.equipment.indexOf(eqtoreplace) != -1) { /*dumb safeguard*/     self.equipment[self.equipment.indexOf(eqtoreplace)] = neweq; /*i don't know why this is necessary but it is; you're just not allowed to refer to equipment through variables when overwriting it with another equipment*/     neweq.animate(~flashandshake~); /*also two variables can't point to the same equipment i guess; doing eqtoreplace.animate(~flashandshake~) has no effect*/    }   } else {    var neweq = new elements.Equipment(swapto);    neweq.column = e.column;    neweq.row = e.row;    neweq.x = -9999;    neweq.y = -9999;    neweq.show = false;    neweq.availablethisturn = false;    if(self.equipment.indexOf(e) != -1) { /*dumb safeguard*/     self.equipment[self.equipment.indexOf(e)] = neweq;    }   }  },Steal,MAX2,,RED,change_power,change_power,,none,-1,NO,NO,excludefromrandomlists,,var swapto = ~Hunting Knife@large~;      if(getstatusself(FURY) < 1) {   var eqtoreplace = ~~;   var onscreenreplace = false;   for(eq in self.equipment) {    /* determine if e is a copy of an equipment that is multiuse or had re-equip used on it; and if it is; store the original variable as eqtoreplace and enable the flag that tells us we're replacing an item already on screen. there's probably an easier way to do this but idk */    if(    e.name == eq.name &&     e.namemodifier == eq.namemodifier &&     (eq.x + 100) >= e.x &&     (eq.x - 100) <= e.x &&     eq != e) {      eqtoreplace = eq; onscreenreplace = true; break;    }   }   if(onscreenreplace) {    var neweq = new elements.Equipment(swapto);    neweq.x = eqtoreplace.x;    neweq.y = eqtoreplace.y;    neweq.row = eqtoreplace.row;    neweq.column = eqtoreplace.column;    if(self.equipment.indexOf(eqtoreplace) != -1) { /*dumb safeguard*/     self.equipment[self.equipment.indexOf(eqtoreplace)] = neweq; /*i don't know why this is necessary but it is; you're just not allowed to refer to equipment through variables when overwriting it with another equipment*/     neweq.animate(~flashandshake~); /*also two variables can't point to the same equipment i guess; doing eqtoreplace.animate(~flashandshake~) has no effect*/    }   } else {    var neweq = new elements.Equipment(swapto);    neweq.column = e.column;    neweq.row = e.row;    neweq.x = -9999;    neweq.y = -9999;    neweq.show = false;    neweq.availablethisturn = false;    if(self.equipment.indexOf(e) != -1) { /*dumb safeguard*/     self.equipment[self.equipment.indexOf(e)] = neweq;    }   }  },,,e.countdown = 0;,,,,e.countdown = 7;,,donothing();,
Whisp@F,Do [fire]<d6> damage[;]|inflict [fire]burn on 6[;]|inflict [weaken]weaken on 5,2,var swapto = ~Whisp@W~;  var myelement = ~fire~;  var otherelement = ~weaken~;  attack(d|myelement);  sfxdamage(target|d);    if(d == 6) {   inflict(myelement);    sfx(~_~ + myelement|~~|0.2);  } if(d == 5) {   sfx(~_~ + otherelement|~~|0.2);   inflict(otherelement);   if(getstatusself(FURY) < 1 && self.layout != ~DECK~) {    var eqtoreplace = ~~;    var onscreenreplace = false;    for(eq in self.equipment) {     /* determine if e is a copy of an equipment that is multiuse or had re-equip used on it; and if it is; store the original variable as eqtoreplace and enable the flag that tells us we're replacing an item already on screen. there's probably an easier way to do this but idk */     if(     e.name == eq.name &&      e.namemodifier == eq.namemodifier &&      (eq.x + 100) >= e.x &&      (eq.x - 100) <= e.x &&      eq != e) {       eqtoreplace = eq; onscreenreplace = true; break;     }    }    if(onscreenreplace) {     var neweq = new elements.Equipment(swapto);     neweq.x = eqtoreplace.x;     neweq.y = eqtoreplace.y;     neweq.row = eqtoreplace.row;     neweq.column = eqtoreplace.column;     if(self.equipment.indexOf(eqtoreplace) != -1) { /*dumb safeguard*/      self.equipment[self.equipment.indexOf(eqtoreplace)] = neweq; /*i don't know why this is necessary but it is; you're just not allowed to refer to equipment through variables when overwriting it with another equipment*/      neweq.animate(~flashandshake~); /*also two variables can't point to the same equipment i guess; doing eqtoreplace.animate(~flashandshake~) has no effect*/     }    } else {     var neweq = new elements.Equipment(swapto);     neweq.column = e.column;     neweq.row = e.row;     neweq.x = -9999;     neweq.y = -9999;     neweq.show = false;     neweq.availablethisturn = false;     if(self.equipment.indexOf(e) != -1) { /*dumb safeguard*/      self.equipment[self.equipment.indexOf(e)] = neweq;     }    }   }  },Hellfire,NORMAL,,RED,change_power,change_power,,none,0,NO,NO,,,var swapto = ~Whisp@W~;  var myelement = ~fire~;  var otherelement = ~weaken~;      if(d == 6) {   donothing();  } if(d == 5) {    if(getstatusself(FURY) < 1 && self.layout != ~DECK~) {    sfx(~_~ + otherelement);  var eqtoreplace = ~~;    var onscreenreplace = false;    for(eq in self.equipment) {     /* determine if e is a copy of an equipment that is multiuse or had re-equip used on it; and if it is; store the original variable as eqtoreplace and enable the flag that tells us we're replacing an item already on screen. there's probably an easier way to do this but idk */     if(     e.name == eq.name &&      e.namemodifier == eq.namemodifier &&      (eq.x + 100) >= e.x &&      (eq.x - 100) <= e.x &&      eq != e) {       eqtoreplace = eq; onscreenreplace = true; break;     }    }    if(onscreenreplace) {     var neweq = new elements.Equipment(swapto);     neweq.x = eqtoreplace.x;     neweq.y = eqtoreplace.y;     neweq.row = eqtoreplace.row;     neweq.column = eqtoreplace.column;     if(self.equipment.indexOf(eqtoreplace) != -1) { /*dumb safeguard*/      self.equipment[self.equipment.indexOf(eqtoreplace)] = neweq; /*i don't know why this is necessary but it is; you're just not allowed to refer to equipment through variables when overwriting it with another equipment*/      neweq.animate(~flashandshake~); /*also two variables can't point to the same equipment i guess; doing eqtoreplace.animate(~flashandshake~) has no effect*/     }    } else {     var neweq = new elements.Equipment(swapto);     neweq.column = e.column;     neweq.row = e.row;     neweq.x = -9999;     neweq.y = -9999;     neweq.show = false;     neweq.availablethisturn = false;     if(self.equipment.indexOf(e) != -1) { /*dumb safeguard*/      self.equipment[self.equipment.indexOf(e)] = neweq;     }    }   }  },,,e.countdown = 0;,,,,e.countdown = 7;,,donothing();,
Whisp@W,Do [weaken]<d6> damage[;]|inflict [weaken]weaken on 6[;]|inflict [fire]burn on 5,2,var swapto = ~Whisp@F~;  var myelement = ~weaken~;  var otherelement = ~fire~;  attack(d|myelement);  sfxdamage(target|d);    if(d == 6) {   inflict(myelement);    sfx(~_~ + myelement|~~|0.2);  } if(d == 5) {   sfx(~_~ + otherelement|~~|0.2);   inflict(otherelement);   if(getstatusself(FURY) < 1 && self.layout != ~DECK~) {    var eqtoreplace = ~~;    var onscreenreplace = false;    for(eq in self.equipment) {     /* determine if e is a copy of an equipment that is multiuse or had re-equip used on it; and if it is; store the original variable as eqtoreplace and enable the flag that tells us we're replacing an item already on screen. there's probably an easier way to do this but idk */     if(     e.name == eq.name &&      e.namemodifier == eq.namemodifier &&      (eq.x + 100) >= e.x &&      (eq.x - 100) <= e.x &&      eq != e) {       eqtoreplace = eq; onscreenreplace = true; break;     }    }    if(onscreenreplace) {     var neweq = new elements.Equipment(swapto);     neweq.x = eqtoreplace.x;     neweq.y = eqtoreplace.y;     neweq.row = eqtoreplace.row;     neweq.column = eqtoreplace.column;     if(self.equipment.indexOf(eqtoreplace) != -1) { /*dumb safeguard*/      self.equipment[self.equipment.indexOf(eqtoreplace)] = neweq; /*i don't know why this is necessary but it is; you're just not allowed to refer to equipment through variables when overwriting it with another equipment*/      neweq.animate(~flashandshake~); /*also two variables can't point to the same equipment i guess; doing eqtoreplace.animate(~flashandshake~) has no effect*/     }    } else {     var neweq = new elements.Equipment(swapto);     neweq.column = e.column;     neweq.row = e.row;     neweq.x = -9999;     neweq.y = -9999;     neweq.show = false;     neweq.availablethisturn = false;     if(self.equipment.indexOf(e) != -1) { /*dumb safeguard*/      self.equipment[self.equipment.indexOf(e)] = neweq;     }    }   }  },Scream,NORMAL,,ORANGE,change_power,change_power,,none,0,NO,NO,,,var swapto = ~Whisp@F~;  var myelement = ~weaken~;  var otherelement = ~fire~;  if(d == 6) {   donothing();  } if(d == 5) {     if(getstatusself(FURY) < 1 && self.layout != ~DECK~) {  sfx(~_~ + otherelement);  var eqtoreplace = ~~;    var onscreenreplace = false;    for(eq in self.equipment) {     /* determine if e is a copy of an equipment that is multiuse or had re-equip used on it; and if it is; store the original variable as eqtoreplace and enable the flag that tells us we're replacing an item already on screen. there's probably an easier way to do this but idk */     if(     e.name == eq.name &&      e.namemodifier == eq.namemodifier &&      (eq.x + 100) >= e.x &&      (eq.x - 100) <= e.x &&      eq != e) {       eqtoreplace = eq; onscreenreplace = true; break;     }    }    if(onscreenreplace) {     var neweq = new elements.Equipment(swapto);     neweq.x = eqtoreplace.x;     neweq.y = eqtoreplace.y;     neweq.row = eqtoreplace.row;     neweq.column = eqtoreplace.column;     if(self.equipment.indexOf(eqtoreplace) != -1) { /*dumb safeguard*/      self.equipment[self.equipment.indexOf(eqtoreplace)] = neweq; /*i don't know why this is necessary but it is; you're just not allowed to refer to equipment through variables when overwriting it with another equipment*/      neweq.animate(~flashandshake~); /*also two variables can't point to the same equipment i guess; doing eqtoreplace.animate(~flashandshake~) has no effect*/     }    } else {     var neweq = new elements.Equipment(swapto);     neweq.column = e.column;     neweq.row = e.row;     neweq.x = -9999;     neweq.y = -9999;     neweq.show = false;     neweq.availablethisturn = false;     if(self.equipment.indexOf(e) != -1) { /*dumb safeguard*/      self.equipment[self.equipment.indexOf(e)] = neweq;     }    }   }  },,,e.countdown = 0;,,,,e.countdown = 7;,,donothing();,
Hamment@I,Do [ice]<d6> damage[;]|inflict [ice]freeze on 6[;]|inflict [shock]shock on 5,2,var swapto = ~Hamment@S~;  var myelement = ~ice~;  var otherelement = ~shock~;  attack(d|myelement);  sfxdamage(target|d);    if(d == 6) {   inflict(myelement);    sfx(~_~ + myelement|~~|0.2);  } if(d == 5) {   sfx(~_~ + otherelement|~~|0.2);   inflict(otherelement);   if(getstatusself(FURY) < 1 && self.layout != ~DECK~) {    var eqtoreplace = ~~;    var onscreenreplace = false;    for(eq in self.equipment) {     /* determine if e is a copy of an equipment that is multiuse or had re-equip used on it; and if it is; store the original variable as eqtoreplace and enable the flag that tells us we're replacing an item already on screen. there's probably an easier way to do this but idk */     if(     e.name == eq.name &&      e.namemodifier == eq.namemodifier &&      (eq.x + 100) >= e.x &&      (eq.x - 100) <= e.x &&      eq != e) {       eqtoreplace = eq; onscreenreplace = true; break;     }    }    if(onscreenreplace) {     var neweq = new elements.Equipment(swapto);     neweq.x = eqtoreplace.x;     neweq.y = eqtoreplace.y;     neweq.row = eqtoreplace.row;     neweq.column = eqtoreplace.column;     if(self.equipment.indexOf(eqtoreplace) != -1) { /*dumb safeguard*/      self.equipment[self.equipment.indexOf(eqtoreplace)] = neweq; /*i don't know why this is necessary but it is; you're just not allowed to refer to equipment through variables when overwriting it with another equipment*/      neweq.animate(~flashandshake~); /*also two variables can't point to the same equipment i guess; doing eqtoreplace.animate(~flashandshake~) has no effect*/     }    } else {     var neweq = new elements.Equipment(swapto);     neweq.column = e.column;     neweq.row = e.row;     neweq.x = -9999;     neweq.y = -9999;     neweq.show = false;     neweq.availablethisturn = false;     if(self.equipment.indexOf(e) != -1) { /*dumb safeguard*/      self.equipment[self.equipment.indexOf(e)] = neweq;     }    }   }  },Arctic Storm,NORMAL,,BRIGHTCYAN,change_power,change_power,,none,0,NO,NO,,,var swapto = ~Hamment@S~;  var myelement = ~ice~;  var otherelement = ~shock~;  if(d == 6) {   donothing();   } if(d == 5) {    if(getstatusself(FURY) < 1 && self.layout != ~DECK~) {  sfx(~_~ + otherelement);  var eqtoreplace = ~~;    var onscreenreplace = false;    for(eq in self.equipment) {     /* determine if e is a copy of an equipment that is multiuse or had re-equip used on it; and if it is; store the original variable as eqtoreplace and enable the flag that tells us we're replacing an item already on screen. there's probably an easier way to do this but idk */     if(     e.name == eq.name &&      e.namemodifier == eq.namemodifier &&      (eq.x + 100) >= e.x &&      (eq.x - 100) <= e.x &&      eq != e) {       eqtoreplace = eq; onscreenreplace = true; break;     }    }    if(onscreenreplace) {     var neweq = new elements.Equipment(swapto);     neweq.x = eqtoreplace.x;     neweq.y = eqtoreplace.y;     neweq.row = eqtoreplace.row;     neweq.column = eqtoreplace.column;     if(self.equipment.indexOf(eqtoreplace) != -1) { /*dumb safeguard*/      self.equipment[self.equipment.indexOf(eqtoreplace)] = neweq; /*i don't know why this is necessary but it is; you're just not allowed to refer to equipment through variables when overwriting it with another equipment*/      neweq.animate(~flashandshake~); /*also two variables can't point to the same equipment i guess; doing eqtoreplace.animate(~flashandshake~) has no effect*/     }    } else {     var neweq = new elements.Equipment(swapto);     neweq.column = e.column;     neweq.row = e.row;     neweq.x = -9999;     neweq.y = -9999;     neweq.show = false;     neweq.availablethisturn = false;     if(self.equipment.indexOf(e) != -1) { /*dumb safeguard*/      self.equipment[self.equipment.indexOf(e)] = neweq;     }    }   }  },,,e.countdown = 0;,,,,e.countdown = 7;,,donothing();,
Hamment@S,Do [shock]<d6> damage[;]|inflict [shock]shock on 6[;]|inflict [ice]freeze on 5,2,var swapto = ~Hamment@I~;  var myelement = ~shock~;  var otherelement = ~ice~;  attack(d|myelement);  sfxdamage(target|d);    if(d == 6) {   inflict(myelement);    sfx(~_~ + myelement|~~|0.2);  } if(d == 5) {   sfx(~_~ + otherelement|~~|0.2);   inflict(otherelement);   if(getstatusself(FURY) < 1 && self.layout != ~DECK~) {    var eqtoreplace = ~~;    var onscreenreplace = false;    for(eq in self.equipment) {     /* determine if e is a copy of an equipment that is multiuse or had re-equip used on it; and if it is; store the original variable as eqtoreplace and enable the flag that tells us we're replacing an item already on screen. there's probably an easier way to do this but idk */     if(     e.name == eq.name &&      e.namemodifier == eq.namemodifier &&      (eq.x + 100) >= e.x &&      (eq.x - 100) <= e.x &&      eq != e) {       eqtoreplace = eq; onscreenreplace = true; break;     }    }    if(onscreenreplace) {     var neweq = new elements.Equipment(swapto);     neweq.x = eqtoreplace.x;     neweq.y = eqtoreplace.y;     neweq.row = eqtoreplace.row;     neweq.column = eqtoreplace.column;     if(self.equipment.indexOf(eqtoreplace) != -1) { /*dumb safeguard*/      self.equipment[self.equipment.indexOf(eqtoreplace)] = neweq; /*i don't know why this is necessary but it is; you're just not allowed to refer to equipment through variables when overwriting it with another equipment*/      neweq.animate(~flashandshake~); /*also two variables can't point to the same equipment i guess; doing eqtoreplace.animate(~flashandshake~) has no effect*/     }    } else {     var neweq = new elements.Equipment(swapto);     neweq.column = e.column;     neweq.row = e.row;     neweq.x = -9999;     neweq.y = -9999;     neweq.show = false;     neweq.availablethisturn = false;     if(self.equipment.indexOf(e) != -1) { /*dumb safeguard*/      self.equipment[self.equipment.indexOf(e)] = neweq;     }    }   }  },Electrify,NORMAL,,YELLOW,change_power,change_power,,none,0,NO,NO,,,var swapto = ~Hamment@I~;  var myelement = ~shock~;  var otherelement = ~ice~;  if(d == 6) {   donothing();   } if(d == 5) {       if(getstatusself(FURY) < 1 && self.layout != ~DECK~) {  sfx(~_~ + otherelement);  var eqtoreplace = ~~;    var onscreenreplace = false;    for(eq in self.equipment) {     /* determine if e is a copy of an equipment that is multiuse or had re-equip used on it; and if it is; store the original variable as eqtoreplace and enable the flag that tells us we're replacing an item already on screen. there's probably an easier way to do this but idk */     if(     e.name == eq.name &&      e.namemodifier == eq.namemodifier &&      (eq.x + 100) >= e.x &&      (eq.x - 100) <= e.x &&      eq != e) {       eqtoreplace = eq; onscreenreplace = true; break;     }    }    if(onscreenreplace) {     var neweq = new elements.Equipment(swapto);     neweq.x = eqtoreplace.x;     neweq.y = eqtoreplace.y;     neweq.row = eqtoreplace.row;     neweq.column = eqtoreplace.column;     if(self.equipment.indexOf(eqtoreplace) != -1) { /*dumb safeguard*/      self.equipment[self.equipment.indexOf(eqtoreplace)] = neweq; /*i don't know why this is necessary but it is; you're just not allowed to refer to equipment through variables when overwriting it with another equipment*/      neweq.animate(~flashandshake~); /*also two variables can't point to the same equipment i guess; doing eqtoreplace.animate(~flashandshake~) has no effect*/     }    } else {     var neweq = new elements.Equipment(swapto);     neweq.column = e.column;     neweq.row = e.row;     neweq.x = -9999;     neweq.y = -9999;     neweq.show = false;     neweq.availablethisturn = false;     if(self.equipment.indexOf(e) != -1) { /*dumb safeguard*/      self.equipment[self.equipment.indexOf(e)] = neweq;     }    }   }  },,,e.countdown = 0;,,,,e.countdown = 7;,,donothing();,
Whisp@F_downgraded,Do [fire]<d6> damage[;]|inflict [fire]burn on 6,2,attack(d|FIRE); if(d == 6) { inflict(FIRE); sfx(~_fire~); } sfxdamage(target|d);,Hellfire,EVEN,,RED,,,,none,0,NO,NO,,,,,,,,,,,,donothing();,
Whisp@W_downgraded,Do [weaken]<d6> damage[;]|inflict [weaken]weaken on 6,2,attack(d|WEAKEN); if(d == 6) { inflict(WEAKEN); sfx(~_weaken~); } sfxdamage(target|d);,Scream,EVEN,,ORANGE,,,,none,0,NO,NO,,,,,,,,,,,,donothing();,
Hamment@I_downgraded,Do [ice]<d6> damage[;]|inflict [ice]freeze on 6,2,attack(d|ICE); if(d == 6) { inflict(ICE); sfx(~_ice~); } sfxdamage(target|d);,Arctic Storm,EVEN,,BRIGHTCYAN,,,,none,0,NO,NO,,,,,,,,,,,,donothing();,
Hamment@S_downgraded,Do [shock]<d6> damage[;]|inflict [shock]shock on 6,2,attack(d|SHOCK); if(d == 6) { inflict(SHOCK); sfx(~_shock~); } sfxdamage(target|d);,Electrify,EVEN,,YELLOW,,,,none,0,NO,NO,,,,,,,,,,,,donothing();,
Whisp@F_upgraded,Do [fire]<d6> damage[;]|inflict [fire]burn on 6[;]|inflict [weaken]weaken on 5,2,var swapto = ~Whisp@W+~;  var myelement = ~fire~;  var otherelement = ~weaken~;  attack(d|myelement);  sfxdamage(target|d);    if(d == 7) {   inflict(myelement);    sfx(~_~ + myelement|~~|0.2);  } if(d == 6) {   sfx(~_~ + otherelement|~~|0.2);   inflict(otherelement);   if(getstatusself(FURY) < 1 && self.layout != ~DECK~) {    var eqtoreplace = ~~;    var onscreenreplace = false;    for(eq in self.equipment) {     /* determine if e is a copy of an equipment that is multiuse or had re-equip used on it; and if it is; store the original variable as eqtoreplace and enable the flag that tells us we're replacing an item already on screen. there's probably an easier way to do this but idk */     if(     e.name == eq.name &&      e.namemodifier == eq.namemodifier &&      (eq.x + 100) >= e.x &&      (eq.x - 100) <= e.x &&      eq != e) {       eqtoreplace = eq; onscreenreplace = true; break;     }    }    if(onscreenreplace) {     var neweq = new elements.Equipment(swapto);     neweq.x = eqtoreplace.x;     neweq.y = eqtoreplace.y;     neweq.row = eqtoreplace.row;     neweq.column = eqtoreplace.column;     if(self.equipment.indexOf(eqtoreplace) != -1) { /*dumb safeguard*/      self.equipment[self.equipment.indexOf(eqtoreplace)] = neweq; /*i don't know why this is necessary but it is; you're just not allowed to refer to equipment through variables when overwriting it with another equipment*/      neweq.animate(~flashandshake~); /*also two variables can't point to the same equipment i guess; doing eqtoreplace.animate(~flashandshake~) has no effect*/     }    } else {     var neweq = new elements.Equipment(swapto);     neweq.column = e.column;     neweq.row = e.row;     neweq.x = -9999;     neweq.y = -9999;     neweq.show = false;     neweq.availablethisturn = false;     if(self.equipment.indexOf(e) != -1) { /*dumb safeguard*/      self.equipment[self.equipment.indexOf(e)] = neweq;     }    }   }  },Hellfire,NORMAL|FREE1,,RED,,,,none,0,NO,NO,,,var swapto = ~Whisp@W+~;  var myelement = ~fire~;  var otherelement = ~weaken~;     if(d == 7) {   donothing();  } if(d == 6) {     if(getstatusself(FURY) < 1 && self.layout != ~DECK~) {  sfx(~_~ + otherelement);   var eqtoreplace = ~~;    var onscreenreplace = false;    for(eq in self.equipment) {     /* determine if e is a copy of an equipment that is multiuse or had re-equip used on it; and if it is; store the original variable as eqtoreplace and enable the flag that tells us we're replacing an item already on screen. there's probably an easier way to do this but idk */     if(     e.name == eq.name &&      e.namemodifier == eq.namemodifier &&      (eq.x + 100) >= e.x &&      (eq.x - 100) <= e.x &&      eq != e) {       eqtoreplace = eq; onscreenreplace = true; break;     }    }    if(onscreenreplace) {     var neweq = new elements.Equipment(swapto);     neweq.x = eqtoreplace.x;     neweq.y = eqtoreplace.y;     neweq.row = eqtoreplace.row;     neweq.column = eqtoreplace.column;     if(self.equipment.indexOf(eqtoreplace) != -1) { /*dumb safeguard*/      self.equipment[self.equipment.indexOf(eqtoreplace)] = neweq; /*i don't know why this is necessary but it is; you're just not allowed to refer to equipment through variables when overwriting it with another equipment*/      neweq.animate(~flashandshake~); /*also two variables can't point to the same equipment i guess; doing eqtoreplace.animate(~flashandshake~) has no effect*/     }    } else {     var neweq = new elements.Equipment(swapto);     neweq.column = e.column;     neweq.row = e.row;     neweq.x = -9999;     neweq.y = -9999;     neweq.show = false;     neweq.availablethisturn = false;     if(self.equipment.indexOf(e) != -1) { /*dumb safeguard*/      self.equipment[self.equipment.indexOf(e)] = neweq;     }    }   }  },,,e.countdown = 0;,,,,e.countdown = 7;,,donothing();,
Whisp@W_upgraded,Do [weaken]<d6> damage[;]|inflict [weaken]weaken on 6[;]|inflict [fire]burn on 5,2,var swapto = ~Whisp@F+~;  var myelement = ~weaken~;  var otherelement = ~fire~;  attack(d|myelement);  sfxdamage(target|d);    if(d == 7) {   inflict(myelement);    sfx(~_~ + myelement|~~|0.2);  } if(d == 6) {   sfx(~_~ + otherelement|~~|0.2);   inflict(otherelement);   if(getstatusself(FURY) < 1 && self.layout != ~DECK~) {    var eqtoreplace = ~~;    var onscreenreplace = false;    for(eq in self.equipment) {     /* determine if e is a copy of an equipment that is multiuse or had re-equip used on it; and if it is; store the original variable as eqtoreplace and enable the flag that tells us we're replacing an item already on screen. there's probably an easier way to do this but idk */     if(     e.name == eq.name &&      e.namemodifier == eq.namemodifier &&      (eq.x + 100) >= e.x &&      (eq.x - 100) <= e.x &&      eq != e) {       eqtoreplace = eq; onscreenreplace = true; break;     }    }    if(onscreenreplace) {     var neweq = new elements.Equipment(swapto);     neweq.x = eqtoreplace.x;     neweq.y = eqtoreplace.y;     neweq.row = eqtoreplace.row;     neweq.column = eqtoreplace.column;     if(self.equipment.indexOf(eqtoreplace) != -1) { /*dumb safeguard*/      self.equipment[self.equipment.indexOf(eqtoreplace)] = neweq; /*i don't know why this is necessary but it is; you're just not allowed to refer to equipment through variables when overwriting it with another equipment*/      neweq.animate(~flashandshake~); /*also two variables can't point to the same equipment i guess; doing eqtoreplace.animate(~flashandshake~) has no effect*/     }    } else {     var neweq = new elements.Equipment(swapto);     neweq.column = e.column;     neweq.row = e.row;     neweq.x = -9999;     neweq.y = -9999;     neweq.show = false;     neweq.availablethisturn = false;     if(self.equipment.indexOf(e) != -1) { /*dumb safeguard*/      self.equipment[self.equipment.indexOf(e)] = neweq;     }    }   }  },Scream,NORMAL|FREE1,,ORANGE,,,,none,0,NO,NO,,,var swapto = ~Whisp@F+~;  var myelement = ~weaken~;  var otherelement = ~fire~;  attack(d|myelement);  sfxdamage(target|d);    if(d == 7) {   inflict(myelement);    sfx(~_~ + myelement|~~|0.2);  } if(d == 6) {   sfx(~_~ + otherelement|~~|0.2);   inflict(otherelement);   if(getstatusself(FURY) < 1 && self.layout != ~DECK~) {    var eqtoreplace = ~~;    var onscreenreplace = false;    for(eq in self.equipment) {     /* determine if e is a copy of an equipment that is multiuse or had re-equip used on it; and if it is; store the original variable as eqtoreplace and enable the flag that tells us we're replacing an item already on screen. there's probably an easier way to do this but idk */     if(     e.name == eq.name &&      e.namemodifier == eq.namemodifier &&      (eq.x + 100) >= e.x &&      (eq.x - 100) <= e.x &&      eq != e) {       eqtoreplace = eq; onscreenreplace = true; break;     }    }    if(onscreenreplace) {     var neweq = new elements.Equipment(swapto);     neweq.x = eqtoreplace.x;     neweq.y = eqtoreplace.y;     neweq.row = eqtoreplace.row;     neweq.column = eqtoreplace.column;     if(self.equipment.indexOf(eqtoreplace) != -1) { /*dumb safeguard*/      self.equipment[self.equipment.indexOf(eqtoreplace)] = neweq; /*i don't know why this is necessary but it is; you're just not allowed to refer to equipment through variables when overwriting it with another equipment*/      neweq.animate(~flashandshake~); /*also two variables can't point to the same equipment i guess; doing eqtoreplace.animate(~flashandshake~) has no effect*/     }    } else {     var neweq = new elements.Equipment(swapto);     neweq.column = e.column;     neweq.row = e.row;     neweq.x = -9999;     neweq.y = -9999;     neweq.show = false;     neweq.availablethisturn = false;     if(self.equipment.indexOf(e) != -1) { /*dumb safeguard*/      self.equipment[self.equipment.indexOf(e)] = neweq;     }    }   }  },,,e.countdown = 0;,,,,e.countdown = 7;,,donothing();,
Hamment@I_upgraded,Do [ice]<d6> damage[;]|inflict [ice]freeze on 6[;]|inflict [shock]shock on 5,2,var swapto = ~Hamment@S+~;  var myelement = ~ice~;  var otherelement = ~shock~;  attack(d|myelement);  sfxdamage(target|d);    if(d == 7) {   inflict(myelement);    sfx(~_~ + myelement|~~|0.2);  } if(d == 6) {   sfx(~_~ + otherelement|~~|0.2);   inflict(otherelement);   if(getstatusself(FURY) < 1 && self.layout != ~DECK~) {    var eqtoreplace = ~~;    var onscreenreplace = false;    for(eq in self.equipment) {     /* determine if e is a copy of an equipment that is multiuse or had re-equip used on it; and if it is; store the original variable as eqtoreplace and enable the flag that tells us we're replacing an item already on screen. there's probably an easier way to do this but idk */     if(     e.name == eq.name &&      e.namemodifier == eq.namemodifier &&      (eq.x + 100) >= e.x &&      (eq.x - 100) <= e.x &&      eq != e) {       eqtoreplace = eq; onscreenreplace = true; break;     }    }    if(onscreenreplace) {     var neweq = new elements.Equipment(swapto);     neweq.x = eqtoreplace.x;     neweq.y = eqtoreplace.y;     neweq.row = eqtoreplace.row;     neweq.column = eqtoreplace.column;     if(self.equipment.indexOf(eqtoreplace) != -1) { /*dumb safeguard*/      self.equipment[self.equipment.indexOf(eqtoreplace)] = neweq; /*i don't know why this is necessary but it is; you're just not allowed to refer to equipment through variables when overwriting it with another equipment*/      neweq.animate(~flashandshake~); /*also two variables can't point to the same equipment i guess; doing eqtoreplace.animate(~flashandshake~) has no effect*/     }    } else {     var neweq = new elements.Equipment(swapto);     neweq.column = e.column;     neweq.row = e.row;     neweq.x = -9999;     neweq.y = -9999;     neweq.show = false;     neweq.availablethisturn = false;     if(self.equipment.indexOf(e) != -1) { /*dumb safeguard*/      self.equipment[self.equipment.indexOf(e)] = neweq;     }    }   }  },Arctic Storm,NORMAL|FREE1,,BRIGHTCYAN,,,,none,0,NO,NO,,,var swapto = ~Hamment@S+~;  var myelement = ~ice~;  var otherelement = ~shock~;  attack(d|myelement);  sfxdamage(target|d);    if(d == 7) {   inflict(myelement);    sfx(~_~ + myelement|~~|0.2);  } if(d == 6) {   sfx(~_~ + otherelement|~~|0.2);   inflict(otherelement);   if(getstatusself(FURY) < 1 && self.layout != ~DECK~) {    var eqtoreplace = ~~;    var onscreenreplace = false;    for(eq in self.equipment) {     /* determine if e is a copy of an equipment that is multiuse or had re-equip used on it; and if it is; store the original variable as eqtoreplace and enable the flag that tells us we're replacing an item already on screen. there's probably an easier way to do this but idk */     if(     e.name == eq.name &&      e.namemodifier == eq.namemodifier &&      (eq.x + 100) >= e.x &&      (eq.x - 100) <= e.x &&      eq != e) {       eqtoreplace = eq; onscreenreplace = true; break;     }    }    if(onscreenreplace) {     var neweq = new elements.Equipment(swapto);     neweq.x = eqtoreplace.x;     neweq.y = eqtoreplace.y;     neweq.row = eqtoreplace.row;     neweq.column = eqtoreplace.column;     if(self.equipment.indexOf(eqtoreplace) != -1) { /*dumb safeguard*/      self.equipment[self.equipment.indexOf(eqtoreplace)] = neweq; /*i don't know why this is necessary but it is; you're just not allowed to refer to equipment through variables when overwriting it with another equipment*/      neweq.animate(~flashandshake~); /*also two variables can't point to the same equipment i guess; doing eqtoreplace.animate(~flashandshake~) has no effect*/     }    } else {     var neweq = new elements.Equipment(swapto);     neweq.column = e.column;     neweq.row = e.row;     neweq.x = -9999;     neweq.y = -9999;     neweq.show = false;     neweq.availablethisturn = false;     if(self.equipment.indexOf(e) != -1) { /*dumb safeguard*/      self.equipment[self.equipment.indexOf(e)] = neweq;     }    }   }  },,,e.countdown = 0;,,,,e.countdown = 7;,,donothing();,
Hamment@S_upgraded,Do [shock]<d6> damage[;]|inflict [shock]shock on 6[;]|inflict [ice]freeze on 5,2,var swapto = ~Hamment@I+~;  var myelement = ~shock~;  var otherelement = ~ice~;  attack(d|myelement);  sfxdamage(target|d);    if(d == 7) {   inflict(myelement);    sfx(~_~ + myelement|~~|0.2);  } if(d == 6) {   sfx(~_~ + otherelement|~~|0.2);   inflict(otherelement);   if(getstatusself(FURY) < 1 && self.layout != ~DECK~) {    var eqtoreplace = ~~;    var onscreenreplace = false;    for(eq in self.equipment) {     /* determine if e is a copy of an equipment that is multiuse or had re-equip used on it; and if it is; store the original variable as eqtoreplace and enable the flag that tells us we're replacing an item already on screen. there's probably an easier way to do this but idk */     if(     e.name == eq.name &&      e.namemodifier == eq.namemodifier &&      (eq.x + 100) >= e.x &&      (eq.x - 100) <= e.x &&      eq != e) {       eqtoreplace = eq; onscreenreplace = true; break;     }    }    if(onscreenreplace) {     var neweq = new elements.Equipment(swapto);     neweq.x = eqtoreplace.x;     neweq.y = eqtoreplace.y;     neweq.row = eqtoreplace.row;     neweq.column = eqtoreplace.column;     if(self.equipment.indexOf(eqtoreplace) != -1) { /*dumb safeguard*/      self.equipment[self.equipment.indexOf(eqtoreplace)] = neweq; /*i don't know why this is necessary but it is; you're just not allowed to refer to equipment through variables when overwriting it with another equipment*/      neweq.animate(~flashandshake~); /*also two variables can't point to the same equipment i guess; doing eqtoreplace.animate(~flashandshake~) has no effect*/     }    } else {     var neweq = new elements.Equipment(swapto);     neweq.column = e.column;     neweq.row = e.row;     neweq.x = -9999;     neweq.y = -9999;     neweq.show = false;     neweq.availablethisturn = false;     if(self.equipment.indexOf(e) != -1) { /*dumb safeguard*/      self.equipment[self.equipment.indexOf(e)] = neweq;     }    }   }  },Electrify,NORMAL|FREE1,,YELLOW,,,,none,0,NO,NO,,,var swapto = ~Hamment@I+~;  var myelement = ~shock~;  var otherelement = ~ice~;  attack(d|myelement);  sfxdamage(target|d);    if(d == 7) {   inflict(myelement);    sfx(~_~ + myelement|~~|0.2);  } if(d == 6) {   sfx(~_~ + otherelement|~~|0.2);   inflict(otherelement);   if(getstatusself(FURY) < 1 && self.layout != ~DECK~) {    var eqtoreplace = ~~;    var onscreenreplace = false;    for(eq in self.equipment) {     /* determine if e is a copy of an equipment that is multiuse or had re-equip used on it; and if it is; store the original variable as eqtoreplace and enable the flag that tells us we're replacing an item already on screen. there's probably an easier way to do this but idk */     if(     e.name == eq.name &&      e.namemodifier == eq.namemodifier &&      (eq.x + 100) >= e.x &&      (eq.x - 100) <= e.x &&      eq != e) {       eqtoreplace = eq; onscreenreplace = true; break;     }    }    if(onscreenreplace) {     var neweq = new elements.Equipment(swapto);     neweq.x = eqtoreplace.x;     neweq.y = eqtoreplace.y;     neweq.row = eqtoreplace.row;     neweq.column = eqtoreplace.column;     if(self.equipment.indexOf(eqtoreplace) != -1) { /*dumb safeguard*/      self.equipment[self.equipment.indexOf(eqtoreplace)] = neweq; /*i don't know why this is necessary but it is; you're just not allowed to refer to equipment through variables when overwriting it with another equipment*/      neweq.animate(~flashandshake~); /*also two variables can't point to the same equipment i guess; doing eqtoreplace.animate(~flashandshake~) has no effect*/     }    } else {     var neweq = new elements.Equipment(swapto);     neweq.column = e.column;     neweq.row = e.row;     neweq.x = -9999;     neweq.y = -9999;     neweq.show = false;     neweq.availablethisturn = false;     if(self.equipment.indexOf(e) != -1) { /*dumb safeguard*/      self.equipment[self.equipment.indexOf(e)] = neweq;     }    }   }  },,,e.countdown = 0;,,,,e.countdown = 7;,,donothing();,
Hunting Knife@large_upgraded,Do [sword]<d6> damage[;] flip slot|,1,var swapto = ~Hunting Knife@small+~;  attack(d);  sfxdamage(target|d);    if(getstatusself(FURY) < 1) {   var eqtoreplace = ~~;   var onscreenreplace = false;   for(eq in self.equipment) {    /* determine if e is a copy of an equipment that is multiuse or had re-equip used on it; and if it is; store the original variable as eqtoreplace and enable the flag that tells us we're replacing an item already on screen. there's probably an easier way to do this but idk */    if(    e.name == eq.name &&     e.namemodifier == eq.namemodifier &&     (eq.x + 100) >= e.x &&     (eq.x - 100) <= e.x &&     eq != e) {      eqtoreplace = eq; onscreenreplace = true; break;    }   }   if(onscreenreplace) {    var neweq = new elements.Equipment(swapto);    neweq.x = eqtoreplace.x;    neweq.y = eqtoreplace.y;    neweq.row = eqtoreplace.row;    neweq.column = eqtoreplace.column;    if(self.equipment.indexOf(eqtoreplace) != -1) { /*dumb safeguard*/     self.equipment[self.equipment.indexOf(eqtoreplace)] = neweq; /*i don't know why this is necessary but it is; you're just not allowed to refer to equipment through variables when overwriting it with another equipment*/     neweq.animate(~flashandshake~); /*also two variables can't point to the same equipment i guess; doing eqtoreplace.animate(~flashandshake~) has no effect*/    }   } else {    var neweq = new elements.Equipment(swapto);    neweq.column = e.column;    neweq.row = e.row;    neweq.x = -9999;    neweq.y = -9999;    neweq.show = false;    neweq.availablethisturn = false;    if(self.equipment.indexOf(e) != -1) { /*dumb safeguard*/     self.equipment[self.equipment.indexOf(e)] = neweq;    }   }  },Steal,MIN5,,RED,,,,none,-1,NO,NO,excludefromrandomlists,,var swapto = ~Hunting Knife@small+~;  attack(d);  sfxdamage(target|d);    if(getstatusself(FURY) < 1) {   var eqtoreplace = ~~;   var onscreenreplace = false;   for(eq in self.equipment) {    /* determine if e is a copy of an equipment that is multiuse or had re-equip used on it; and if it is; store the original variable as eqtoreplace and enable the flag that tells us we're replacing an item already on screen. there's probably an easier way to do this but idk */    if(    e.name == eq.name &&     e.namemodifier == eq.namemodifier &&     (eq.x + 100) >= e.x &&     (eq.x - 100) <= e.x &&     eq != e) {      eqtoreplace = eq; onscreenreplace = true; break;    }   }   if(onscreenreplace) {    var neweq = new elements.Equipment(swapto);    neweq.x = eqtoreplace.x;    neweq.y = eqtoreplace.y;    neweq.row = eqtoreplace.row;    neweq.column = eqtoreplace.column;    if(self.equipment.indexOf(eqtoreplace) != -1) { /*dumb safeguard*/     self.equipment[self.equipment.indexOf(eqtoreplace)] = neweq; /*i don't know why this is necessary but it is; you're just not allowed to refer to equipment through variables when overwriting it with another equipment*/     neweq.animate(~flashandshake~); /*also two variables can't point to the same equipment i guess; doing eqtoreplace.animate(~flashandshake~) has no effect*/    }   } else {    var neweq = new elements.Equipment(swapto);    neweq.column = e.column;    neweq.row = e.row;    neweq.x = -9999;    neweq.y = -9999;    neweq.show = false;    neweq.availablethisturn = false;    if(self.equipment.indexOf(e) != -1) { /*dumb safeguard*/     self.equipment[self.equipment.indexOf(e)] = neweq;    }   }  },,,e.countdown = 0;,,,,e.countdown = 7;,,donothing();,
Hunting Knife@small_upgraded,Do [sword]<d6> damage[;] flip slot|,1,var swapto = ~Hunting Knife@large+~;  attack(d);  sfxdamage(target|d);    if(getstatusself(FURY) < 1) {   var eqtoreplace = ~~;   var onscreenreplace = false;   for(eq in self.equipment) {    /* determine if e is a copy of an equipment that is multiuse or had re-equip used on it; and if it is; store the original variable as eqtoreplace and enable the flag that tells us we're replacing an item already on screen. there's probably an easier way to do this but idk */    if(    e.name == eq.name &&     e.namemodifier == eq.namemodifier &&     (eq.x + 100) >= e.x &&     (eq.x - 100) <= e.x &&     eq != e) {      eqtoreplace = eq; onscreenreplace = true; break;    }   }   if(onscreenreplace) {    var neweq = new elements.Equipment(swapto);    neweq.x = eqtoreplace.x;    neweq.y = eqtoreplace.y;    neweq.row = eqtoreplace.row;    neweq.column = eqtoreplace.column;    if(self.equipment.indexOf(eqtoreplace) != -1) { /*dumb safeguard*/     self.equipment[self.equipment.indexOf(eqtoreplace)] = neweq; /*i don't know why this is necessary but it is; you're just not allowed to refer to equipment through variables when overwriting it with another equipment*/     neweq.animate(~flashandshake~); /*also two variables can't point to the same equipment i guess; doing eqtoreplace.animate(~flashandshake~) has no effect*/    }   } else {    var neweq = new elements.Equipment(swapto);    neweq.column = e.column;    neweq.row = e.row;    neweq.x = -9999;    neweq.y = -9999;    neweq.show = false;    neweq.availablethisturn = false;    if(self.equipment.indexOf(e) != -1) { /*dumb safeguard*/     self.equipment[self.equipment.indexOf(e)] = neweq;    }   }  },Steal,MAX2,,RED,,,,none,-1,NO,NO,excludefromrandomlists,,var swapto = ~Hunting Knife@large+~;  attack(d);  sfxdamage(target|d);    if(getstatusself(FURY) < 1) {   var eqtoreplace = ~~;   var onscreenreplace = false;   for(eq in self.equipment) {    /* determine if e is a copy of an equipment that is multiuse or had re-equip used on it; and if it is; store the original variable as eqtoreplace and enable the flag that tells us we're replacing an item already on screen. there's probably an easier way to do this but idk */    if(    e.name == eq.name &&     e.namemodifier == eq.namemodifier &&     (eq.x + 100) >= e.x &&     (eq.x - 100) <= e.x &&     eq != e) {      eqtoreplace = eq; onscreenreplace = true; break;    }   }   if(onscreenreplace) {    var neweq = new elements.Equipment(swapto);    neweq.x = eqtoreplace.x;    neweq.y = eqtoreplace.y;    neweq.row = eqtoreplace.row;    neweq.column = eqtoreplace.column;    if(self.equipment.indexOf(eqtoreplace) != -1) { /*dumb safeguard*/     self.equipment[self.equipment.indexOf(eqtoreplace)] = neweq; /*i don't know why this is necessary but it is; you're just not allowed to refer to equipment through variables when overwriting it with another equipment*/     neweq.animate(~flashandshake~); /*also two variables can't point to the same equipment i guess; doing eqtoreplace.animate(~flashandshake~) has no effect*/    }   } else {    var neweq = new elements.Equipment(swapto);    neweq.column = e.column;    neweq.row = e.row;    neweq.x = -9999;    neweq.y = -9999;    neweq.show = false;    neweq.availablethisturn = false;    if(self.equipment.indexOf(e) != -1) { /*dumb safeguard*/     self.equipment[self.equipment.indexOf(e)] = neweq;    }   }  },,,e.countdown = 0;,,,,e.countdown = 7;,,donothing();,
Hunting Knife@large_downgraded,Do [sword]<d6> damage[;] flip slot|,2,var swapto = ~Hunting Knife@small~;  attack(d);  sfxdamage(target|d);    if(getstatusself(FURY) < 1) {   var eqtoreplace = ~~;   var onscreenreplace = false;   for(eq in self.equipment) {    /* determine if e is a copy of an equipment that is multiuse or had re-equip used on it; and if it is; store the original variable as eqtoreplace and enable the flag that tells us we're replacing an item already on screen. there's probably an easier way to do this but idk */    if(    e.name == eq.name &&     e.namemodifier == eq.namemodifier &&     (eq.x + 100) >= e.x &&     (eq.x - 100) <= e.x &&     eq != e) {      eqtoreplace = eq; onscreenreplace = true; break;    }   }   if(onscreenreplace) {    var neweq = new elements.Equipment(swapto);    neweq.x = eqtoreplace.x;    neweq.y = eqtoreplace.y;    neweq.row = eqtoreplace.row;    neweq.column = eqtoreplace.column;    if(self.equipment.indexOf(eqtoreplace) != -1) { /*dumb safeguard*/     self.equipment[self.equipment.indexOf(eqtoreplace)] = neweq; /*i don't know why this is necessary but it is; you're just not allowed to refer to equipment through variables when overwriting it with another equipment*/     neweq.downgrade(); neweq.animate(~flashandshake~); /*also two variables can't point to the same equipment i guess; doing eqtoreplace.animate(~flashandshake~) has no effect*/    }   } else {    var neweq = new elements.Equipment(swapto);    neweq.column = e.column;    neweq.row = e.row;    neweq.x = -9999;    neweq.y = -9999;    neweq.show = false;    neweq.availablethisturn = false;    if(self.equipment.indexOf(e) != -1) { /*dumb safeguard*/     self.equipment[self.equipment.indexOf(e)] = neweq; neweq.downgrade();   }   }  },Steal,REQUIRE6,,RED,,,,none,-1,NO,NO,excludefromrandomlists,,var swapto = ~Hunting Knife@small~;  attack(d);  sfxdamage(target|d);    if(getstatusself(FURY) < 1) {   var eqtoreplace = ~~;   var onscreenreplace = false;   for(eq in self.equipment) {    /* determine if e is a copy of an equipment that is multiuse or had re-equip used on it; and if it is; store the original variable as eqtoreplace and enable the flag that tells us we're replacing an item already on screen. there's probably an easier way to do this but idk */    if(    e.name == eq.name &&     e.namemodifier == eq.namemodifier &&     (eq.x + 100) >= e.x &&     (eq.x - 100) <= e.x &&     eq != e) {      eqtoreplace = eq; onscreenreplace = true; break;    }   }   if(onscreenreplace) {    var neweq = new elements.Equipment(swapto);    neweq.x = eqtoreplace.x;    neweq.y = eqtoreplace.y;    neweq.row = eqtoreplace.row;    neweq.column = eqtoreplace.column;    if(self.equipment.indexOf(eqtoreplace) != -1) { /*dumb safeguard*/     self.equipment[self.equipment.indexOf(eqtoreplace)] = neweq; /*i don't know why this is necessary but it is; you're just not allowed to refer to equipment through variables when overwriting it with another equipment*/     neweq.downgrade(); neweq.animate(~flashandshake~); /*also two variables can't point to the same equipment i guess; doing eqtoreplace.animate(~flashandshake~) has no effect*/    }   } else {    var neweq = new elements.Equipment(swapto);    neweq.column = e.column;    neweq.row = e.row;    neweq.x = -9999;    neweq.y = -9999;    neweq.show = false;    neweq.availablethisturn = false;    if(self.equipment.indexOf(e) != -1) { /*dumb safeguard*/     self.equipment[self.equipment.indexOf(e)] = neweq; neweq.downgrade();   }   }  },,,e.countdown = 0;,,,,e.countdown = 7;,,donothing();,
Hunting Knife@small_downgraded,Do [sword]<d6> damage[;] flip slot|,2,var swapto = ~Hunting Knife@large~;  attack(d);  sfxdamage(target|d);    if(getstatusself(FURY) < 1) {   var eqtoreplace = ~~;   var onscreenreplace = false;   for(eq in self.equipment) {    /* determine if e is a copy of an equipment that is multiuse or had re-equip used on it; and if it is; store the original variable as eqtoreplace and enable the flag that tells us we're replacing an item already on screen. there's probably an easier way to do this but idk */    if(    e.name == eq.name &&     e.namemodifier == eq.namemodifier &&     (eq.x + 100) >= e.x &&     (eq.x - 100) <= e.x &&     eq != e) {      eqtoreplace = eq; onscreenreplace = true; break;    }   }   if(onscreenreplace) {    var neweq = new elements.Equipment(swapto);    neweq.x = eqtoreplace.x;    neweq.y = eqtoreplace.y;    neweq.row = eqtoreplace.row;    neweq.column = eqtoreplace.column;    if(self.equipment.indexOf(eqtoreplace) != -1) { /*dumb safeguard*/     self.equipment[self.equipment.indexOf(eqtoreplace)] = neweq; /*i don't know why this is necessary but it is; you're just not allowed to refer to equipment through variables when overwriting it with another equipment*/     neweq.downgrade(); neweq.animate(~flashandshake~); /*also two variables can't point to the same equipment i guess; doing eqtoreplace.animate(~flashandshake~) has no effect*/    }   } else {    var neweq = new elements.Equipment(swapto);    neweq.column = e.column;    neweq.row = e.row;    neweq.x = -9999;    neweq.y = -9999;    neweq.show = false;    neweq.availablethisturn = false;    if(self.equipment.indexOf(e) != -1) { /*dumb safeguard*/     self.equipment[self.equipment.indexOf(e)] = neweq; neweq.downgrade();   }   }  },Steal,REQUIRE1,,RED,,,,none,-1,NO,NO,excludefromrandomlists,,var swapto = ~Hunting Knife@large~;  attack(d);  sfxdamage(target|d);    if(getstatusself(FURY) < 1) {   var eqtoreplace = ~~;   var onscreenreplace = false;   for(eq in self.equipment) {    /* determine if e is a copy of an equipment that is multiuse or had re-equip used on it; and if it is; store the original variable as eqtoreplace and enable the flag that tells us we're replacing an item already on screen. there's probably an easier way to do this but idk */    if(    e.name == eq.name &&     e.namemodifier == eq.namemodifier &&     (eq.x + 100) >= e.x &&     (eq.x - 100) <= e.x &&     eq != e) {      eqtoreplace = eq; onscreenreplace = true; break;    }   }   if(onscreenreplace) {    var neweq = new elements.Equipment(swapto);    neweq.x = eqtoreplace.x;    neweq.y = eqtoreplace.y;    neweq.row = eqtoreplace.row;    neweq.column = eqtoreplace.column;    if(self.equipment.indexOf(eqtoreplace) != -1) { /*dumb safeguard*/     self.equipment[self.equipment.indexOf(eqtoreplace)] = neweq; /*i don't know why this is necessary but it is; you're just not allowed to refer to equipment through variables when overwriting it with another equipment*/     neweq.downgrade(); neweq.animate(~flashandshake~); /*also two variables can't point to the same equipment i guess; doing eqtoreplace.animate(~flashandshake~) has no effect*/    }   } else {    var neweq = new elements.Equipment(swapto);    neweq.column = e.column;    neweq.row = e.row;    neweq.x = -9999;    neweq.y = -9999;    neweq.show = false;    neweq.availablethisturn = false;    if(self.equipment.indexOf(e) != -1) { /*dumb safeguard*/     self.equipment[self.equipment.indexOf(e)] = neweq; neweq.downgrade();   }   }  },,,e.countdown = 0;,,,,e.countdown = 7;,,donothing();,
Hunting Knife@large_weakened,Do [sword]<d6> damage[;] flip slot|,1,var swapto = ~Hunting Knife@small+~;  attack(d);  sfxdamage(target|d);    if(getstatusself(FURY) < 1) {   var eqtoreplace = ~~;   var onscreenreplace = false;   for(eq in self.equipment) {    /* determine if e is a copy of an equipment that is multiuse or had re-equip used on it; and if it is; store the original variable as eqtoreplace and enable the flag that tells us we're replacing an item already on screen. there's probably an easier way to do this but idk */    if(    e.name == eq.name &&     e.namemodifier == eq.namemodifier &&     (eq.x + 100) >= e.x &&     (eq.x - 100) <= e.x &&     eq != e) {      eqtoreplace = eq; onscreenreplace = true; break;    }   }   if(onscreenreplace) {    var neweq = new elements.Equipment(swapto);    neweq.x = eqtoreplace.x;    neweq.y = eqtoreplace.y;    neweq.row = eqtoreplace.row;    neweq.column = eqtoreplace.column;    if(self.equipment.indexOf(eqtoreplace) != -1) { /*dumb safeguard*/     self.equipment[self.equipment.indexOf(eqtoreplace)] = neweq; /*i don't know why this is necessary but it is; you're just not allowed to refer to equipment through variables when overwriting it with another equipment*/     neweq.downgrade(); neweq.animate(~flashandshake~); /*also two variables can't point to the same equipment i guess; doing eqtoreplace.animate(~flashandshake~) has no effect*/    }   } else {    var neweq = new elements.Equipment(swapto);    neweq.column = e.column;    neweq.row = e.row;    neweq.x = -9999;    neweq.y = -9999;    neweq.show = false;    neweq.availablethisturn = false;    if(self.equipment.indexOf(e) != -1) { /*dumb safeguard*/     self.equipment[self.equipment.indexOf(e)] = neweq; neweq.downgrade();   }   }  },Steal,REQUIRE6,,RED,,,,none,-1,NO,NO,excludefromrandomlists,,var swapto = ~Hunting Knife@small+~;  attack(d);  sfxdamage(target|d);    if(getstatusself(FURY) < 1) {   var eqtoreplace = ~~;   var onscreenreplace = false;   for(eq in self.equipment) {    /* determine if e is a copy of an equipment that is multiuse or had re-equip used on it; and if it is; store the original variable as eqtoreplace and enable the flag that tells us we're replacing an item already on screen. there's probably an easier way to do this but idk */    if(    e.name == eq.name &&     e.namemodifier == eq.namemodifier &&     (eq.x + 100) >= e.x &&     (eq.x - 100) <= e.x &&     eq != e) {      eqtoreplace = eq; onscreenreplace = true; break;    }   }   if(onscreenreplace) {    var neweq = new elements.Equipment(swapto);    neweq.x = eqtoreplace.x;    neweq.y = eqtoreplace.y;    neweq.row = eqtoreplace.row;    neweq.column = eqtoreplace.column;    if(self.equipment.indexOf(eqtoreplace) != -1) { /*dumb safeguard*/     self.equipment[self.equipment.indexOf(eqtoreplace)] = neweq; /*i don't know why this is necessary but it is; you're just not allowed to refer to equipment through variables when overwriting it with another equipment*/     neweq.downgrade(); neweq.animate(~flashandshake~); /*also two variables can't point to the same equipment i guess; doing eqtoreplace.animate(~flashandshake~) has no effect*/    }   } else {    var neweq = new elements.Equipment(swapto);    neweq.column = e.column;    neweq.row = e.row;    neweq.x = -9999;    neweq.y = -9999;    neweq.show = false;    neweq.availablethisturn = false;    if(self.equipment.indexOf(e) != -1) { /*dumb safeguard*/     self.equipment[self.equipment.indexOf(e)] = neweq; neweq.downgrade();   }   }  },,,e.countdown = 0;,,,,e.countdown = 7;,,donothing();,
Hunting Knife@small_weakened,Do [sword]<d6> damage[;] flip slot|,1,var swapto = ~Hunting Knife@large+~;  attack(d);  sfxdamage(target|d);    if(getstatusself(FURY) < 1) {   var eqtoreplace = ~~;   var onscreenreplace = false;   for(eq in self.equipment) {    /* determine if e is a copy of an equipment that is multiuse or had re-equip used on it; and if it is; store the original variable as eqtoreplace and enable the flag that tells us we're replacing an item already on screen. there's probably an easier way to do this but idk */    if(    e.name == eq.name &&     e.namemodifier == eq.namemodifier &&     (eq.x + 100) >= e.x &&     (eq.x - 100) <= e.x &&     eq != e) {      eqtoreplace = eq; onscreenreplace = true; break;    }   }   if(onscreenreplace) {    var neweq = new elements.Equipment(swapto);    neweq.x = eqtoreplace.x;    neweq.y = eqtoreplace.y;    neweq.row = eqtoreplace.row;    neweq.column = eqtoreplace.column;    if(self.equipment.indexOf(eqtoreplace) != -1) { /*dumb safeguard*/     self.equipment[self.equipment.indexOf(eqtoreplace)] = neweq; /*i don't know why this is necessary but it is; you're just not allowed to refer to equipment through variables when overwriting it with another equipment*/     neweq.downgrade(); neweq.animate(~flashandshake~); /*also two variables can't point to the same equipment i guess; doing eqtoreplace.animate(~flashandshake~) has no effect*/    }   } else {    var neweq = new elements.Equipment(swapto);    neweq.column = e.column;    neweq.row = e.row;    neweq.x = -9999;    neweq.y = -9999;    neweq.show = false;    neweq.availablethisturn = false;    if(self.equipment.indexOf(e) != -1) { /*dumb safeguard*/     self.equipment[self.equipment.indexOf(e)] = neweq; neweq.downgrade();   }   }  },Steal,REQUIRE1,,RED,,,,none,-1,NO,NO,excludefromrandomlists,,var swapto = ~Hunting Knife@large+~;  attack(d);  sfxdamage(target|d);    if(getstatusself(FURY) < 1) {   var eqtoreplace = ~~;   var onscreenreplace = false;   for(eq in self.equipment) {    /* determine if e is a copy of an equipment that is multiuse or had re-equip used on it; and if it is; store the original variable as eqtoreplace and enable the flag that tells us we're replacing an item already on screen. there's probably an easier way to do this but idk */    if(    e.name == eq.name &&     e.namemodifier == eq.namemodifier &&     (eq.x + 100) >= e.x &&     (eq.x - 100) <= e.x &&     eq != e) {      eqtoreplace = eq; onscreenreplace = true; break;    }   }   if(onscreenreplace) {    var neweq = new elements.Equipment(swapto);    neweq.x = eqtoreplace.x;    neweq.y = eqtoreplace.y;    neweq.row = eqtoreplace.row;    neweq.column = eqtoreplace.column;    if(self.equipment.indexOf(eqtoreplace) != -1) { /*dumb safeguard*/     self.equipment[self.equipment.indexOf(eqtoreplace)] = neweq; /*i don't know why this is necessary but it is; you're just not allowed to refer to equipment through variables when overwriting it with another equipment*/     neweq.downgrade(); neweq.animate(~flashandshake~); /*also two variables can't point to the same equipment i guess; doing eqtoreplace.animate(~flashandshake~) has no effect*/    }   } else {    var neweq = new elements.Equipment(swapto);    neweq.column = e.column;    neweq.row = e.row;    neweq.x = -9999;    neweq.y = -9999;    neweq.show = false;    neweq.availablethisturn = false;    if(self.equipment.indexOf(e) != -1) { /*dumb safeguard*/     self.equipment[self.equipment.indexOf(e)] = neweq; neweq.downgrade();   }   }  },,,e.countdown = 0;,,,,e.countdown = 7;,,donothing();,
Octobar_downgraded,Reduce countdowns by 8,1,boostcountdowns(actualdice[0].basevalue); boostcountdowns(actualdice[1].basevalue);,Turbo Boost,NORMAL|NORMAL,8,ORANGE,,,,none,0,YES,NO,,,,,,,,,,,,,
Metacrowbar_downgraded,Reduce a random countdown|by the last dice inserted,1,var poss = []; for(eq in self.equipment){if(eq.countdown > 0 && eq.ready && eq.availablethisturn){ poss.push(eq) } } if(self.stolencard){if(self.stolencard.countdown > 0 && self.stolencard.ready){poss.push(self.stolencard) } } if(poss.length > 0){ var r = rand(poss); givedice(e.dicehistory[e.dicehistory.length - 1].basevalue); r.assigndice(self.dicepool[self.dicepool.length - 1]); } /*of course its not copypasted from rope dart; are you kidding; i removed the semicolons after the brackets and let the skillcard be a valid target and everything. had no idea self.stolencard was a thing though; that might come in handy eventually*/,Accelerate,COUNTDOWN,8,GREEN,,,,none,0,YES,NO,,,,,,,,,,,,,
Nail Bar_downgraded,Boost countdowns by <d6>|(You lose [heart]2 hp each turn),1,boostcountdowns(actualdice[1].basevalue); boostcountdowns(actualdice[0].basevalue); /*insertion order being swapped from octobar is probably especially janky here; but its consistent darn it!*/,Turbo Boost,NORMAL|MAX3,,RED,,,,none,0,YES,NO,,,,,,,e.animate(~flashandshake~); pierceattackself(2); sfx(~_damage~);,,,,,,
Octobar_upgraded,Reduce countdowns by 10,1,boostcountdowns(2); boostcountdowns(actualdice[0].basevalue); boostcountdowns(actualdice[1].basevalue);,Turbo Boost,FREE2|NORMAL|NORMAL,8,ORANGE,,,,none,0,YES,NO,,,,,,,,,,,,,
Metacrowbar_upgraded,Reduce countdowns by|the last dice inserted,1,boostcountdowns(e.dicehistory[e.dicehistory.length - 1].basevalue);,Accelerate,COUNTDOWN,6,GREEN,,,,none,0,YES,NO,,,,,,,,,,,,,
Nail Bar_upgraded,Boost countdowns by <d6>|(You lose [heart]4 hp each turn)|,1,boostcountdowns(3); boostcountdowns(actualdice[0].basevalue);,Turbo Boost,NORMAL|FREE3,,RED,,,,none,2,YES,NO,,,,,,,e.animate(~flashandshake~); pierceattackself(4); sfx(~_damage~);,,,,,,
Metacrowbar_weakened,Reduce a random countdown|by the last dice inserted,1,var poss = []; for(eq in self.equipment){if(eq.countdown > 0 && eq.ready && eq.availablethisturn){ poss.push(eq) } } if(self.stolencard){if(self.stolencard.countdown > 0 && self.stolencard.ready){poss.push(self.stolencard) } } if(poss.length > 0){ var r = rand(poss); givedice(e.dicehistory[e.dicehistory.length - 1].basevalue); r.assigndice(self.dicepool[self.dicepool.length - 1]); },Accelerate,COUNTDOWN,6,GREEN,,,,none,0,YES,NO,,,,,,,,,,,,,
Bone Club,Do [sword]6 damage[;]|50% chance to [curse]Curse,2,attack(6); var odds = 50; if(getstatusself(~luck~) > 0 # getstatusself(~luck+~) > 0){ odds = 100; } if(chance(odds)) { inflict(CURSE); sfx(~_curse~); self.textparticle(~Success!~); },Dramatic Pause,COUNTDOWN,8,PURPLE,change_power,change_power,,_damage,0,NO,NO,,,,,,,,,,,,,
Bone Club_upgraded,Do [sword]6 damage[;]|if filled perfectly[;] [curse]Curse,2,attack(6); var sum = 0; for (i in 0...e.dicehistory.length) { sum = sum + e.dicehistory[i].basevalue; } if (sum == e.countdown) { inflict(CURSE); sfx(~_curse~); self.textparticle(~Success!~); } e.dicehistory = [];,Dramatic Pause,COUNTDOWN,8,PURPLE,,,,_damage,0,NO,NO,,,,,,,,,,,,,
Bone Club_downgraded,Do [sword]6 damage,2,attack(6); /*var sfxdone = false; var odds = 50; if(getstatusself(~luck~) > 0 # getstatusself(~luck+~) > 0){ odds = 100; } if(chance(odds)) { inflict(CURSE); sfx(~_curse~); sfxdone = true; } odds = 50; if(getstatusself(~luck~) > 0 # getstatusself(~luck+~) > 0){ odds = 0; } if(chance(odds)) { inflictself(CURSE); if(!sfxdone) { sfx(~_curse~); } } */,Dramatic Pause,COUNTDOWN,8,PURPLE,,,,_damage,0,NO,NO,,,,,,,,,,,,,
Table Flip,Reroll dice that aren't <d6>[;]|and return this dice,1,var c = 0; for (mydice in self.dicepool){ if (mydice.available() && mydice.basevalue != d){ mydice.animatereroll(rand([1|2|3|4|5|6])| self.screenposition()| c * 0.05); c++; } } givedice(d);,Rollout,NORMAL,,GREEN,change_power,change_power,,none,0,YES,NO,,1,,,,,,,,,,,
Table Flip_downgraded,Reroll dice that aren't <d6>[;]|and return this dice,1,var c = 0; for (mydice in self.dicepool){ if (mydice.available() && mydice.basevalue != d){ mydice.animatereroll(rand([1|2|3|4|5|6])| self.screenposition()| c * 0.05); c++; } } givedice(d);,Rollout,ODD,,GREEN,,,,none,0,YES,NO,,,,,,,,,,,,,
Table Flip_upgraded,Reroll dice that aren't <d6>[;]|and return this dice|,1,var c = 0; for (mydice in self.dicepool){ if (mydice.available() && mydice.basevalue != d){ mydice.animatereroll(rand([1|2|3|4|5|6])| self.screenposition()| c * 0.05); c++; } } givedice(d);,Rollout,NORMAL,,GREEN,,,,none,2,YES,NO,,,,,,,,,,,,,
Tragic Entrance,At start of fight[;] lose [heart]5|After fight[;] gain 2 max hp,1,,Still Standing,,,PURPLE,change_power,noeffect,,none,0,YES,NO,,,,,if(!flee) { self.maxhp +=2; self.hp += 2; },,if(turn == 1) { e.animate(~flashandshake~); e.changecolour(~GRAY~); pierceattackself(5); sfx(~_curse~); },,,,,,
Tragic Entrance_upgraded,At start of fight[;] lose [heart]3|After fight[;] gain 2 max hp,1,,Still Standing,,,PURPLE,,,,none,0,YES,NO,,,,,if(!flee) { self.maxhp +=2; self.hp += 2; },,if(turn == 1) { e.animate(~flashandshake~); e.changecolour(~GRAY~); pierceattackself(3); sfx(~_curse~); },,,,,,
Panacea,Restore [heal]ALL health[;]|destroy this immediately,1,attackself(self.hp - self.maxhp); sfx(~_survive~); trace(Spellbook); if(self.getskillcard().skillcard == ~witch~) { for(i in 1...7) if(Spellbook.spellname(i) == e.name) { Spellbook.erase(i); break; } } e.name = ~ncrsaysremoveme~; removeequipment(~ncrsaysremoveme~); if(self.layout == ~DECK~) { var deleteindex = -1; for(i in 0...Deck.getcards(~all~).length) if(Deck.getcards(~all~)[i].equipment == e) { deleteindex = i; break; } Deck.getcards(~all~)[deleteindex].delete(); },Healthy Eating,ODD,,GREEN,simplify,change_power,,jester_delete,0,YES,YES,cannotreuse,1,,,,,,,,,,e.preventdefault = true; e.maintainfury = true,
Panacea_downgraded,Restore [heal]20 health[;]|destroy this immediately,1,attackself(-20); sfx(~_survive~); trace(Spellbook); if(self.getskillcard().skillcard == ~witch~) { for(i in 1...7) if(Spellbook.spellname(i) == e.name) { Spellbook.erase(i); break; } } e.name = ~ncrsaysremoveme~; removeequipment(~ncrsaysremoveme~); if(self.layout == ~DECK~) { var deleteindex = -1; for(i in 0...Deck.getcards(~all~).length) if(Deck.getcards(~all~)[i].equipment == e) { deleteindex = i; break; } Deck.getcards(~all~)[deleteindex].delete(); },Healthy Eating,ODD,,GREEN,,,,jester_delete,0,YES,YES,cannotreuse,,,,,,,,,,,e.preventdefault = true; e.maintainfury = true,
Buzzsaw,Combine dice[;]|split total in 4,1,if(d > 3) { var dicetogive = []; var options = [1|2|3|4|5|6]; var t = d; while(t - 3 < options.length) { options.pop(); } var r1 = rand(options); while(chance((r1 * r1) * 2.5)) { r1 = rand(options); } t -= r1; while(t - 2 < options.length) { options.pop(); } var r2 = rand(options); while(chance((r2 * r2) * 1.6666)) { r2 = rand(options); } t -= r2; while(t - 1 < options.length) { options.pop(); } var r3 = rand(options); while(chance((r3 * r3) * 0.8333)) { r3 = rand(options); } t -= r3; while(t < options.length) { options.pop(); } var r4 = options[options.length - 1]; t -= r4; dicetogive = [r1|r2|r3|r4]; shuffle(dicetogive); givedice(dicetogive|~splitdice~); } else { givedice(actualdice); self.textparticle(~no~); },Razor Blade,MIN3|MIN3,,GREEN,change_power,change_power,,none,0,YES,NO,,,,,,,,,,,,,
Buzzsaw_upgraded,Combine dice[;]|split total in 6,1,if(d > 5) { var dicetogive = []; var options = [1|2|3|4|5|6]; var t = d; while(t - 5 < options.length) { options.pop(); } var r1 = rand(options); while(chance((r1 * r1) * 2.5)) { r1 = rand(options); } t -= r1; while(t - 4 < options.length) { options.pop(); } var r2 = rand(options); while(chance((r2 * r2) * 2)) { r2 = rand(options); } t -= r2; while(t - 3 < options.length) { options.pop(); } var r3 = rand(options); while(chance((r3 * r3) * 1.5)) { r3 = rand(options); } t -= r3; while(t - 2 < options.length) { options.pop(); } var r4 = rand(options); while(chance((r4 * r4) * 1)) { r4 = rand(options); } t -= r4; while(t - 1 < options.length) { options.pop(); } var r5 = rand(options); while(chance((r5 * r5) * 0.5)) { r5 = rand(options); } t -= r5; while(t < options.length) { options.pop(); } var r6 = options[options.length - 1]; t -= r6; dicetogive = [r1|r2|r3|r4|r5|r6]; shuffle(dicetogive); givedice(dicetogive); } else { givedice(actualdice|~splitdice~); self.textparticle(~too lazy 4 this~); },Razor Blade,MIN3|MIN3|MIN3,,GREEN,,,,none,0,YES,NO,,,,,,,,,,,,,
Buzzsaw_downgraded,Combine dice[;]|split total in 4,1,if(d > 3) { var dicetogive = []; var options = [1|2|3|4|5|6]; var t = d; while(t - 3 < options.length) { options.pop(); } var r1 = rand(options); while(chance((r1 * r1) * 2.5)) { r1 = rand(options); } t -= r1; while(t - 2 < options.length) { options.pop(); } var r2 = rand(options); while(chance((r2 * r2) * 1.6666)) { r2 = rand(options); } t -= r2; while(t - 1 < options.length) { options.pop(); } var r3 = rand(options); while(chance((r3 * r3) * 0.8333)) { r3 = rand(options); } t -= r3; while(t < options.length) { options.pop(); } var r4 = options[options.length - 1]; t -= r4; dicetogive = [r1|r2|r3|r4]; shuffle(dicetogive); givedice(dicetogive|~splitdice~); } else { givedice(actualdice); self.textparticle(~no~); },Razor Blade,MIN5|MIN5,,GREEN,,,,none,0,YES,NO,,,,,,,,,,,,,
Scraptula,Flip a dice upside down|(Always offered as scrap),1,givedice(7-d);,Parity Flip,RANGE25,,GRAY,simplify,change_power,,none,0,YES,NO,appearsforparts,,,,,,,,,,,,
Scraptula_downgraded,Flip a dice upside down|(Always offered as scrap),1,givedice(7-d);,Parity Flip,RANGE45,,GRAY,,,,none,0,YES,NO,appearsforparts,,,,,,,,,,,,
Hammer Up!,Add a Rubber Mallet to|your deck for this fight,2,if(self.layout != ~DECK~) { self.textparticle(~Uhh...~); } else { self.textparticle(~Hammer Up!~); var cardlist = Deck.getcards(~all~); for(mycard in cardlist) { if(mycard.equipment.name == ~Rubber Mallet~) { mycard.equipment.setvar(~alreadyhere~|true); } } addjestercard(~Rubber Mallet~); screenshake(); sfx(~openchest~); self.setvar(~hammers~|self.getvar(~hammers~) + 1); },Replicate,COUNTDOWN,5,RED,change_power,change_power,,hammer_up,0,YES,NO,excludefromrandomlists|jesteronly,,,self.setvar(~hammers~|0);,var cardlist = Deck.getcards(~all~); var ham = self.getvar(~hammers~); if(ham < 0) { while(ham < 0) { addjestercard(~Rubber Mallet~); ham++; } } if(ham > 0) { for(mycard in cardlist) { if(mycard.equipment.name == ~Rubber Mallet~ && mycard.equipment.equipmentcol == 2) { mycard.delete(); ham--; if(ham == 0) break; } } if(ham > 0) { for(mycard in cardlist) { if(mycard.equipment.name == ~Rubber Mallet~) { mycard.delete(); ham--; if(ham == 0) break; } } } },,,,,,,,
Hammer Up!_downgraded,Randomly either add or|remove a Rubber Mallet,2,if(self.layout != ~DECK~) { self.textparticle(~Uhh...~); } else { if(chance(50) # getstatusself(~luck~) > 0 # getstatusself(~luck+~) > 0) { self.textparticle(~Hammer Up!~); sfx(~hammer_up~); var cardlist = Deck.getcards(~all~); for(mycard in cardlist) { if(mycard.equipment.name == ~Rubber Mallet~) { mycard.equipment.setvar(~alreadyhere~|true); } } addjestercard(~Rubber Mallet~); screenshake(); sfx(~openchest~); self.setvar(~hammers~|self.getvar(~hammers~) + 1); Deck.getcards(~all~)[Deck.getcardlist(~all~).length - 1].equipment.changecolour(~RED~); } else { var hammerdeleted = false; var cardlist = Deck.getcards(~all~); for(mycard in cardlist) { if(mycard.equipment.name == ~Rubber Mallet~ && mycard.equipment.equipmentcol == 2) { self.textparticle(~Hammer Down...~); sfx(~hammer_down~); sfx(~jester_delete~); mycard.delete(); screenshake(); self.setvar(~hammers~|self.getvar(~hammers~) - 1); hammerdeleted = true; break; } } if(!hammerdeleted) { for(mycard in cardlist) { if(mycard.equipment.name == ~Rubber Mallet~) { self.textparticle(~Hammer Down...~); sfx(~hammer_down~); sfx(~jester_delete~); mycard.delete(); screenshake(); self.setvar(~hammers~|self.getvar(~hammers~) - 1); hammerdeleted = true; break; } } } if(!hammerdeleted) { self.textparticle(~No effect!~); } } },Replicate,COUNTDOWN,5,RED,,,,none,0,YES,NO,excludefromrandomlists|jesteronly,,,,,,,,,,,,
Hammer Up!_upgraded,Add a Rubber Mallet to|your deck for this fight,2,if(self.layout != ~DECK~) { self.textparticle(~Uhh...~); } else { self.textparticle(~Hammer Up!~); var cardlist = Deck.getcards(~all~); for(mycard in cardlist) { if(mycard.equipment.name == ~Rubber Mallet~) { mycard.equipment.setvar(~alreadyhere~|true); } } addjestercard(~Rubber Mallet~); screenshake(); sfx(~openchest~); self.setvar(~hammers~|self.getvar(~hammers~) + 1); },Replicate,ODD,,RED,,,,hammer_up,0,YES,NO,excludefromrandomlists|jesteronly,,,self.setvar(~hammers~|0);,var cardlist = Deck.getcards(~all~); var ham = self.getvar(~hammers~); if(ham < 0) { while(ham < 0) { addjestercard(~Rubber Mallet~); ham++; } } if(ham > 0) { for(mycard in cardlist) { if(mycard.equipment.name == ~Rubber Mallet~ && mycard.equipment.equipmentcol == 2) { mycard.delete(); ham--; if(ham == 0) break; } } if(ham > 0) { for(mycard in cardlist) { if(mycard.equipment.name == ~Rubber Mallet~) { mycard.delete(); ham--; if(ham == 0) break; } } } },,,,,,,,
Hammer Up!_weakened,Randomly either add or|remove a Rubber Mallet,2,if(self.layout != ~DECK~) { self.textparticle(~Uhh...~); } else { if(chance(50) # getstatusself(~luck~) > 0 # getstatusself(~luck+~) > 0) { self.textparticle(~Hammer Up!~); sfx(~hammer_up~); var cardlist = Deck.getcards(~all~); for(mycard in cardlist) { if(mycard.equipment.name == ~Rubber Mallet~) { mycard.equipment.setvar(~alreadyhere~|true); } } addjestercard(~Rubber Mallet~); screenshake(); sfx(~openchest~); self.setvar(~hammers~|self.getvar(~hammers~) + 1); Deck.getcards(~all~)[Deck.getcardlist(~all~).length - 1].equipment.changecolour(~RED~); } else { var hammerdeleted = false; var cardlist = Deck.getcards(~all~); for(mycard in cardlist) { if(mycard.equipment.name == ~Rubber Mallet~ && mycard.equipment.equipmentcol == 2) { self.textparticle(~Hammer Down...~); sfx(~hammer_down~); sfx(~jester_delete~); mycard.delete(); screenshake(); self.setvar(~hammers~|self.getvar(~hammers~) - 1); hammerdeleted = true; break; } } if(!hammerdeleted) { for(mycard in cardlist) { if(mycard.equipment.name == ~Rubber Mallet~) { self.textparticle(~Hammer Down...~); sfx(~hammer_down~); sfx(~jester_delete~); mycard.delete(); screenshake(); self.setvar(~hammers~|self.getvar(~hammers~) - 1); hammerdeleted = true; break; } } } if(!hammerdeleted) { self.textparticle(~No effect!~); } } },Replicate,ODD,,RED,,,,none,0,YES,NO,excludefromrandomlists|jesteronly,,,,,,,,,,,,
Dihydrogen Monoxide,Convert enemy's|[ice]freeze to [poison]poison,1,var g = getstatus(ICE); if(g > 0) { inflict(POISON|g); sfx(~_fire~); sfx(~_poison~); } else {self.textparticle(~No effect!~);} removestatus(ICE|ALL);,Overload,EVEN,,PURPLE,simplify,complicate,,none,0,NO,NO,,,,,,,,,,,,,
Carbon Monoxide,Convert enemy's|[fire]burn to [poison]poison,1,var g = getstatus(FIRE); if(g > 0) { inflict(POISON|g); sfx(~_fire~); sfx(~_poison~); } else {self.textparticle(~No effect!~);} removestatus(FIRE|ALL); /*whereas carbon monoxide is relatively harmless; dihydrogen monoxide is the most common cause of asphyxiation and comprises 90% of the ocean*/,Overload,EVEN,,PURPLE,simplify,complicate,,none,0,NO,NO,,,,,,,,,,,,,
Technology,Do [sword]<d6>[;] +1 dmg per turn|[80%][gray]''A little overbearing sometimes''[],1,attack(d);,Emulator,MAX4,,YELLOW,change_power,change_function,,_damage,0,NO,NO,,1,,,e.changeslots([e.getslots()[0]]);,var g = e.getslots(); if(g.length == 1 && turn > 1) { e.changeslots([g[0]|~FREE1~]); },,var g = e.getslots(); if(g.length == 1) { e.changeslots([g[0]|~FREE1~]); } else if(g.length == 2) { if(g[1] == ~FREE6~) { e.changeslots([g[0]|~FREE6~|~FREE1~]); } else { e.changeslots([g[0]|~FREE~ + ((g[1].split(~FREE~)[1] - 0) + 1)]); } } else if(g.length == 3) { if(g[2] != ~FREE6~) { e.changeslots([g[0]|~FREE6~|~FREE~ + ((g[2].split(~FREE~)[1] - 0) + 1)]); } },,,,,
Technology_upgraded,Do [sword]<d6>[;] +1 dmg per turn|[80%][gray]''A modern quasi-religion''[],1,attack(d);,Emulator,NORMAL,,YELLOW,,,,_damage,0,NO,NO,,,,,e.changeslots([e.getslots()[0]]);,var g = e.getslots(); if(g.length == 1 && turn > 1) { e.changeslots([g[0]|~FREE1~]); },,var g = e.getslots(); if(g.length == 1) { e.changeslots([g[0]|~FREE1~]); } else if(g.length == 2) { if(g[1] == ~FREE6~) { e.changeslots([g[0]|~FREE6~|~FREE1~]); } else { e.changeslots([g[0]|~FREE~ + ((g[1].split(~FREE~)[1] - 0) + 1)]); } } else if(g.length == 3) { if(g[2] != ~FREE6~) { e.changeslots([g[0]|~FREE6~|~FREE~ + ((g[2].split(~FREE~)[1] - 0) + 1)]); } },,,,,
Technology_downgraded,Do [sword]<d6>[;] +1 dmg per turn|[80%][gray]''Technology works.''[],1,attack(d);,Emulator,MAX4,,YELLOW,,,,_damage,0,NO,NO,,,,,e.changeslots([e.getslots()[0]]);,var g = e.getslots(); if(g.length == 1 && turn > 1) { e.changeslots([g[0]|~FREE1~]); },,var g = e.getslots(); if(g.length == 1) { e.changeslots([g[0]|~FREE1~]); } else if(g.length == 2) { if(g[1] == ~FREE6~) { e.changeslots([g[0]|~FREE6~|~FREE1~]); } else { e.changeslots([g[0]|~FREE~ + ((g[1].split(~FREE~)[1] - 0) + 1)]); } } else if(g.length == 3) { if(g[2] != ~FREE6~) { e.changeslots([g[0]|~FREE6~|~FREE~ + ((g[2].split(~FREE~)[1] - 0) + 1)]); } },,,,,
Chainsmoke,Each turn[;] [blind]blind and|[fire]burn you and enemy|+1 to each status each turn,1,,Science,,,RED,change_power,,,none,0,NO,NO,,,,,,inflictself(BLIND|turn); inflictself(FIRE|turn); inflict(BLIND|turn); inflict(FIRE|turn); e.animate(~flashandshake~); sfx(~_fire~); sfx(~_blind~);,,,,,,,
Chainsmoke_upgraded,Each turn[;] [blind]blind and|[fire]burn you and enemy|+2 to each status each turn,1,,Science,,,RED,,,,none,0,NO,NO,,,,,,inflictself(BLIND|turn * 2); inflictself(FIRE|turn * 2); inflict(BLIND|turn * 2); inflict(FIRE|turn * 2); e.animate(~flashandshake~); sfx(~_fire~); sfx(~_blind~);,,,,,,,
Black Ice,Each turn[;] [blind]blind and|[ice]freeze you and enemy|+1 to each status each turn,1,,Science,,,GRAY,change_power,,,none,0,NO,NO,,,,,,inflictself(BLIND|turn); inflictself(ICE|turn); inflict(BLIND|turn); inflict(ICE|turn); e.animate(~flashandshake~); sfx(~_ice~); sfx(~_blind~);,,,,,,,
Black Ice_upgraded,Each turn[;] [blind]blind and|[ice]freeze you and enemy|+2 to each status each turn,1,,Science,,,GRAY,,,,none,0,NO,NO,,,,,,inflictself(BLIND|turn * 2); inflictself(ICE|turn * 2); inflict(BLIND|turn * 2); inflict(ICE|turn * 2); e.animate(~flashandshake~); sfx(~_ice~); sfx(~_blind~);,,,,,,,
Kale Smoothie,[]+1 max hp if you win|[gray](once per battle),1,if(e.timesused > 0) { self.textparticle(~Already used!~); } else { sfx(~_thinghappens~); sfx(~_heal~); e.setvar(~kaleapply~|true); },Health Pack,DOUBLES|DOUBLES,,GREEN,change_power,complicate,,,0,YES,YES,,,,e.setvar(~kaleapply~|false);,if(flee != true && e.getvar(~kaleapply~) == true) { self.maxhp++; self.hp++; },,,,,,,e.preventdefault = true; e.maintainfury = true;,
Kale Smoothie_upgraded,[]+1 max hp if you win|[gray](once per battle),1,if(e.timesused > 0) { self.textparticle(~Already used!~); } else { sfx(~_thinghappens~); sfx(~_heal~); e.setvar(~kaleapply~|true); },Health Pack,EVEN,,GREEN,,,,,0,YES,YES,,,,e.setvar(~kaleapply~|false);,if(flee != true && e.getvar(~kaleapply~) == true) { self.maxhp++; self.hp++; },,,,,,,e.preventdefault = true; e.maintainfury = true;,
It's Been,Inflict [weaken]1 weaken if|target is not [blind]blind,1,if(!target.hasstatus(BLIND)) { inflict(WEAKEN); sfx(~_weaken~); } else { self.textparticle(~No effect!~); } /*cocked your head to th-*/,Scream,ODD,,ORANGE,simplify,complicate,,none,0,NO,NO,,,,,,,,,,,,,
Talent Contest,Fully charge limit break|[gray](once per battle),1,if(self.limitvalue != null && self.limitmax != null) { self.limitvalue = self.limitmax; },Hustle,COUNTDOWN,12,YELLOW,change_power,change_power,,_cure,0,YES,YES,,,,,,,,,,,,,
Talent Contest_downgraded,Charge limit break by [confuse]5|[gray](once per battle),1,if(self.limitvalue != null && self.limitmax != null) { self.limitvalue += 5; if(self.limitvalue > self.limitmax) self.limitvalue = self.limitmax; },Hustle,COUNTDOWN,12,YELLOW,,,,_cure,0,YES,YES,,,,,,,,,,,,,
Talent Contest_upgraded,Use limit break for free|[gray](once per battle),1,if(self.limitbreak != null) { new elements.Skill(self.limitbreak.name).execute(self|target); } /*oh no! this actually can break stuff if [insert extremely specific situation with cybernetics i can't be damned to remember]! how could i let such a horrible bug pass by! i need to add five billion lines of code stat*/,Hustle,COUNTDOWN,12,YELLOW,,,,none,0,YES,YES,,,,,,,,,,,,if(self.limitbreak.script.indexOf(~inflictself(FURY)~) != -1) { e.preventdefault = true; e.maintainfury = true; },
Velocity,Gain an extra turn[;] end turn|Countdown resets each turn|[gray](once per battle),1,inflictself(EXTRATURN); self.endturnnow();,Time Stop,COUNTDOWN,25,PINK,change_power,change_power,,none,0,YES,YES,,1,,,,e.countdown = 25;,,e.countdown = 25;,,,,e.preventdefault = true; e.maintainfury = true;,
Velocity_downgraded,Gain an extra turn[;] end turn|Countdown resets each turn|[gray](once per battle),1,inflictself(EXTRATURN); self.endturnnow();,Time Stop,COUNTDOWN,30,PINK,,,,none,0,YES,YES,,,,,,e.countdown = 25;,,e.countdown = 25;,,,,e.preventdefault = true; e.maintainfury = true;,
Velocity_upgraded,Gain an extra turn|Countdown resets each turn|[gray](once per battle),1,inflictself(EXTRATURN);,Time Stop,COUNTDOWN,25,PINK,,,,none,0,YES,YES,,,,,,e.countdown = 25;,,e.countdown = 25;,,,,e.preventdefault = true; e.maintainfury = true;,
Cybernetics,Replace your limit break with|your (first) current gadget|[gray](once per battle),1,if(self.getskillcard() != null && self.getskillcard().name == ~Inventor Gadgets~ && self.getskillcard().skills.length > 0) { self.setvar(~myoldlimit~|self.limitbreak.name); var b = self.getskillcard().skills[0].name; if(self.getvar(~myoldlimit~) == b) { self.textparticle(~No effect!~); } else { sfx(~openchest~); if(b == ~Gadget Roll~) { b = ~Limit Roll~; } if(b == ~Mirror Smash~) { b = ~Limit Mirror~; } if(b == ~Broken Gadget~) { b = ~Limit Broke~; } self.changelimitbreak(b); self.template.limit = b; self.template.alternatelimit = ~Limit Broke~; var j = self.limitbreak.script.split(~Gadget.changegadget(self| \~~ + self.limitbreak.name + ~\~| \~Broken Gadget~); if(j.length > 1) { self.limitbreak.script = j.join(~self.template.limit = \~Limit Broke\~; self.changelimitbreak(\~Limit Broke~); } var l = self.limitbreak.script.split(~Gadget.changegadget(self | \~~ + self.limitbreak.name + ~\~|~); if(l.length > 1) { self.limitbreak.script = l.join(~self.changelimitbreak(\~~); } var h = self.limitbreak.script.split(~var proximy = self.getskillcard().y + (self.getskillcard().height / 2) - 132; var proximx = self.getskillcard().x + (self.getskillcard().width / 2) - 110;~); if(h.length > 1) { self.limitbreak.script = h.join(~var proximy = self.y + 335; var proximx = self.x + 960;~); } } } else { self.textparticle(~No effect!~); },Less Fluff,REQUIRE3,,YELLOW,simplify,doublerequirements,,none,0,YES,YES,excludefromrandomlists|inventoronly,,,,,,,,,,,,
Glassblowing,[]+1 dice[;] permanently.|Destroy this on use,2,self.dice++; if(self.layout == ~DECK~) { var deleteindex = -1; for(i in 0...Deck.getcards(~all~).length) if(Deck.getcards(~all~)[i].equipment == e) { deleteindex = i; break; } Deck.getcards(~all~)[deleteindex].delete(); } else { e.name = ~ncrsaysremoveme~; removeequipment(~ncrsaysremoveme~); },Curved Mirror,COUNTDOWN,40,ORANGE,change_power,change_power,,permadice,0,YES,NO,cannotreuse,,,,,,,,,,,e.preventdefault = true; e.maintainfury = true;,
Glassblowing_upgraded,[]+1 dice[;] permanently.|Destroy this on use,2,self.dice++; if(self.layout == ~DECK~) { var deleteindex = -1; for(i in 0...Deck.getcards(~all~).length) if(Deck.getcards(~all~)[i].equipment == e) { deleteindex = i; break; } Deck.getcards(~all~)[deleteindex].delete(); } else { e.name = ~ncrsaysremoveme~; removeequipment(~ncrsaysremoveme~); },Curved Mirror,COUNTDOWN,32,ORANGE,,,,permadice,0,YES,NO,cannotreuse,,,,,,,,,,,e.preventdefault = true; e.maintainfury = true;,
Glassblowing_downgraded,Roll 6 new dice|Destroy this on use,2,givedice(rand([1|2|3|4|5|6])|rand([1|2|3|4|5|6])|rand([1|2|3|4|5|6])|rand([1|2|3|4|5|6])|rand([1|2|3|4|5|6])|rand([1|2|3|4|5|6])); if(self.layout == ~DECK~) { var deleteindex = -1; for(i in 0...Deck.getcards(~all~).length) if(Deck.getcards(~all~)[i].equipment == e) { deleteindex = i; break; } Deck.getcards(~all~)[deleteindex].delete(); } else { e.name = ~ncrsaysremoveme~; removeequipment(~ncrsaysremoveme~); },Curved Mirror,COUNTDOWN,40,ORANGE,,,,none,0,YES,NO,cannotreuse,,,,,,,,,,,e.preventdefault = true; e.maintainfury = true;,
Glassblowing_weakened,Roll 6 new dice|Destroy this on use,2,givedice(rand([1|2|3|4|5|6])|rand([1|2|3|4|5|6])|rand([1|2|3|4|5|6])|rand([1|2|3|4|5|6])|rand([1|2|3|4|5|6])|rand([1|2|3|4|5|6])); if(self.layout == ~DECK~) { var deleteindex = -1; for(i in 0...Deck.getcards(~all~).length) if(Deck.getcards(~all~)[i].equipment == e) { deleteindex = i; break; } Deck.getcards(~all~)[deleteindex].delete(); } else { e.name = ~ncrsaysremoveme~; removeequipment(~ncrsaysremoveme~); },Curved Mirror,COUNTDOWN,32,ORANGE,,,,none,0,YES,NO,cannotreuse,,,,,,,,,,,e.preventdefault = true; e.maintainfury = true;,
Scrap Lamp,Stash a <slotdoubles>[;] return both dice|(Always offered as scrap),1,inflictself(~stash~+d); inflictself(~lantern~); givedice([d|d]);,Light Switch,DOUBLES|DOUBLES,,GRAY,change_power,change_power,,_magic,0,YES,NO,appearsforparts,,,,,,,,,,,,
Scrap Lamp_upgraded,Stash higher dice[;] return both|(Always offered as scrap),1,inflictself(~lantern~); if(actualdice[0].basevalue > actualdice[1].basevalue) { inflictself(~stash~+(actualdice[0].basevalue)); } else { inflictself(~stash~+(actualdice[1].basevalue)); } givedice(actualdice);,Light Switch,NORMAL|NORMAL,8,GRAY,,,,_magic,0,YES,NO,appearsforparts,,,,,,,,,,,,
Scrap Lamp_downgraded,Stash a <slotdoubles>[;] return a dice|(Always offered as scrap),1,inflictself(~stash~+d); inflictself(~lantern~); givedice(d);,Light Switch,DOUBLES|DOUBLES,,GRAY,,,,_magic,0,YES,NO,appearsforparts,,,,,,,,,,,,
Scrapstick,Burn self[;] do [fire]3 dmg|(Always offered as scrap)|,1,var oldburn = 0; var oldaltburn = 0; if(self.status.length > 0) { for(stat in self.status) { if(stat.type == ~fire~) { oldburn = stat.value; } if(stat.type == ~alternate_fire~) { oldaltburn = stat.value; } } } inflictself(FIRE); sfxdamage(target|3); attack(3|FIRE); var inflictwhat = ~~; for(stat in self.status) { if(stat.type == ~fire~ && stat.value != oldburn) { inflictwhat = stat.type; } if(stat.type == ~alternate_fire~ && stat.value != oldaltburn) { inflictwhat = stat.type; } } if(inflictwhat != ~~) { var dicelist = []; for(mydice in self.dicepool) { if(mydice.available() && mydice.burn != true && mydice.alternateburn != true) { dicelist.push(mydice); } } if(dicelist.length > 0) { shuffle(dicelist); dicelist[0].animate(inflictwhat); } if(self.status.length > 0) { for(stat in self.status) { if(stat.type == inflictwhat) { stat.value--; } } } } /*-we walked in?*/,Blowtorch,EVEN,,GRAY,change_power,change_power,,_fire,-1,NO,NO,appearsforparts,,,,,,,,,,,,
Scrapstick_upgraded,Do [fire]3 damage|(Always offered as scrap)|,1,sfxdamage(target|3); attack(3|FIRE);,Blowtorch,EVEN,,GRAY,,,,_fire,-1,NO,NO,appearsforparts,,,,,,,,,,,,
Scrapstick_downgraded,Burn self twice[;] do [fire]3 dmg|(Always offered as scrap)|,1,var oldburn = 0; var oldaltburn = 0; if(self.status.length > 0) { for(stat in self.status) { if(stat.type == ~fire~) { oldburn = stat.value; } if(stat.type == ~alternate_fire~) { oldaltburn = stat.value; } } } inflictself(FIRE|2); sfxdamage(target|3); attack(3|FIRE); var inflictwhat = ~~; for(stat in self.status) { if(stat.type == ~fire~ && stat.value != oldburn) { inflictwhat = stat.type; } if(stat.type == ~alternate_fire~ && stat.value != oldaltburn) { inflictwhat = stat.type; } } if(inflictwhat != ~~) { var dicelist = []; for(mydice in self.dicepool) { if(mydice.available() && mydice.burn != true && mydice.alternateburn != true) { dicelist.push(mydice); } } if(dicelist.length > 0) { shuffle(dicelist); dicelist[0].animate(inflictwhat); } if(dicelist.length > 1) { dicelist[1].animate(inflictwhat|0.2); } if(self.status.length > 0) { for(stat in self.status) { if(stat.type == inflictwhat) { stat.value -= 2; } } } },Blowtorch,EVEN,,GRAY,,,,_fire,-1,NO,NO,appearsforparts,,,,,,,,,,,,
Scrapsies,In [jinx]<d6> turns[;] do [sword]<triple>|(Always offered as scrap),1,jinx(~Scrapsies~|~take [sword]%VAR% damage~|~Take [sword]%VAR% damage~|~attack(%VAR%); sfxdamage(null|%VAR%);~|target|self|d|(d * 3));  sfx(~_thinghappens~);,Drunken Boxing,MAX3,,GRAY,change_power,change_power,,none,0,NO,NO,appearsforparts,,,,,,,,,,,,
Scrapsies_upgraded,In [jinx]2 turns[;] do [sword]<triple>|(Always offered as scrap),1,jinx(~Scrapsies+~|~take [sword]%VAR% damage~|~Take [sword]%VAR% damage~|~attack(%VAR%); sfxdamage(null|%VAR%);~|target|self|2|(d * 3));  sfx(~_thinghappens~);,Drunken Boxing,MAX3,,GRAY,,,,none,0,NO,NO,appearsforparts,,,,,,,,,,,,
Scrapsies_downgraded,In [jinx]<d6> turns[;] do [sword]<double>|(Always offered as scrap),1,jinx(~Scrapsies-~|~take [sword]%VAR% damage~|~Take [sword]%VAR% damage~|~attack(%VAR%); sfxdamage(null|%VAR%);~|target|self|d|(d * 2));  sfx(~_thinghappens~);,Drunken Boxing,MAX3,,GRAY,,,,none,0,NO,NO,appearsforparts,,,,,,,,,,,,
Scrap Slingshot,Do [sword]<double>[;] get a new dice|(Always offered as scrap),1,attack(d * 2); givedice();,Gadget Roll,MAX2,,GRAY,change_power,change_power,,_damage,0,NO,NO,appearsforparts,,,,,,,,,,,,
Scrap Slingshot_upgraded,Do [sword]4[;] get a new dice|(Always offered as scrap),1,attack(4); givedice();,Gadget Roll,MAX2,,GRAY,,,,_damage,0,NO,NO,appearsforparts,,,,,,,,,,,,
Scrap Slingshot_downgraded,Get a new dice|(Always offered as scrap),1,givedice();,Gadget Roll,MAX2,,GRAY,,,,_damage,0,NO,NO,appearsforparts,,,,,,,,,,,,
Scrap Trap,Lock dice that roll <d6>|(Always offered as scrap),1,inflict(~counter_~ + d);,Copyright Strike,ODD,,GRAY,simplify,change_function,,_magic,0,NO,NO,appearsforparts,,,,,,,,,,,,
Scrap Trap_downgraded,Lock dice that roll 3|(Always offered as scrap),1,inflict(~counter_3~);,Copyright Strike,ODD,,GRAY,,,,_magic,0,NO,NO,appearsforparts,,,,,,,,,,,,
Spearhead,Do [sword]8[;] return the dice|[gray](once per battle),1,attack(8); givedice(d); sfxdamage(target|12); /*want this to be marked as a 'big damage' attack*/,Hustle,REQUIRE6,,RED,change_power,change_function,,none,0,NO,YES,,,,,,,,,,,,,
Spearhead_upgraded,Do [sword]16[;] return the dice|[gray](once per battle),1,attack(16); givedice(d); sfxdamage(target|16);,Hustle,REQUIRE6|REQUIRE6,,RED,,,,none,0,NO,YES,,,,,,,,,,,,,
Spearhead_downgraded,Do [sword]8 damage|[gray](once per battle),1,attack(8); sfxdamage(target|8);,Hustle,REQUIRE6,,RED,,,,none,0,NO,YES,,,,,,,,,,,,,
Sharp Straw,Do [sword]<d6> damage. On 1[;]|next use drains health,1,if(simulation) { attack(d); if(d == 1 && turn % 2 == 1) bonus(1000); if(turn % 2 == 0) bonus(d); } else { var dmgdesc = ~Do [sword]<d6> damage~; var draindesc = ~Drain [heart]<d6> health~; if(e.fulldescription.split(draindesc).length > 1) { drain(d); sfx(~_drain~); } else { attack(d); sfxdamage(target|d); } if(d != 1 && e.fulldescription.split(draindesc).length > 1) { e.animate(~flash~); e.fulldescription = e.fulldescription.split(draindesc).join(dmgdesc); } if(d == 1 && e.fulldescription.split(dmgdesc).length > 1) { e.animate(~flash~); e.fulldescription = e.fulldescription.split(dmgdesc).join(draindesc); } } /*whipcrack couldve been done a million times easier omg*/,Blood Sip,MAX4,,RED,increaserange,change_function,,none,0,NO,NO,,1,,,,,,,,,,,
Sharp Straw_downgraded,Do [sword]<d6> damage,1,attack(d); sfxdamage(target|d);,Blood Sip,MAX4,,RED,,,,none,0,NO,NO,,,,,,,,,,,,,
Illusion Spell,Deal [vanish]5 damage|Inflict [vanish]2 vanish,1,sfxdamage(target|5); attack(5|VANISH); inflict(~ncr_vanish~|2); /*fire spell*/,Strobe Light,REQUIRE2,,PINK,change_power,change_power,,_vanish,0,NO,NO,,,,,,,,,,,,,
Illusion Spell_upgraded,Deal [vanish]6 damage|Inflict [vanish]Vanish_ALL,1,sfxdamage(target|6); attack(6|VANISH); inflict(VANISH);,Strobe Light,REQUIRE2,,PINK,,,,_vanish,0,NO,NO,,,,,,,,,,,,,
Illusion Spell_downgraded,Deal [sword]5 damage,1,sfxdamage(target|5); attack(5);,Strobe Light,REQUIRE2,,PINK,,,,_vanish,0,NO,NO,,,,,,,,,,,,,
Energy Ball,Deal [vanish]<d6> damage|Inflict [vanish]1 vanish,1,sfxdamage(target|d); attack(d| VANISH); inflict(~ncr_vanish~); /*fireball*/,Strobe Light,EVEN,,PINK,change_power,change_power,,_vanish,0,NO,NO,,,,,,,,,,,,,
Energy Ball_upgraded,Deal [vanish]<d6> damage|Inflict [vanish]2 vanish,1,sfxdamage(target|d); attack(d| VANISH); inflict(~ncr_vanish~|2);,Strobe Light,EVEN,,PINK,,,,_vanish,0,NO,NO,,,,,,,,,,,,,
Energy Ball_downgraded,Deal [sword]<d6> damage,1,sfxdamage(target|d); attack(d);,Strobe Light,EVEN,,PINK,,,,_vanish,0,NO,NO,,,,,,,,,,,,,
Sleight of Hand@ncrmod,Do [sword]<d6> damage[;]|on 6[;] inflict [vanish]1 vanish,2,sfxdamage(target|d); attack(d); if(d == 6) { inflict(~ncr_vanish~); sfx(~_vanish~|~~|0.2);  } /*whip*/,Delude,NORMAL,,PURPLE,change_power,change_power,,_damage,0,NO,NO,,,,,,,,,,,,,
Sleight of Hand@ncrmod_upgraded,Do [sword]<d6> damage[;]|on 6[;] inflict [vanish]2 vanish,2,sfxdamage(target|d); attack(d); if(d == 6) { inflict(~ncr_vanish~|2); sfx(~_vanish~|~~|0.2); },Delude,NORMAL,,PURPLE,,,,_damage,0,NO,NO,,,,,,,,,,,,,
Sleight of Hand@ncrmod_downgraded,Do [sword]<d6> damage,2,sfxdamage(target|d); attack(d);,Delude,NORMAL,,PURPLE,,,,_damage,0,NO,NO,,,,,,,,,,,,,
Sceptre,Deal [vanish]6 damage|Inflict [vanish]1 vanish,2,sfxdamage(target|6); attack(6| VANISH); inflict(~ncr_vanish~); /*staff*/,Hadoken,COUNTDOWN,8,PINK,change_power,change_power,,_vanish,0,NO,NO,,,,,,,,,,,,,
Sceptre_downgraded,Deal [vanish]3 damage|Inflict [vanish]1 vanish,2,sfxdamage(target|3); attack(3| VANISH); inflict(~ncr_vanish~);,Hadoken,COUNTDOWN,8,PINK,,,,_vanish,0,NO,NO,,,,,,,,,,,,,
Sceptre_upgraded,Deal [vanish]8 damage|Inflict [vanish]1 vanish,2,sfxdamage(target|8); attack(8| VANISH); inflict(~ncr_vanish~);,Hadoken,COUNTDOWN,8,PINK,,,,_vanish,0,NO,NO,,,,,,,,,,,,,
Wicker Sceptre,Deal [vanish]9 damage|Inflict [vanish]2 vanish,2,sfxdamage(target|9); attack(9| VANISH); inflict(~ncr_vanish~|2); /*wicker staff*/,Hadoken,COUNTDOWN,12,PINK,threequartercountdown,change_power,,_vanish,0,NO,NO,,,,,,,,,,,,,
Wicker Sceptre_weakened,Deal [vanish]5 damage|Inflict [vanish]1 vanish,2,sfxdamage(target|5); attack(5| VANISH); inflict(~ncr_vanish~);,Hadoken,COUNTDOWN,9,PINK,,,,_vanish,0,NO,NO,,,,,,,,,,,,,
Wicker Sceptre_downgraded,Deal [vanish]5 damage|Inflict [vanish]1 vanish,2,sfxdamage(target|5); attack(5| VANISH); inflict(~ncr_vanish~);,Hadoken,COUNTDOWN,12,PINK,,,,_vanish,0,NO,NO,,,,,,,,,,,,,
Undying Flame,Burn all dice,2,inflict(FIRE|ALL); /*fool's fire*/,Hellfire,COUNTDOWN,12,RED,halfcountdown,change_function,,_fire,0,NO,NO,,,,,,,,,,,,,
Undying Flame_downgraded,Inflict [vanish]1 vanish,2,inflict(~ncr_vanish~);,Hellfire,COUNTDOWN,12,RED,,,,_vanish,0,NO,NO,,,,,,,,,,,,,
Undying Flame_weakened,Inflict [vanish]1 vanish,2,inflict(~ncr_vanish~);,Hellfire,COUNTDOWN,6,RED,,,,_vanish,0,NO,NO,,,,,,,,,,,,,
Idiot's Ice,Freeze all dice,2,inflict(ICE|ALL); /*fool's frost*/,Arctic Storm,COUNTDOWN,12,BRIGHTCYAN,halfcountdown,change_function,,_ice,0,NO,NO,,,,,,,,,,,,,
Idiot's Ice_downgraded,Inflict [vanish]1 vanish,2,inflict(~ncr_vanish~);,Arctic Storm,COUNTDOWN,12,BRIGHTCYAN,,,,_vanish,0,NO,NO,,,,,,,,,,,,,
Idiot's Ice_weakened,Inflict [vanish]1 vanish,2,inflict(~ncr_vanish~);,Arctic Storm,COUNTDOWN,6,BRIGHTCYAN,,,,_vanish,0,NO,NO,,,,,,,,,,,,,
Proton Pack,[vanish]<d6> dmg[;] +[vanish]2 vanish|[gray](once per battle),1,if(target.name == ~Wisp~) d = 999; sfxdamage(target|d); attack(d|VANISH); inflict(~ncr_vanish~|2); /*flamethrower*/,Hadoken,NORMAL|NORMAL,,PINK,change_power,complicate,,_vanish,0,NO,YES,,,,,,,,,,,,,
Proton Pack_upgraded,[vanish]<d6> dmg[;] +[vanish]4 vanish|[gray](once per battle),2,if(target.name == ~Wisp~) d = 999; sfxdamage(target|d); attack(d|VANISH); inflict(~ncr_vanish~|4);,Hadoken,NORMAL|NORMAL|NORMAL|NORMAL,,PINK,,,,_vanish,0,NO,YES,,,,,,,,,,,,,
Ouija Board,[vanish]<timesused> dmg[;] inflict [vanish]1 vanish|Add +[vanish]1 dmg each use,2,sfxdamage(target|e.timesused + 1); attack(e.timesused + 1| VANISH); inflict(~ncr_vanish~); bonus(1000); /*campfire. why is a girl scout carrying around a ouija board? i dunno. what do i look like; a child psychologist?*/,Hadoken,EVEN,,PINK,change_power,complicate,,_vanish,0,NO,NO,,,,,,,,,,,,,
Ouija Board_upgraded,[vanish]<timesused> dmg[;] inflict [vanish]2 vanish|Add +[vanish]1 dmg each use,2,sfxdamage(target|e.timesused + 1); attack(e.timesused + 1| VANISH); inflict(~ncr_vanish~|2); bonus(1000);,Hadoken,EVEN,,PINK,,,,_vanish,0,NO,NO,,,,,,,,,,,,,
Light Show,Do [vanish]6 damage for|each [vanish]1 vanish on enemy,2,if(getstatus(VANISH) > 0) { attack((target.dice + target.extradice + target.bonusdice) * 6); sfxdamage(target|(target.dice + target.extradice + target.bonusdice) * 6); } else { attack(getstatus(~ncr_vanish~) * 6 | VANISH); sfxdamage(target|getstatus(~ncr_vanish~) * 6); } /*fire blast. this behavior for vanish all is a little weird but much better than the previous behavior of ''do 999 damage since its unlimited vanish. lol''. this doesn't work used by an enemy against robot and it has vanish all inflicted; since it has 0 dice unless hom comes into play; but WHO CARES*/,Strobe Light,COUNTDOWN,4,PINK,change_power,change_power,,_vanish,0,NO,NO,,,,,,,,,,,,,
Light Show_upgraded,Do [vanish]7 damage for|each [vanish]1 vanish on enemy,2,if(getstatus(VANISH) > 0) { attack((target.dice + target.extradice + target.bonusdice) * 7); sfxdamage(target|(target.dice + target.extradice + target.bonusdice) * 7); } else { attack(getstatus(~ncr_vanish~) * 7 | VANISH); sfxdamage(target|getstatus(~ncr_vanish~) * 7); },Strobe Light,COUNTDOWN,4,PINK,,,,_vanish,0,NO,NO,,,,,,,,,,,,,
Light Show_downgraded,Do [vanish]4 damage for|each [vanish]1 vanish on enemy,2,if(getstatus(VANISH) > 0) { attack((target.dice + target.extradice + target.bonusdice) * 4); sfxdamage(target|(target.dice + target.extradice + target.bonusdice) * 4); } else { attack(getstatus(~ncr_vanish~) * 4 | VANISH); sfxdamage(target|getstatus(~ncr_vanish~) * 4); },Strobe Light,COUNTDOWN,4,PINK,,,,_vanish,0,NO,NO,,,,,,,,,,,,,
Shudder,Inflict [vanish]1 vanish[;]|return both dice,1,inflict(~ncr_vanish~); givedice([d| d]); /*ignite*/,Strobe Light,DOUBLES|DOUBLES,,PINK,change_power,change_power,,_vanish,0,NO,NO,,1,,,,,,,,,,,
Shudder_upgraded,Inflict [vanish]1 vanish[;]|return the dice,1,inflict(~ncr_vanish~); givedice(d);,Strobe Light,EVEN,,PINK,,,,_vanish,0,NO,NO,,,,,,,,,,,,,
Shudder_downgraded,Inflict [vanish]1 vanish,1,inflict(~ncr_vanish~);,Strobe Light,DOUBLES|DOUBLES,,PINK,,,,_vanish,0,NO,NO,,,,,,,,,,,,,
Smoke Machine,Each turn[;] [blind]blind and|[vanish]vanish you and enemy|+1 to each status each turn,1,/*chainsmoke*/,Science,,,PINK,change_power,,,none,0,NO,NO,,,,,,inflictself(BLIND|turn); inflictself(~ncr_vanish~|turn); inflict(BLIND|turn); inflict(~ncr_vanish~|turn); e.animate(~flashandshake~); sfx(~_blind~);,,,,,,,
Smoke Machine_upgraded,Each turn[;] [blind]blind and|[vanish]vanish you and enemy|+2 to each status each turn,1,,Science,,,PINK,,,,none,0,NO,NO,,,,,,inflictself(BLIND|turn * 2); inflictself(~ncr_vanish~|turn * 2); inflict(BLIND|turn * 2); inflict(~ncr_vanish~|turn * 2); e.animate(~flashandshake~); sfx(~_blind~);,,,,,,,
Mirage,Inflict [vanish]Vanish_ALL[],2,inflict(VANISH); bonus(1000); /*ice age. geddit!*/,Strobe Light,REQUIRE1|REQUIRE1,,PINK,change_power,change_power,,_vanish,0,NO,NO,,,,,,,,,,,,,
Mirage_upgraded,Inflict [vanish]Vanish_ALL[],2,inflict(VANISH); bonus(1000);,Strobe Light,DOUBLES|DOUBLES,,PINK,,,,_vanish,0,NO,NO,,,,,,,,,,,,,
Mirage_downgraded,Inflict [vanish]Vanish_ALL[],2,inflict(VANISH); bonus(1000);,Strobe Light,REQUIRE1|REQUIRE1|REQUIRE1|REQUIRE1,,PINK,,,,_vanish,0,NO,NO,,,,,,,,,,,,,
Hard Light,Do [vanish]<d6> damage[;]|+[vanish]3 if enemy has [vanish]vanish,2,if(getstatus(~ncr_vanish~) > 0 # getstatus(VANISH) > 0) { attack((d + 3) | VANISH); sfxdamage(target|d+3); } else { attack((d) | VANISH); sfxdamage(target|d); } /*flame shatter*/,Strobe Light,NORMAL,,PINK,change_power,change_power,,_vanish,0,NO,NO,,,,,,,,,,,,,
Hard Light_upgraded,Do [vanish]<d6> damage[;]|x2 if enemy has [vanish]vanish,2,if(getstatus(~ncr_vanish~) > 0 # getstatus(VANISH) > 0) { attack((d * 2) | VANISH); sfxdamage(target|d * 2); } else { attack((d) | VANISH); sfxdamage(target|d); },Strobe Light,NORMAL,,PINK,,,,_vanish,0,NO,NO,,,,,,,,,,,,,
Hard Light_downgraded,Do [vanish]<d6> damage[;]|+[vanish]3 if enemy has [vanish]vanish,2,if(getstatus(~ncr_vanish~) > 0 # getstatus(VANISH) > 0) { attack((d + 3) | VANISH); sfxdamage(target|d+3); } else { attack((d) | VANISH); sfxdamage(target|d); },Strobe Light,MAX3,,PINK,,,,_vanish,0,NO,NO,,,,,,,,,,,,,
Blacklight,Do [vanish]2 damage[;]|inflict [vanish]1 vanish,1,sfxdamage(target|2); attack(2|VANISH); inflict(~ncr_vanish~); /*lighter*/,Hadoken,COUNTDOWN,5,PINK,change_power,change_power,,_vanish,0,NO,NO,,1,,,,,,,,,,,
Blacklight_upgraded,Do [vanish]3 damage[;]|inflict [vanish]1 vanish,1,sfxdamage(target|3); attack(3|VANISH); inflict(~ncr_vanish~);,Hadoken,COUNTDOWN,5,PINK,,,,_vanish,0,NO,NO,,,,,,,,,,,,,
Blacklight_downgraded,Do [vanish]1 damage[;]|inflict [vanish]1 vanish,1,sfxdamage(target|1); attack(1|VANISH); inflict(~ncr_vanish~);,Hadoken,COUNTDOWN,5,PINK,,,,_vanish,0,NO,NO,,,,,,,,,,,,,
Ectoplasm,Do [vanish]<d6> damage[;]|on 4[;] inflict [vanish]1 vanish,2,sfxdamage(target|d); attack(d|VANISH); if(d == 4) { inflict(~ncr_vanish~); } /*molotov cocktail*/,Hadoken,NORMAL,,PINK,change_power,complicate,,_vanish,0,NO,NO,,,,,,,,,,,,,
Ectoplasm_upgraded,Do [vanish]<d6> damage[;]|on even[;] inflict [vanish]1 vanish,2,sfxdamage(target|d); attack(d|VANISH); if(d % 2 == 0) { inflict(~ncr_vanish~); },Hadoken,NORMAL,,PINK,,,,_vanish,0,NO,NO,,,,,,,,,,,,,
Spirit Sword,Do [vanish]<d6> dmg[;] +[vanish]2 vanish|(get [vanish]vanish[] each turn),1,sfxdamage(target|d); attack(d|VANISH);  inflict(~ncr_vanish~|2); /*flaming sword*/,Hadoken,MAX5|MAX5,,PINK,change_power,complicate,,_vanish,0,NO,NO,,1,,,,,e.animate(~flashandshake~); inflictself(~ncr_vanish~);,,,,,,
Spirit Sword_upgraded,Do [vanish]<d6> dmg[;] +[vanish]2 vanish|(get [vanish]vanish[] each turn),1,sfxdamage(target|d); attack(d|VANISH);  inflict(~ncr_vanish~|2);,Hadoken,NORMAL|NORMAL,,PINK,,,,_vanish,0,NO,NO,,,,,,,e.animate(~flashandshake~); inflictself(~ncr_vanish~);,,,,,,
Shocking Horror,Do [sword]<d6> damage[;] inflict|[vanish]Vanish and [shock]Shock,1,sfxdamage(target|d); attack(d); inflict(~ncr_vanish~); inflict(SHOCK| 1); sfx(~_vanish~|~~|0.2); sfx(~_shock~|~~|0.2); /*pitchfork. joke stolen from dr. lunatic; great video game*/,Hadoken,MAX4,,PINK,change_power,change_power,,_damage,0,NO,NO,,1,,,,,,,,,,,
Shocking Horror_upgraded,Do [sword]<d6> damage[;] inflict|[vanish]Vanish and [shock]Shock,1,sfxdamage(target|d); attack(d); inflict(~ncr_vanish~); inflict(SHOCK| 1); sfx(~_vanish~|~~|0.2); sfx(~_shock~|~~|0.2);,Hadoken,NORMAL,,PINK,,,,_damage,0,NO,NO,,,,,,,,,,,,,
Shocking Horror_downgraded,Do [sword]<d6> damage,1,sfxdamage(target|d); attack(d);,Hadoken,REQUIRE5,,PINK,,,,_damage,0,NO,NO,,,,,,,,,,,,,
Boo,In [jinx]6 turns[;]|do [vanish]20 damage|[80%][gray]''2SPOOKY4ME''[],2,/*this may very well be THE lamest fire-vanish swap but i find the notion of the enemy taking massive damage because you said 'boo' really funny for some reason*/ jinx(~Boo~|~take [vanish]%VAR% damage~|~Take [vanish]%VAR% damage~|~attack(%VAR%| VANISH); sfxdamage(null|%VAR%); sfx(\~_vanish\~|\~\~|0.2);~|target|self|6|20); sfx(~_thinghappens~); /*mercy*/,Hadoken,COUNTDOWN,5,PINK,change_power,change_power,,none,0,NO,NO,,,,,,,,,,,,,
Boo_upgraded,In [jinx]5 turns[;]|do [vanish]20 damage|[80%][gray]''2SPOOKY4ME''[],2,jinx(~Boo+~|~take [vanish]%VAR% damage~|~Take [vanish]%VAR% damage~|~attack(%VAR%| VANISH); sfxdamage(null|%VAR%); sfx(\~_vanish\~|\~\~|0.2);~|target|self|5|20); sfx(~_thinghappens~);,Hadoken,COUNTDOWN,5,PINK,,,,none,0,NO,NO,,,,,,,,,,,,,
Boo_downgraded,In [jinx]7 turns[;]|do [vanish]20 damage|[80%][gray]''2SPOOPY4ME''[],2,jinx(~Boo-~|~take [vanish]%VAR% damage~|~Take [vanish]%VAR% damage~|~attack(%VAR%| VANISH); sfxdamage(null|%VAR%); sfx(\~_vanish\~|\~\~|0.2);~|target|self|7|20); sfx(~_thinghappens~);,Hadoken,COUNTDOWN,5,PINK,,,,none,0,NO,NO,,,,,,,,,,,,,
Milky Potion,[vanish]8 dmg[;] inflict [vanish]Vanish_ALL[]|[gray](once per battle),2,sfxdamage(target|8); attack(8|VANISH); inflict(VANISH); /*fire potion. potions in nethack that summon ghosts are called 'milky potions'. so vanish is associated with summoning ghosts AND repelling ghosts. i don't get it. what the heck ncr*/,Delude,COUNTDOWN,8,PINK,threequartercountdown,change_power,,_vanish,0,NO,YES,,,,,,,,,,,,,
Milky Potion_downgraded,Do [vanish]4 damage|[gray](once per battle),2,sfxdamage(target|4); attack(4|VANISH);,Delude,COUNTDOWN,8,PINK,,,,_vanish,0,NO,YES,,,,,,,,,,,,,
Purify,Do [vanish]20 damage[;]|inflict [vanish]Vanish_ALL[],1,sfxdamage(target|20); attack(20| VANISH); inflict(VANISH); /*meteor. there are approximately five people in the known universe who will actually understand every reference contained in this mod; and unfortunately one of them is me*/,Strobe Light,COUNTDOWN,20,PINK,change_power,change_power,,_vanish,0,NO,NO,,2,,,,,,,,,,,
Purify_upgraded,Do [vanish]25 damage[;]|inflict [vanish]Vanish_ALL[],1,sfxdamage(target|25); attack(25| VANISH); inflict(VANISH);,Strobe Light,COUNTDOWN,20,PINK,,,,_vanish,0,NO,NO,,,,,,,,,,,,,
Purify_downgraded,Do [vanish]10 damage[;]|inflict [vanish]1 vanish,1,sfxdamage(target|10); attack(10| VANISH); inflict(~ncr_vanish~);,Strobe Light,COUNTDOWN,20,PINK,,,,_vanish,0,NO,NO,,,,,,,,,,,,,
Spectral Cauldron,Roll a new dice[;] receive [vanish]1|[gray](Reuseable),1,inflictself(~ncr_vanish~); givedice(); /*crucible*/,Random Roll,NORMAL,,PINK,change_power,change_power,,_vanish,4,YES,NO,,1,,,,,,,,,,,
Spectral Cauldron_upgraded,Roll 4 new dice[;] receive [vanish]4,1,inflictself(~ncr_vanish~|4); givedice([rand([1|2|3|4|5|6])|rand([1|2|3|4|5|6])|rand([1|2|3|4|5|6])|rand([1|2|3|4|5|6])]);,Random Roll,NORMAL,,PINK,,,,_vanish,0,YES,NO,,,,,,,,,,,,,
Spectral Cauldron_downgraded,Roll a new dice[;] receive [vanish]1,1,inflictself(~ncr_vanish~); givedice();,Random Roll,NORMAL,,PINK,,,,_vanish,0,YES,NO,,,,,,,,,,,,,
The Grave,Do [vanish]<d6> damage[;]|Inflict [vanish]5 vanish,1,sfxdamage(target|d); attack(d|VANISH); inflict(~ncr_vanish~|5); /*the ashes*/,Delude,REQUIRE5|FREE5,,PINK,change_power,change_power,,_vanish,0,NO,NO,,,,,,,,,,,,,
The Grave_upgraded,Do [vanish]<d6> damage[;]|Inflict [vanish]5 vanish,1,sfxdamage(target|d); attack(d|VANISH); inflict(~ncr_vanish~|5);,Delude,REQUIRE5|FREE6,,PINK,,,,_vanish,0,NO,NO,,,,,,,,,,,,,
The Grave_downgraded,Inflict [vanish]5 vanish,1,inflict(~ncr_vanish~|5);,Delude,REQUIRE5,,PINK,,,,_vanish,0,NO,NO,,,,,,,,,,,,,
St. Elmo's Fire,Deal [vanish]6 damage|Inflict [vanish]1 vanish,2,sfxdamage(target|6); attack(6| VANISH); inflict(~ncr_vanish~); /*cannon fire*/,Hadoken,COUNTDOWN,8,PINK,change_power,change_power,,_vanish,0,NO,NO,,,,,,,,,,,,,
St. Elmo's Fire_downgraded,Deal [vanish]3 damage|Inflict [vanish]1 vanish,2,sfxdamage(target|3); attack(3| VANISH); inflict(~ncr_vanish~;),Hadoken,COUNTDOWN,8,PINK,,,,_vanish,0,NO,NO,,,,,,,,,,,,,
St. Elmo's Fire_upgraded,Deal [vanish]8 damage|Inflict [vanish]1 vanish,2,sfxdamage(target|8); attack(8| VANISH); inflict(~ncr_vanish~);,Hadoken,COUNTDOWN,8,PINK,,,,_vanish,0,NO,NO,,,,,,,,,,,,,
Mist,Do [vanish]3[;] inflict [vanish]1 vanish|[gray](once per battle),2,sfxdamage(target|3); attack(3|VANISH); inflict(~ncr_vanish~); /*heat wave*/,Strobe Light,COUNTDOWN,5,PINK,change_power,change_power,,_vanish,0,NO,YES,,,,,,,,,,,,,
Mist_upgraded,Do [vanish]4[;] inflict [vanish]1 vanish|[gray](once per battle),2,sfxdamage(target|3); attack(4|VANISH); inflict(~ncr_vanish~);,Strobe Light,COUNTDOWN,5,PINK,,,,_vanish,0,NO,YES,,,,,,,,,,,,,
Mist_downgraded,Inflict [vanish]1 vanish|[gray](once per battle),2,inflict(~ncr_vanish~);,Strobe Light,COUNTDOWN,5,PINK,,,,_vanish,0,NO,YES,,,,,,,,,,,,,
Sheer Will,Deal [vanish]<d6> damage|Inflict [vanish]1 vanish,1,sfxdamage(target|d); attack(d|VANISH); inflict(~ncr_vanish~); bonus(1000); /*burning light*/,Delude,MIN4,,PINK,simplify,change_power,,_vanish,0,NO,NO,,1,,,,,,,,,,,
Sheer Will_downgraded,Deal [vanish]<d6> damage|Inflict [vanish]1 vanish,1,sfxdamage(target|d); attack(d|VANISH); inflict(~ncr_vanish~);,Delude,MAX3,,PINK,,,,_vanish,0,NO,NO,,,,,,,,,,,,,
Raw Energy,Do [vanish]<d6> damage[;]|Inflict [vanish]1 vanish,1,sfxdamage(target|d); attack(d|VANISH); inflict(~ncr_vanish~); /*inferno*/,Delude,NORMAL|NORMAL,,PINK,change_power,complicate,,_vanish,0,NO,NO,,1,,,,,,,,,,,
Raw Energy_upgraded,Do [vanish]<d6> damage[;]|Inflict [vanish]2 vanish,1,sfxdamage(target|d); attack(d|VANISH); inflict(~ncr_vanish~|2);,Delude,NORMAL|NORMAL,,PINK,,,,_vanish,0,NO,NO,,,,,,,,,,,,,
Heatless Fire,Do [vanish]4 damage|Inflict [vanish]1 vanish,2,sfxdamage(target|4); attack(4); inflict(~ncr_vanish~); sfx(~_vanish~|~~|0.2); /*fire breath. about a week ago (update: i have no idea when this was); during some bored venture through wikipedia i came across this quote from carl sagan: 'Now; what's the difference between an invisible; incorporeal; floating dragon who spits heatless fire and no dragon at all? If there's no way to disprove my contention; no conceivable experiment that would count against it; what does it mean to say that my dragon exists?'. then when i needed to rename this item because 'thick fumes' doesn't really fit the vanish theme; i remembered that quote. flames that look real but aren't are an established theme here already; e.g. fool's fire and st. elmo's fire. idk how it hurts you but it does i guess. it's allowed to make not much sense as long it's thematic and/or a reference (in this case both)*/,Strobe Light,COUNTDOWN,5,PINK,change_power,change_power,,_damage,0,NO,NO,,,,,,,,,,,,,
Heatless Fire_upgraded,Do [vanish]6 damage|Inflict [vanish]1 vanish,2,sfxdamage(target|6); attack(6); inflict(~ncr_vanish~); sfx(~_vanish~|~~|0.2);,Strobe Light,COUNTDOWN,5,PINK,,,,_damage,0,NO,NO,,,,,,,,,,,,,
Heatless Fire_downgraded,Do [vanish]4 damage,2,sfxdamage(target|4); attack(4);,Strobe Light,COUNTDOWN,5,PINK,,,,_damage,0,NO,NO,,,,,,,,,,,,,
Lightstick,Stash a [dice]<d6>[;] take this|out of play next turn|,1,inflictself(~stash~+d|1); inflictself(~illuminate~); /*matchstick swap; soul jar; was originally going to be called ''lightstick'' in case you're wondering what this is doing here*/,Light Switch,MIN4,,YELLOW,simplify,change_function,,_magic,-1,NO,NO,,2,,,,,,if(e.timesused > 0) { e.onceperbattle = true; e.usedthisbattle = true; },,,,,
Lightstick_downgraded,Stash a [dice]<d6>[;] take this|out of play next turn|,1,inflictself(~stash~+d|1); inflictself(~illuminate~);,Light Switch,MIN4,,YELLOW,,,,_magic,2,NO,NO,,,,,,,,if(e.timesused > 0) { e.onceperbattle = true; e.usedthisbattle = true; },,,,,
Timeghost,Inflict [vanish]<timesused> vanish[;]|+1 each turn,1,inflict(~ncr_vanish~|turn); /*pyrotechnIX*/,Strobe Light,NORMAL|NORMAL,9,PINK,change_power,change_power,,_vanish,0,NO,NO,,1,,,,,,e.timesused += 1;,,,,,
Timeghost_downgraded,Inflict [vanish]<timesused> vanish[;]|+1 each turn,1,inflict(~ncr_vanish~|turn);,Strobe Light,REQUIRE6|REQUIRE3,,PINK,,,,_vanish,0,NO,NO,,,,,,,,e.timesused += 1;,,,,,
Timeghost_upgraded,Inflict [vanish]<timesused> vanish[;]|+1 each turn,1,inflict(~ncr_vanish~|turn);,Strobe Light,COUNTDOWN,9,PINK,,,,_vanish,0,NO,NO,,,,,,,,e.timesused += 1;,,,,,
Soul Jar,Inflict [vanish]1 vanish|[gray](Reuseable),1,inflict(~ncr_vanish~); /*matchstick*/,Hadoken,EVEN,,PINK,change_requirements,removereusable,,_vanish,-1,NO,NO,,1,,,,,,,,,,,
Soul Jar_upgraded,Inflict [vanish]1 vanish|[gray](Reuseable),1,inflict(~ncr_vanish~);,Hadoken,NORMAL,,PINK,,,,_vanish,-1,NO,NO,,,,,,,,,,,,,
Energy Crystal,Deal [vanish]<d6> damage|Inflict [vanish]1 vanish,2,sfxdamage(target|d); attack(d|VANISH); inflict(~ncr_vanish~); /*fire crystal*/,Delude,EVEN,,PINK,simplify,complicate,,_vanish,0,NO,NO,,,,,,,,,,,,,
Explosive Overclocking,If you error[;] inflict [fire]2 burn,1,,Hellfire,,,RED,change_power,change_function,,none,0,NO,NO,errorimmune|robotonly,,,,,,e.setvar(~error~|0); e.changecolour(~RED~); e.addtag(~errorimmune~);,e.setvar(~error~|0); e.changecolour(~RED~); e.addtag(~errorimmune~);,if (self.roll_total >= self.roll_target && self.roll_jackpot <= 0 && e.getvar(~error~) == 0) { e.setvar(~error~|1); e.animate(~flashandshake~); e.changecolour(~GRAY~); sfx(~_fire~); inflict(FIRE|2); e.removetag(~errorimmune~); e.animate(~error~|0.05); },,,,
Explosive Overclocking_upgraded,If you error[;] inflict [fire]2 burn|If you jackpot[;] inflict [fire]1 burn,1,,Hellfire,,,RED,,,,none,0,NO,NO,errorimmune|robotonly,,,,,,e.setvar(~error~|0); e.changecolour(~RED~); e.addtag(~errorimmune~);,e.setvar(~error~|0); e.changecolour(~RED~); e.addtag(~errorimmune~);,if (self.roll_total >= self.roll_target && self.roll_jackpot <= 0 && e.getvar(~error~) == 0) { e.setvar(~error~|1); e.animate(~flashandshake~); e.changecolour(~GRAY~); sfx(~_fire~); inflict(FIRE|2); e.removetag(~errorimmune~); e.animate(~error~|0.05); } if(self.roll_jackpot > 0) { e.animate(~flashandshake~); e.changecolour(~GRAY~); sfx(~_fire~); inflict(FIRE); },,,,
Explosive Overclocking_downgraded,If you error[;] inflict [fire]1 burn,1,,Hellfire,,,RED,,,,none,0,NO,NO,errorimmune|robotonly,,,,,,e.setvar(~error~|0); e.changecolour(~RED~); e.addtag(~errorimmune~);,e.setvar(~error~|0); e.changecolour(~RED~); e.addtag(~errorimmune~);,if (self.roll_total >= self.roll_target && self.roll_jackpot <= 0 && e.getvar(~error~) == 0) { e.setvar(~error~|1); e.animate(~flashandshake~); e.changecolour(~GRAY~); inflict(FIRE|1); sfx(~_fire~); e.removetag(~errorimmune~); e.animate(~error~|0.05); },,,,
Bustin' Makes Me Feel Good,If you error[;] inflict [vanish]2 vanish,1,,Strobe Light,,,PINK,change_power,change_function,,none,0,NO,NO,errorimmune|robotonly,,,,,,e.setvar(~error~|0); e.changecolour(~PINK~); e.addtag(~errorimmune~);,e.setvar(~error~|0); e.changecolour(~PINK~); e.addtag(~errorimmune~);,if (self.roll_total >= self.roll_target && self.roll_jackpot <= 0 && e.getvar(~error~) == 0) { e.setvar(~error~|1); e.animate(~flashandshake~); e.changecolour(~GRAY~);  inflict(~ncr_vanish~|2); e.removetag(~errorimmune~); e.animate(~error~|0.05); sfx(~_vanish~); },,,,
Bustin' Makes Me Feel Good_upgraded,If you error[;] inflict [vanish]2 vanish|If you jackpot[;] inflict [vanish]1 vanish,1,,Strobe Light,,,PINK,,,,none,0,NO,NO,errorimmune|robotonly,,,,,,e.setvar(~error~|0); e.changecolour(~PINK~); e.addtag(~errorimmune~);,e.setvar(~error~|0); e.changecolour(~PINK~); e.addtag(~errorimmune~);,if (self.roll_total >= self.roll_target && self.roll_jackpot <= 0 && e.getvar(~error~) == 0) { e.setvar(~error~|1); e.animate(~flashandshake~); e.changecolour(~GRAY~);  inflict(~ncr_vanish~|2); e.removetag(~errorimmune~); e.animate(~error~|0.05); } if(self.roll_jackpot > 0) { e.animate(~flashandshake~); e.changecolour(~GRAY~); inflict(~ncr_vanish~);  sfx(~_vanish~); },,,,
Bustin' Makes Me Feel Good_downgraded,If you error[;] inflict [vanish]1 vanish,1,,Strobe Light,,,PINK,,,,none,0,NO,NO,errorimmune|robotonly,,,,,,e.setvar(~error~|0); e.changecolour(~PINK~); e.addtag(~errorimmune~);,e.setvar(~error~|0); e.changecolour(~PINK~); e.addtag(~errorimmune~);,if (self.roll_total >= self.roll_target && self.roll_jackpot <= 0 && e.getvar(~error~) == 0) { e.setvar(~error~|1); e.animate(~flashandshake~); e.changecolour(~GRAY~); inflict(~ncr_vanish~); e.removetag(~errorimmune~); e.animate(~error~|0.05); sfx(~_vanish~); },,,,
Cold Iron,If you error[;] inflict [ice]2 freeze,1,,Arctic Storm,,,BRIGHTCYAN,change_power,change_function,,none,0,NO,NO,errorimmune|robotonly,,,,,,e.setvar(~error~|0); e.changecolour(~BLUE~); e.addtag(~errorimmune~);,e.setvar(~error~|0); e.changecolour(~BLUE~); e.addtag(~errorimmune~);,if (self.roll_total >= self.roll_target && self.roll_jackpot <= 0 && e.getvar(~error~) == 0) { e.setvar(~error~|1); e.animate(~flashandshake~); e.changecolour(~GRAY~); sfx(~_ice~); inflict(ICE|2); e.removetag(~errorimmune~); e.animate(~error~|0.05); },,,,
Cold Iron_upgraded,If you error[;] inflict [ice]2 freeze|If you jackpot[;] inflict [ice]1 freeze,1,,Arctic Storm,,,BRIGHTCYAN,,,,none,0,NO,NO,errorimmune|robotonly,,,,,,e.setvar(~error~|0); e.changecolour(~BLUE~); e.addtag(~errorimmune~);,e.setvar(~error~|0); e.changecolour(~BLUE~); e.addtag(~errorimmune~);,if (self.roll_total >= self.roll_target && self.roll_jackpot <= 0 && e.getvar(~error~) == 0) { e.setvar(~error~|1); e.animate(~flashandshake~); e.changecolour(~GRAY~); sfx(~_ice~); inflict(ICE|2); e.removetag(~errorimmune~); e.animate(~error~|0.05); } if(self.roll_jackpot > 0) { e.animate(~flashandshake~); e.changecolour(~GRAY~); sfx(~_ice~); inflict(ICE); },,,,
Cold Iron_downgraded,If you error[;] inflict [ice]1 freeze,1,,Arctic Storm,,,BRIGHTCYAN,,,,none,0,NO,NO,errorimmune|robotonly,,,,,,e.setvar(~error~|0); e.changecolour(~BLUE~); e.addtag(~errorimmune~);,e.setvar(~error~|0); e.changecolour(~BLUE~); e.addtag(~errorimmune~);,if (self.roll_total >= self.roll_target && self.roll_jackpot <= 0 && e.getvar(~error~) == 0) { e.setvar(~error~|1); e.animate(~flashandshake~); e.changecolour(~GRAY~); sfx(~_ice~); inflict(ICE|1); e.removetag(~errorimmune~); e.animate(~error~|0.05); },,,,
Light Pillar,Do [vanish]<d6> damage|(Cost [mana]1[]: inflict vanish),1,sfxdamage(target|d); if(getstatusself(MANA) >= 1) { removestatusself(MANA|1); attack(d | VANISH); inflict(~ncr_vanish~); } else { attack(d | VANISH); }  /*sunburn*/,Delude,MIN4,,PINK,change_power,complicate,,_vanish,0,NO,NO,,1,,,,,,,,,,,
Light Pillar_upgraded,Do [vanish]<d6> damage|(Cost [mana]1[]: inflict vanish),1,sfxdamage(target|d); if(getstatusself(MANA) >= 1) { removestatusself(MANA|1); attack(d | VANISH); inflict(~ncr_vanish~); } else { attack(d | VANISH); } ,Delude,NORMAL,,PINK,,,,_vanish,0,NO,NO,,,,,,,,,,,,,
Magic Pipe,Inflict [vanish]1 vanish per|[weaken]1 weaken on enemy,1,inflict(~ncr_vanish~|getstatus(WEAKEN)); /*hell's bells*/,Strobe Light,COUNTDOWN,18,PINK,change_power,change_function,,_vanish,0,NO,NO,,,,,,,,,,,,,
Magic Pipe_upgraded,Inflict [vanish]1 vanish per|[weaken]1 weaken on enemy,1,inflict(~ncr_vanish~|getstatus(WEAKEN));,Strobe Light,COUNTDOWN,12,PINK,,,,_vanish,0,NO,NO,,,,,,,,,,,,,
Magic Pipe_downgraded,Inflict [vanish]1 vanish per|[weaken]2 weaken on enemy,1,var f = getstatus(WEAKEN) * 0.5; if (f % 1 != 0) { f = f - 0.5; } inflict(~ncr_vanish~|f); /*the f is for... france. because alias conrad coldwood is french. genius.*/,Strobe Light,COUNTDOWN,18,PINK,,,,_vanish,0,NO,NO,,,,,,,,,,,,,
Magic Pipe_weakened,Inflict [vanish]1 vanish per|[weaken]2 weaken on enemy,1,var f = getstatus(WEAKEN) * 0.5; if (f % 1 != 0) { f = f - 0.5; } inflict(~ncr_vanish~|f);,Strobe Light,COUNTDOWN,12,PINK,,,,_vanish,0,NO,NO,,,,,,,,,,,,,
Haunted Teapot,Self inflict [vanish]1 vanish|(Always offered as scrap),1,/*scrap kettle*/,Delude,,,GRAY,change_power,change_power,,none,0,NO,NO,appearsforparts,,,,,,e.animate(~flashandshake~); inflictself(~ncr_vanish~);,,,,,,
Haunted Teapot_upgraded,Roll an extra dice[;] get [vanish]1|(Always offered as scrap),1,,Delude,,,GRAY,,,,none,0,NO,NO,appearsforparts,,,,,,e.animate(~flashandshake~); givedice(); inflictself(~ncr_vanish~);,,,,,,
Haunted Teapot_downgraded,Self inflict [vanish]2 vanish|(Always offered as scrap),1,0,Delude,,,GRAY,,,,none,0,NO,NO,appearsforparts,,,,,,e.animate(~flashandshake~); inflictself(~ncr_vanish~|2);,,,,,,
Gaslighting,Do [sword]<d6> damage[;] on 6[;]|next use inflicts [vanish]2 vanish,2,e.setvar(~test~|true); var readystring = ~#~.substr(0|1) + ~[purple](ready)~; sfxdamage(target|d); attack(d); if(e.fulldescription.split(readystring).length > 1) { inflict(~ncr_vanish~|2); } if(d == 6 && e.fulldescription.split(readystring).length == 1) { trace(~hi 1~); e.fulldescription = e.fulldescription + readystring; for(eq in self.equipment) { if(e.getvar(~test~) == true && eq.getvar(~test~) == true && eq.ready) { trace(~hi 2~); if(eq.fulldescription.split(readystring).length == 1) { trace(~hi 3~); eq.fulldescription = eq.fulldescription + readystring; eq.animate(~flash~); } eq.setvar(~test~|false); break; } } } if(d != 6 && e.fulldescription.split(readystring).length > 1) { e.fulldescription = e.fulldescription.split(readystring)[0]; for(eq in self.equipment) { if(e.getvar(~test~) == true && eq.getvar(~test~) == true && eq.ready) { eq.fulldescription = eq.fulldescription.split(readystring)[0]; eq.animate(~flash~); eq.setvar(~test~|false); break; } } } e.setvar(~test~|false); /*whipcrack. has the same ''deceit'' theme as Sleight of Hand@ncrmod but much harsher*/,Strobe Light,NORMAL,,PURPLE,reducesize,change_function,,_damage,0,NO,NO,excludefromrandomlists,,,var readystring = ~#~.substr(0|1) + ~[purple](ready)~; if(e.fulldescription.split(readystring).length > 1) { e.fulldescription = e.fulldescription.split(readystring)[0]; },var readystring = ~#~.substr(0|1) + ~[purple](ready)~; if(e.fulldescription.split(readystring).length > 1) { e.fulldescription = e.fulldescription.split(readystring)[0]; },,,,,for(eq in self.equipment) { if(eq.name == e.name && eq.namemodifier == e.namemodifier && (eq.y + 10) >= e.y && (eq.y - 10) <= e.y && (eq.x + 10) >= e.x && (eq.x - 10) <= e.x) { eq.setvar(~test~|true); } },,,
Gaslighting_downgraded,Do [sword]<d6> damage,2,sfxdamage(target|d); attack(d);,Strobe Light,NORMAL,,PURPLE,,,,_damage,0,NO,NO,excludefromrandomlists,,,,,,,,,,,,
Gaslighting_weakened,Do [sword]<d6> damage,1,sfxdamage(target|d); attack(d);,Strobe Light,NORMAL,,PURPLE,,,,_damage,0,NO,NO,excludefromrandomlists,,,,,,,,,,,,
Gaslighting_deckupgrade,Do [sword]<d6> damage[;] on 4-6[;]|next use inflicts [vanish]2 vanish,2,e.setvar(~test~|true); var readystring = ~#~.substr(0|1) + ~[purple](ready)~; sfxdamage(target|d); attack(d); if(e.fulldescription.split(readystring).length > 1) { inflict(~ncr_vanish~|2); } if(d > 3 && e.fulldescription.split(readystring).length == 1) { trace(~hi 1~); e.fulldescription = e.fulldescription + readystring; for(eq in self.equipment) { if(e.getvar(~test~) == true && eq.getvar(~test~) == true && eq.ready) { trace(~hi 2~); if(eq.fulldescription.split(readystring).length == 1) { trace(~hi 3~); eq.fulldescription = eq.fulldescription + readystring; eq.animate(~flash~); } eq.setvar(~test~|false); break; } } } if(d < 4 && e.fulldescription.split(readystring).length > 1) { e.fulldescription = e.fulldescription.split(readystring)[0]; for(eq in self.equipment) { if(e.getvar(~test~) == true && eq.getvar(~test~) == true && eq.ready) { eq.fulldescription = eq.fulldescription.split(readystring)[0]; eq.animate(~flash~); eq.setvar(~test~|false); break; } } } e.setvar(~test~|false);,Strobe Light,NORMAL,,PURPLE,,,,_fire,0,NO,NO,excludefromrandomlists,,,var readystring = ~#~.substr(0|1) + ~[purple](ready)~; if(e.fulldescription.split(readystring).length > 1) { e.fulldescription = e.fulldescription.split(readystring)[0]; },var readystring = ~#~.substr(0|1) + ~[purple](ready)~; if(e.fulldescription.split(readystring).length > 1) { e.fulldescription = e.fulldescription.split(readystring)[0]; },,,,,for(eq in self.equipment) { if(eq.name == e.name && eq.namemodifier == e.namemodifier && (eq.y + 10) >= e.y && (eq.y - 10) <= e.y && (eq.x + 10) >= e.x && (eq.x - 10) <= e.x) { eq.setvar(~test~|true); } },,,
Long Con,Remove up to [vanish]1 from you|Inflict [vanish] equal to excess,1,/*heat pump. first this was named 'containment trap'; then i realized that would be a better name for vanish matchbox (at the time named 'invocation ritual' for some boring reason) and for some reason i thought spirit levels and heat pumps were totally mildly related somehow (uh; architecture?) and named this 'spirit level'. i realized jackeea already had an equipment named spirit level but i was like 'lol this is a better name anyway' but realized this was an even better name. it's not; but earlier today i got bored and started reading about con tricks on wikipedia; and then i felt like i needed to emphasize the 'stage magic/illusion' theme for vanish more*/,Reset Button,,,PURPLE,change_power,noeffect,,none,0,NO,NO,,,,,,e.setvar(~trapactions~|1 - getstatusself(~ncr_vanish~)); removestatusself(~ncr_vanish~);,e.animate(~flashandshake~); if(e.getvar(~trapactions~) > 0) { inflict(~ncr_vanish~|e.getvar(~trapactions~)); sfx(~_vanish~);,,,,,,
Long Con_upgraded,Remove up to [vanish]2 from you|Inflict [vanish] equal to excess,1,/*a long con is just a really drawn out con trick; like a ponzi scheme. in this case it's a long con because con tricks are a theme for vanish i guess (see 'Sleight of Hand@ncrmod'; also mildly related is 'gaslighting' since that's also about mentalism) and this consistently inflicts vanish every turn and deflect vanish from you*/,Reset Button,,,PURPLE,,,,none,0,NO,NO,,,,,,e.setvar(~trapactions~|2 - getstatusself(~ncr_vanish~)); removestatusself(~ncr_vanish~|2);,e.animate(~flashandshake~); if(e.getvar(~trapactions~) > 0) { inflict(~ncr_vanish~|e.getvar(~trapactions~)); sfx(~_vanish~);,,,,,,
Hexagram,Get a 6[;] but receive|[vanish]vanish twice each turn,1,/*hot table*/,Mirror Smash,,,PINK,change_power,change_power,,none,0,YES,NO,cannotreuse|shockavoid|altpoisonavoid,,,,,inflictself(~ncr_vanish~|2);,e.animate(~flash~); var mynewdice = new elements.Dice(); mynewdice.basevalue = 6; self.dicepool.push(mynewdice); mynewdice.x = e.x + 280; mynewdice.y = e.y + 192; sfx(~jackpot_rolldice~); e.doequipmentaction(self|target|-e.castdirection|[]|0.5|true);,,,,,e.preventdefault = true; e.maintainfury = true;,
Hexagram_upgraded,Get a 6[;] but receive|[vanish]vanish once each turn,1,/*former ignore reequip method*/,Mirror Smash,,,PINK,,,,none,0,YES,NO,cannotreuse|shockavoid|altpoisonavoid,,,,,inflictself(~ncr_vanish~);,e.animate(~flash~); var mynewdice = new elements.Dice(); mynewdice.basevalue = 6; self.dicepool.push(mynewdice); mynewdice.x = e.x + 280; mynewdice.y = e.y + 192; sfx(~jackpot_rolldice~); e.doequipmentaction(self|target|-e.castdirection|[]|0.5|true);,,,,,e.preventdefault = true; e.maintainfury = true;,
Hexagram_downgraded,Get a 5[;] but receive|[vanish]vanish twice each turn,1,/*former ignore reequip method*/,Mirror Smash,,,PINK,,,,none,0,YES,NO,cannotreuse|shockavoid|altpoisonavoid,,,,,inflictself(~ncr_vanish~|2);,e.animate(~flash~); var mynewdice = new elements.Dice(); mynewdice.basevalue = 5; self.dicepool.push(mynewdice); mynewdice.x = e.x + 280; mynewdice.y = e.y + 192; sfx(~jackpot_rolldice~); e.doequipmentaction(self|target|-e.castdirection|[]|0.5|true);,,,,,e.preventdefault = true; e.maintainfury = true;,
Hexagram_weakened,Get a 5[;] but receive|[vanish]vanish once each turn,1,/*former ignore reequip method*/,Mirror Smash,,,PINK,,,,none,0,YES,NO,cannotreuse|shockavoid|altpoisonavoid,,,,,inflictself(~ncr_vanish~);,e.animate(~flash~); var mynewdice = new elements.Dice(); mynewdice.basevalue = 5; self.dicepool.push(mynewdice); mynewdice.x = e.x + 280; mynewdice.y = e.y + 192; sfx(~jackpot_rolldice~); e.doequipmentaction(self|target|-e.castdirection|[]|0.5|true);,,,,,e.preventdefault = true; e.maintainfury = true;,
Wisper@V,Do [vanish]<d6> damage[;]|inflict [vanish]vanish on 6[;]|inflict [weaken]weaken on 5,2,var swapto = ~Wisper@W~;  var myelement = ~vanish~;  var otherelement = ~weaken~;  attack(d|myelement);  sfxdamage(target|d);    if(d == 6) {   sfx(~_vanish~|~~|0.2);   inflict(~ncr_vanish~);  } if(d == 5) {   sfx(~_~ + otherelement|~~|0.2);   inflict(otherelement);   if(getstatusself(FURY) < 1 && self.layout != ~DECK~) {    var eqtoreplace = ~~;    var onscreenreplace = false;    for(eq in self.equipment) {     /* determine if e is a copy of an equipment that is multiuse or had re-equip used on it; and if it is; store the original variable as eqtoreplace and enable the flag that tells us we're replacing an item already on screen. there's probably an easier way to do this but idk */     if(     e.name == eq.name &&      e.namemodifier == eq.namemodifier &&      (eq.x + 100) >= e.x &&      (eq.x - 100) <= e.x &&      eq != e) {       eqtoreplace = eq; onscreenreplace = true; break;     }    }    if(onscreenreplace) {     var neweq = new elements.Equipment(swapto);     neweq.x = eqtoreplace.x;     neweq.y = eqtoreplace.y;     neweq.row = eqtoreplace.row;     neweq.column = eqtoreplace.column;     if(self.equipment.indexOf(eqtoreplace) != -1) { /*dumb safeguard*/      self.equipment[self.equipment.indexOf(eqtoreplace)] = neweq; /*i don't know why this is necessary but it is; you're just not allowed to refer to equipment through variables when overwriting it with another equipment*/      neweq.animate(~flashandshake~); /*also two variables can't point to the same equipment i guess; doing eqtoreplace.animate(~flashandshake~) has no effect*/     }    } else {     var neweq = new elements.Equipment(swapto);     neweq.column = e.column;     neweq.row = e.row;     neweq.x = -9999;     neweq.y = -9999;     neweq.show = false;     neweq.availablethisturn = false;     if(self.equipment.indexOf(e) != -1) { /*dumb safeguard*/      self.equipment[self.equipment.indexOf(e)] = neweq;     }    }   }  } /*whisp*/,Strobe Light,NORMAL,,PINK,change_power,change_power,,none,0,NO,NO,,,,,,e.countdown = 0;,,,,e.countdown = 7;,,donothing();,
Wisper@W,Do [weaken]<d6> damage[;]|inflict [weaken]weaken on 6[;]|inflict [vanish]vanish on 5,2,var swapto = ~Wisper@V~;  var myelement = ~weaken~;  var otherelement = ~vanish~;  attack(d|myelement);  sfxdamage(target|d);    if(d == 6) {   sfx(~_~ + myelement|~~|0.2);   inflict(myelement);  } if(d == 5) {   sfx(~_vanish~|~~|0.2);   inflict(~ncr_vanish~);   if(getstatusself(FURY) < 1 && self.layout != ~DECK~) {    var eqtoreplace = ~~;    var onscreenreplace = false;    for(eq in self.equipment) {     /* determine if e is a copy of an equipment that is multiuse or had re-equip used on it; and if it is; store the original variable as eqtoreplace and enable the flag that tells us we're replacing an item already on screen. there's probably an easier way to do this but idk */     if(     e.name == eq.name &&      e.namemodifier == eq.namemodifier &&      (eq.x + 100) >= e.x &&      (eq.x - 100) <= e.x &&      eq != e) {       eqtoreplace = eq; onscreenreplace = true; break;     }    }    if(onscreenreplace) {     var neweq = new elements.Equipment(swapto);     neweq.x = eqtoreplace.x;     neweq.y = eqtoreplace.y;     neweq.row = eqtoreplace.row;     neweq.column = eqtoreplace.column;     if(self.equipment.indexOf(eqtoreplace) != -1) { /*dumb safeguard*/      self.equipment[self.equipment.indexOf(eqtoreplace)] = neweq; /*i don't know why this is necessary but it is; you're just not allowed to refer to equipment through variables when overwriting it with another equipment*/      neweq.animate(~flashandshake~); /*also two variables can't point to the same equipment i guess; doing eqtoreplace.animate(~flashandshake~) has no effect*/     }    } else {     var neweq = new elements.Equipment(swapto);     neweq.column = e.column;     neweq.row = e.row;     neweq.x = -9999;     neweq.y = -9999;     neweq.show = false;     neweq.availablethisturn = false;     if(self.equipment.indexOf(e) != -1) { /*dumb safeguard*/      self.equipment[self.equipment.indexOf(e)] = neweq;     }    }   }  },Scream,NORMAL,,ORANGE,change_power,change_power,,none,0,NO,NO,,,,,,e.countdown = 0;,,,,e.countdown = 7;,,donothing();,
Wisper@V_downgraded,Do [vanish]<d6> damage[;]|inflict [vanish]vanish on 6,2,attack(d|VANISH); if(d == 6) { sfx(~_vanish~|~~|0.2); inflict(~ncr_vanish~); } sfxdamage(target|d);,Strobe Light,EVEN,,PINK,,,,none,0,NO,NO,,,,,,,,,,,,donothing();,
Wisper@W_downgraded,Do [weaken]<d6> damage[;]|inflict [weaken]weaken on 6,2,attack(d|WEAKEN); if(d == 6) { inflict(WEAKEN); sfx(~_weaken~); } sfxdamage(target|d);,Scream,EVEN,,ORANGE,,,,none,0,NO,NO,,,,,,,,,,,,donothing();,
Wisper@V_upgraded,Do [vanish]<d6> damage[;]|inflict [vanish]vanish on 6[;]|inflict [weaken]weaken on 5,2,var swapto = ~Wisper@W~;  var myelement = ~vanish~;  var otherelement = ~weaken~;  attack(d|myelement);  sfxdamage(target|d);    if(d == 7) {   sfx(~_vanish~|~~|0.2);   inflict(~ncr_vanish~);  } if(d == 6) {   sfx(~_~ + otherelement|~~|0.2);   inflict(otherelement);   if(getstatusself(FURY) < 1 && self.layout != ~DECK~) {    var eqtoreplace = ~~;    var onscreenreplace = false;    for(eq in self.equipment) {     /* determine if e is a copy of an equipment that is multiuse or had re-equip used on it; and if it is; store the original variable as eqtoreplace and enable the flag that tells us we're replacing an item already on screen. there's probably an easier way to do this but idk */     if(     e.name == eq.name &&      e.namemodifier == eq.namemodifier &&      (eq.x + 100) >= e.x &&      (eq.x - 100) <= e.x &&      eq != e) {       eqtoreplace = eq; onscreenreplace = true; break;     }    }    if(onscreenreplace) {     var neweq = new elements.Equipment(swapto);     neweq.x = eqtoreplace.x;     neweq.y = eqtoreplace.y;     neweq.row = eqtoreplace.row;     neweq.column = eqtoreplace.column;     if(self.equipment.indexOf(eqtoreplace) != -1) { /*dumb safeguard*/      self.equipment[self.equipment.indexOf(eqtoreplace)] = neweq; /*i don't know why this is necessary but it is; you're just not allowed to refer to equipment through variables when overwriting it with another equipment*/      neweq.animate(~flashandshake~); /*also two variables can't point to the same equipment i guess; doing eqtoreplace.animate(~flashandshake~) has no effect*/     }    } else {     var neweq = new elements.Equipment(swapto);     neweq.column = e.column;     neweq.row = e.row;     neweq.x = -9999;     neweq.y = -9999;     neweq.show = false;     neweq.availablethisturn = false;     if(self.equipment.indexOf(e) != -1) { /*dumb safeguard*/      self.equipment[self.equipment.indexOf(e)] = neweq;     }    }   }  },Strobe Light,NORMAL|FREE1,,PINK,,,,none,0,NO,NO,,,,,,e.countdown = 0;,,,,e.countdown = 7;,,donothing();,
Wisper@W_upgraded,Do [weaken]<d6> damage[;]|inflict [weaken]weaken on 6[;]|inflict [vanish]vanish on 5,2,var swapto = ~Wisper@V~;  var myelement = ~weaken~;  var otherelement = ~vanish~;  attack(d|myelement);  sfxdamage(target|d);    if(d == 7) {   sfx(~_~ + myelement|~~|0.2);   inflict(myelement);  } if(d == 6) {   sfx(~_vanish~|~~|0.2);   inflict(~ncr_vanish~);   if(getstatusself(FURY) < 1 && self.layout != ~DECK~) {    var eqtoreplace = ~~;    var onscreenreplace = false;    for(eq in self.equipment) {     /* determine if e is a copy of an equipment that is multiuse or had re-equip used on it; and if it is; store the original variable as eqtoreplace and enable the flag that tells us we're replacing an item already on screen. there's probably an easier way to do this but idk */     if(     e.name == eq.name &&      e.namemodifier == eq.namemodifier &&      (eq.x + 100) >= e.x &&      (eq.x - 100) <= e.x &&      eq != e) {       eqtoreplace = eq; onscreenreplace = true; break;     }    }    if(onscreenreplace) {     var neweq = new elements.Equipment(swapto);     neweq.x = eqtoreplace.x;     neweq.y = eqtoreplace.y;     neweq.row = eqtoreplace.row;     neweq.column = eqtoreplace.column;     if(self.equipment.indexOf(eqtoreplace) != -1) { /*dumb safeguard*/      self.equipment[self.equipment.indexOf(eqtoreplace)] = neweq; /*i don't know why this is necessary but it is; you're just not allowed to refer to equipment through variables when overwriting it with another equipment*/      neweq.animate(~flashandshake~); /*also two variables can't point to the same equipment i guess; doing eqtoreplace.animate(~flashandshake~) has no effect*/     }    } else {     var neweq = new elements.Equipment(swapto);     neweq.column = e.column;     neweq.row = e.row;     neweq.x = -9999;     neweq.y = -9999;     neweq.show = false;     neweq.availablethisturn = false;     if(self.equipment.indexOf(e) != -1) { /*dumb safeguard*/      self.equipment[self.equipment.indexOf(e)] = neweq;     }    }   }  },Scream,NORMAL|FREE1,,ORANGE,,,,none,0,NO,NO,,,,,,e.countdown = 0;,,,,e.countdown = 7;,,donothing();,
Swamp Gas,Convert enemy's|[vanish]vanish to [poison]poison|[80%][gray]''Reflected by a weather balloon'',1,var g = getstatus(~ncr_vanish~); if(getstatus(VANISH) > 0) { g = target.dice + target.extradice + target.bonusdice; } if(g > 0) { inflict(POISON|g); sfx(~_vanish~); sfx(~_poison~); removestatus(~ncr_vanish~|ALL); removestatus(VANISH|ALL); } else {self.textparticle(~No effect!~); },Overload,EVEN,,PURPLE,simplify,complicate,,none,0,NO,NO,,,,,,,,,,,,,
Containment Trap,Do [vanish]<d6> damage[;] on 4[;]|get a Soul Jar for this turn,1,attack(d|VANISH); if(d == 4 && getstatusself(FURY) < 1) { if(self.getvar(~ncrwispkludge~) == 0) { giveequipment(~Soul Jar~|true); } else { giveequipment(~Matchstick~|true); } sfx(~_thinghappens~); } /*originally named 'soul jar jar' but that's just too dumb even for me. jar-jar; you're a genius!*/,Hadoken,MAX4,,PINK,change_power,change_power,,_damage,0,NO,NO,excludefromrandomlists,,,,,,,,,,,donothing();,
Containment Trap_upgraded,Do [vanish]<d6> damage[;] on 4[;]|get a Soul Jar permanently,1,attack(d|VANISH); if(d == 4 && getstatusself(FURY) < 1) { if(self.getvar(~ncrwispkludge~) == 0) { giveequipment(~Soul Jar~|true|false|e); } else { giveequipment(~Matchstick~|true|false|e); } sfx(~openchest~); } /*anyway how does this work what? you hit the enemy with the trap and on 4 you open it and then you put the contents in a jar immediately. are you like stealing the enemy's soul or are there just a lot of ghosts in there for some reason. uh. it dont make sense but who caresss*/,Hadoken,MAX4,,PINK,,,,_damage,0,NO,NO,excludefromrandomlists,,,,,,,,,,,donothing();,
Containment Trap_downgraded,Do [vanish]<d6> damage[;] on 4[;]|inflict [vanish]vanish,1,attack(d|VANISH); if(d == 4) { inflict(~ncr_vanish~);,Hadoken,MAX4,,PINK,,,,_damage,0,NO,NO,excludefromrandomlists,,,,,,,,,,,,
Tombstone,Get [vanish]1 vanish[;] do [vanish]3 dmg|(Always offered as scrap)|,1,inflictself(~ncr_vanish~); sfxdamage(target|3); attack(3|VANISH); /*isn't this where-*/,Hadoken,EVEN,,GRAY,change_power,change_power,,_vanish,-1,NO,NO,appearsforparts,,,,,,,,,,,,
Tombstone_upgraded,Do [vanish]3 damage|(Always offered as scrap)|,1,sfxdamage(target|3); attack(3|VANISH);,Hadoken,EVEN,,GRAY,,,,_vanish,-1,NO,NO,appearsforparts,,,,,,,,,,,,
Tombstone_downgraded,Get [vanish]2 vanish[;] do [vanish]3 dmg|(Always offered as scrap)|,1,inflictself(~ncr_vanish~|2); sfxdamage(target|3); attack(3|VANISH);,Hadoken,EVEN,,GRAY,,,,_vanish,-1,NO,NO,appearsforparts,,,,,,,,,,,,
Scrap Puck,Freeze self[;] do [ice]3 dmg|(Always offered as scrap)|,1,var oldfreeze = 0; var oldaltfreeze = 0; if(self.status.length > 0) { for(stat in self.status) { if(stat.type == ~ice~) { oldfreeze = stat.value; } if(stat.type == ~alternate_ice~) { oldaltfreeze = stat.value; } } } inflictself(ICE); sfxdamage(target|3); attack(3|ICE); var inflictwhat = ~~; for(stat in self.status) { if(stat.type == ~ice~ && stat.value != oldfreeze) { inflictwhat = stat.type; } if(stat.type == ~alternate_ice~ && stat.value != oldaltfreeze) { inflictwhat = stat.type; } } if(inflictwhat == ~ice~) { var dicelist = []; for(mydice in self.dicepool) { if(mydice.available() && mydice.burn != true && mydice.animateburn != true) { dicelist.push(mydice); } } if(dicelist.length > 0) { dicelist.sort(function(a|b) return -1 * (a.basevalue - b.basevalue)); dicelist[0].animate(~ice~); } } if(inflictwhat == ~alternate_ice~) { for(mydice in self.dicepool) { if(mydice.available() && mydice.burn != true && mydice.animateburn != true) { mydice.animate(~alternate_ice~); } } } if(self.status.length > 0) { for(stat in self.status) { if(stat.type == inflictwhat) { stat.value--; } } },Flash Freeze,EVEN,,GRAY,change_power,change_power,,_ice,-1,NO,NO,appearsforparts,,,,,,,,,,,,
Scrap Puck_upgraded,Do [ice]3 damage|(Always offered as scrap)|,1,sfxdamage(target|3); attack(3|ICE),Flash Freeze,EVEN,,GRAY,,,,_ice,-1,NO,NO,appearsforparts,,,,,,,,,,,,
Scrap Puck_downgraded,Freeze self 2x[;] do [ice]3 dmg|(Always offered as scrap)|,1,var oldfreeze = 0; var oldaltfreeze = 0; if(self.status.length > 0) { for(stat in self.status) { if(stat.type == ~ice~) { oldfreeze = stat.value; } if(stat.type == ~alternate_ice~) { oldaltfreeze = stat.value; } } } inflictself(ICE|2); sfxdamage(target|3); attack(3|ICE); var inflictwhat = ~~; for(stat in self.status) { if(stat.type == ~ice~ && stat.value != oldfreeze) { inflictwhat = stat.type; } if(stat.type == ~alternate_ice~ && stat.value != oldaltfreeze) { inflictwhat = stat.type; } } if(inflictwhat == ~ice~) { var dicelist = []; for(mydice in self.dicepool) { if(mydice.available() && mydice.burn != true && mydice.alternateburn != true) { dicelist.push(mydice); } } if(dicelist.length > 0) { dicelist.sort(function(a|b) return -1 * (a.basevalue - b.basevalue)); dicelist[0].animate(~ice~); } if(dicelist.length > 1) { dicelist[1].animate(~ice~|0.1); } } if(inflictwhat == ~alternate_ice~) { for(mydice in self.dicepool) { if(mydice.available() && mydice.burn != true && mydice.alternateburn != true) { mydice.animate(~alternate_ice~); mydice.animate(~alternate_ice~|0.1); } } } if(self.status.length > 0) { for(stat in self.status) { if(stat.type == inflictwhat) { stat.value -= 2; } } },Flash Freeze,EVEN,,GRAY,,,,_ice,-1,NO,NO,appearsforparts,,,,,,,,,,,,
Cremator,[vanish]4 damage + [vanish]1 vanish|[gray](Reuseable),1,sfxdamage(target|4); attack(4|VANISH); inflict(~ncr_vanish~); /*furnace*/,Hadoken,COUNTDOWN,8,PURPLE,change_power,change_power,,_vanish,-1,NO,NO,,1,,,,,,,,,,,
Cremator_upgraded,[vanish]6 damage + [vanish]1 vanish|[gray](Reuseable),1,sfxdamage(target|6); attack(6|VANISH); inflict(~ncr_vanish~);,Hadoken,COUNTDOWN,8,PURPLE,,,,_vanish,-1,NO,NO,,,,,,,,,,,,,
Cremator_downgraded,[vanish]2 damage + [vanish]1 vanish|[gray](Reuseable),1,sfxdamage(target|2); attack(2|VANISH); inflict(~ncr_vanish~);,Hadoken,COUNTDOWN,8,PURPLE,,,,_vanish,-1,NO,NO,,,,,,,,,,,,,
Industrial Press,Gain [shield]<d6> shield|On 4[;] do [sword]4 damage,2,if(d == 4) { attack(4); sfxdamage(target|4); sfx(~_shield~|~~|0.2); } else { sfx(~_shield~); } inflictself(SHIELD|d); /*cody thought of this name*/,Safeguard,MAX4,,ORANGE,simplify,change_function,,none,0,NO,NO,,,,,,,,,,if(d == 1) { e.castdirection = 1; } else { e.castdirection = -1; },,,
Industrial Press_downgraded,Gain [shield]<d6> shield,2,inflictself(SHIELD|d);,Safeguard,MAX4,,ORANGE,,,,_shield,0,NO,NO,,,,,,,,,,,,,
Bustle,Do [sword]<d6> damage. On 6[;]|charge limit break by [confuse]3,2,attack(d); sfxdamage(target|d); if(d == 6) { sfx(~_cure~); if(self.limitvalue != null && self.limitmax != null) { self.limitvalue += 3; if(self.limitvalue > self.limitmax) { self.limitvalue = self.limitmax; } } } /*'hustle and bustle are like my right and left arms'*/,Hustle,NORMAL,,YELLOW,reducesize,change_power,,none,0,NO,NO,,,,,,,,,,,,,
Bustle_downgraded,Do [sword]<d6> damage. On 6[;]|charge limit break by [confuse]1,2,attack(d); sfxdamage(target|d); if(d == 6) { sfx(~_cure~); if(self.limitvalue != null && self.limitmax != null) { self.limitvalue += 1; if(self.limitvalue > self.limitmax) { self.limitvalue = self.limitmax; } } },Hustle,NORMAL,,YELLOW,,,,none,0,NO,NO,,,,,,,,,,,,,
Bustle_weakened,Do [sword]<d6> damage. On 6[;]|charge limit break by [confuse]1,1,attack(d); sfxdamage(target|d); if(d == 6) { sfx(~_cure~); if(self.limitvalue != null && self.limitmax != null) { self.limitvalue += 1; if(self.limitvalue > self.limitmax) { self.limitvalue = self.limitmax; } } },Hustle,NORMAL,,YELLOW,,,,none,0,NO,NO,,,,,,,,,,,,,
Bustle_deckupgrade,Do [sword]<d6> damage. On even[;]|charge limit break by [confuse]3,2,attack(d); sfxdamage(target|d); if(d % 2 == 0) { sfx(~_cure~); if(self.limitvalue != null && self.limitmax != null) { self.limitvalue += 3; if(self.limitvalue > self.limitmax) { self.limitvalue = self.limitmax; } } },Hustle,NORMAL,,YELLOW,reducesize,change_power,,none,0,NO,NO,,,,,,,,,,,,,
Desperation Attack,Do [sword]<d6> dmg. Cost [confuse]<d6>|limit charge: return the dice,1,if(self.limitvalue != null && self.limitvalue >= d) { self.limitvalue -= d; givedice(d); sfx(~_cure~); } attack(d); sfxdamage(target|d);,Hustle,NORMAL,,YELLOW,change_power,change_power,,none,0,NO,NO,,1,,,,,,,,,,,
Desperation Attack_upgraded,Do [sword]<d6>. Cost [confuse]<d6>|limit charge: return both dice,1,if(self.limitvalue != null && self.limitvalue >= d) { self.limitvalue -= d; givedice([d - 2|2]); sfx(~_cure~); } attack(d); sfxdamage(target|d);,Hustle,NORMAL|FREE2,,YELLOW,,,,none,0,NO,NO,,,,,,,,,,,,,
Desperation Attack_downgraded,Do [sword]<d6> damage[;] lower|limit charge by [confuse]<d6>,1,if(self.limitvalue != null) { self.limitvalue -= d; if(self.limitvalue < 0) { self.limitvalue = 0; } sfx(~_cure~); } attack(d); sfxdamage(target|d);,Hustle,NORMAL,,YELLOW,,,,none,0,NO,NO,,,,,,,,,,,,,
Under Pressure,Do [sword]<d6> damage[;]|on 6[;] inflict [ice]1 freeze;|[quote]on X[quote] lowers every turn,2,attack(d); sfxdamage(target|d); var turnnum = 7 - turn; if(turnnum < 1) { turnnum = 1; } if(d == turnnum) { inflict(ICE| 1); sfx(~_ice~|~~|0.2); },Arctic Storm,NORMAL,,BRIGHTCYAN,reducesize,change_power,,none,0,NO,NO,excludefromrandomlists,,,var onblah = [~on 5~|~on 4~|~on 3~|~on 2~|~on 1~]; for(blah in onblah) { if(e.fulldescription.split(blah).length > 1) { e.fulldescription = e.fulldescription.split(blah).join(~on 6~); break; } },var onblah = [~on 5~|~on 4~|~on 3~|~on 2~|~on 1~]; for(blah in onblah) { if(e.fulldescription.split(blah).length > 1) { e.fulldescription = e.fulldescription.split(blah).join(~on 6~); break; } },var onblah = [~on 6~|~on 5~|~on 4~|~on 3~|~on 2~]; for(blah in onblah) { if(e.fulldescription.split(blah).length > 1) { e.fulldescription = e.fulldescription.split(blah).join(~on ~ + (7 - turn)); break; } },,,,,,,
Under Pressure_downgraded,Do [sword]<d6> damage,2,attack(d); sfxdamage(target|d);,Arctic Storm,NORMAL,,BRIGHTCYAN,,,,none,0,NO,NO,excludefromrandomlists,,,,,,,,,,,,
Under Pressure_deckupgrade,Do [sword]<d6> damage[;]|on 6[;] inflict [ice]2 freeze;|[quote]on X[quote] lowers every turn,2,attack(d); sfxdamage(target|d); var turnnum = 7 - turn; if(turnnum < 1) { turnnum = 1; } if(d == turnnum) { inflict(ICE| 2); sfx(~_ice~|~~|0.2); },Arctic Storm,NORMAL,,BRIGHTCYAN,,,,none,0,NO,NO,excludefromrandomlists,,,var onblah = [~on 5~|~on 4~|~on 3~|~on 2~|~on 1~]; for(blah in onblah) { if(e.fulldescription.split(blah).length > 1) { e.fulldescription = e.fulldescription.split(blah).join(~on 6~); break; } },var onblah = [~on 5~|~on 4~|~on 3~|~on 2~|~on 1~]; for(blah in onblah) { if(e.fulldescription.split(blah).length > 1) { e.fulldescription = e.fulldescription.split(blah).join(~on 6~); break; } },var onblah = [~on 6~|~on 5~|~on 4~|~on 3~|~on 2~]; for(blah in onblah) { if(e.fulldescription.split(blah).length > 1) { e.fulldescription = e.fulldescription.split(blah).join(~on ~ + (7 - turn)); break; } },,,,,,,
Ashes to Ashes,Do [sword]<d6> damage[;]|on 6[;] inflict [fire]1 burn;|[quote]on X[quote] lowers every turn,2,attack(d); sfxdamage(target|d); var turnnum = 7 - turn; if(turnnum < 1) { turnnum = 1; } if(d == turnnum) { inflict(FIRE| 1); sfx(~_fire~|~~|0.2); },Hellfire,NORMAL,,RED,reducesize,change_power,,none,0,NO,NO,excludefromrandomlists,,,var onblah = [~on 5~|~on 4~|~on 3~|~on 2~|~on 1~]; for(blah in onblah) { if(e.fulldescription.split(blah).length > 1) { e.fulldescription = e.fulldescription.split(blah).join(~on 6~); break; } },var onblah = [~on 5~|~on 4~|~on 3~|~on 2~|~on 1~]; for(blah in onblah) { if(e.fulldescription.split(blah).length > 1) { e.fulldescription = e.fulldescription.split(blah).join(~on 6~); break; } },var onblah = [~on 6~|~on 5~|~on 4~|~on 3~|~on 2~]; for(blah in onblah) { if(e.fulldescription.split(blah).length > 1) { e.fulldescription = e.fulldescription.split(blah).join(~on ~ + (7 - turn)); break; } },,,,,,,
Ashes to Ashes_downgraded,Do [sword]<d6> damage,2,attack(d); sfxdamage(target|d);,Hellfire,NORMAL,,RED,,,,none,0,NO,NO,excludefromrandomlists,,,,,,,,,,,,
Ashes to Ashes_deckupgrade,Do [sword]<d6> damage[;]|on 6[;] inflict [fire]2 burn;|[quote]on X[quote] lowers every turn,2,attack(d); sfxdamage(target|d); var turnnum = 7 - turn; if(turnnum < 1) { turnnum = 1; } if(d == turnnum) { inflict(FIRE| 2); sfx(~_fire~|~~|0.2); },Hellfire,NORMAL,,RED,,,,none,0,NO,NO,excludefromrandomlists,,,var onblah = [~on 5~|~on 4~|~on 3~|~on 2~|~on 1~]; for(blah in onblah) { if(e.fulldescription.split(blah).length > 1) { e.fulldescription = e.fulldescription.split(blah).join(~on 6~); break; } },var onblah = [~on 5~|~on 4~|~on 3~|~on 2~|~on 1~]; for(blah in onblah) { if(e.fulldescription.split(blah).length > 1) { e.fulldescription = e.fulldescription.split(blah).join(~on 6~); break; } },var onblah = [~on 6~|~on 5~|~on 4~|~on 3~|~on 2~]; for(blah in onblah) { if(e.fulldescription.split(blah).length > 1) { e.fulldescription = e.fulldescription.split(blah).join(~on ~ + (7 - turn)); break; } },,,,,,,
Bite the Dust,Do [sword]<d6> damage[;]|on 6[;] inflict [vanish]1 vanish;|[quote]on X[quote] lowers every turn,2,attack(d); sfxdamage(target|d); var turnnum = 7 - turn; if(turnnum < 1) { turnnum = 1; } if(d == turnnum) { inflict(~ncr_vanish~); sfx(~_vanish~|~~|0.2); }  } /*fuck i can't come up with names*/,Strobe Light,NORMAL,,PINK,reducesize,change_power,,none,0,NO,NO,excludefromrandomlists,,,var onblah = [~on 5~|~on 4~|~on 3~|~on 2~|~on 1~]; for(blah in onblah) { if(e.fulldescription.split(blah).length > 1) { e.fulldescription = e.fulldescription.split(blah).join(~on 6~); break; } },var onblah = [~on 5~|~on 4~|~on 3~|~on 2~|~on 1~]; for(blah in onblah) { if(e.fulldescription.split(blah).length > 1) { e.fulldescription = e.fulldescription.split(blah).join(~on 6~); break; } },var onblah = [~on 6~|~on 5~|~on 4~|~on 3~|~on 2~]; for(blah in onblah) { if(e.fulldescription.split(blah).length > 1) { e.fulldescription = e.fulldescription.split(blah).join(~on ~ + (7 - turn)); break; } },,,,,,,
Bite the Dust_downgraded,Do [sword]<d6> damage,2,attack(d); sfxdamage(target|d);,Strobe Light,NORMAL,,PINK,,,,none,0,NO,NO,excludefromrandomlists,,,,,,,,,,,,
Bite the Dust_deckupgrade,Do [sword]<d6> damage[;]|on 6[;] inflict [vanish]2 vanish;|[quote]on X[quote] lowers every turn,2,attack(d); sfxdamage(target|d); var turnnum = 7 - turn; if(turnnum < 1) { turnnum = 1; } if(d == turnnum) { inflict(~ncr_vanish~|2); sfx(~_vanish~|~~|0.2); }  },Strobe Light,NORMAL,,PINK,,,,none,0,NO,NO,excludefromrandomlists,,,var onblah = [~on 5~|~on 4~|~on 3~|~on 2~|~on 1~]; for(blah in onblah) { if(e.fulldescription.split(blah).length > 1) { e.fulldescription = e.fulldescription.split(blah).join(~on 6~); break; } },var onblah = [~on 5~|~on 4~|~on 3~|~on 2~|~on 1~]; for(blah in onblah) { if(e.fulldescription.split(blah).length > 1) { e.fulldescription = e.fulldescription.split(blah).join(~on 6~); break; } },var onblah = [~on 6~|~on 5~|~on 4~|~on 3~|~on 2~]; for(blah in onblah) { if(e.fulldescription.split(blah).length > 1) { e.fulldescription = e.fulldescription.split(blah).join(~on ~ + (7 - turn)); break; } },,,,,,,
Undermine,Do [weaken]<d6> damage[;] if below 3[;]|inflict [weaken]<d6> weaken instead,2,if(d > 2) { attack(d); sfxdamage(target|d); } else { inflict(WEAKEN|d); sfx(~_weaken~); },Scream,NORMAL,,ORANGE,change_power,change_power,,none,0,NO,NO,,,,,,,,,,,,,
Undermine_upgraded,Do [weaken]<d6> damage[;] if below 3[;]|also inflict [weaken]<d6> weaken,2,attack(d); sfxdamage(target|d); if(d <= 2) { inflict(WEAKEN|d); sfx(~_weaken~); },Scream,NORMAL,,ORANGE,,,,none,0,NO,NO,,,,,,,,,,,,,
Undermine_downgraded,Do [weaken]<d6> damage,2,attack(d); sfxdamage(target|d);,Scream,MIN3,,ORANGE,,,,none,0,NO,NO,,,,,,,,,,,,,
Rickety Shield,Gain [shield]<d6> shield. In [jinx]2|turns[;] take [sword]<d6> damage,1,inflictself(SHIELD|d); jinx(~Rickety Shield~|~take [sword]%VAR% damage~|~Take [sword]%VAR% damage~|~sfxdamage(null|%VAR%); attack(%VAR%); sfx(\~_shield\~);~|self|self|2|d); sfx(~_thinghappens~);,Safeguard,NORMAL,,ORANGE,add2,change_power,,_shield,0,YES,NO,,1,,,,,,,,,,,
Rickety Shield_downgraded,Gain [shield]<d6> shield. In [jinx]2|turns[;] lose [heart]<d6> health,1,inflictself(SHIELD|d); jinx(~Rickety Shield-~|~lose [heart]%VAR% health~|~Lose [heart]%VAR% health~|~sfxdamage(null|%VAR%); pierceattack(%VAR%); sfx(\~_shield\~);~|self|self|2|d); sfx(~_thinghappens~);,Safeguard,NORMAL,,ORANGE,,,,_shield,0,YES,NO,,,,,,,,,,,,,
No Pain No Gain,Lose [heart]<d6> health. In [jinx]2|turns[;] heal for [heart]<double>,1,pierceattackself(d); sfx(~_heal~); jinx(~No Pain No Gain~|~recover [heart]%VAR% health~|~Recover [heart]%VAR% health~|~attack(-%VAR%); sfx(\~_heal\~);~|self|self|2|d * 2);,Rejuvenate,NORMAL,,PURPLE,change_power,complicate,,none,0,YES,NO,,1,,,,,,,,,,,
No Pain No Gain_upgraded,Lose [heart]3 health. In [jinx]2|turns[;] heal for [heart]<double>,1,pierceattackself(4); sfx(~_heal~); jinx(~No Pain No Gain~|~recover [heart]%VAR% health~|~Recover [heart]%VAR% health~|~attack(-%VAR%); sfx(\~_heal\~);~|self|self|2|d * 2);,Rejuvenate,NORMAL,,PURPLE,,,,none,0,YES,NO,,,,,,,,,,,,,
Defense Mechanism,Gain [shield]8 shield[;] on double|5[;] gain [reduce]1 reduce,1,inflictself(SHIELD|8); if(actualdice[0].basevalue == 5 && actualdice[1].basevalue == 5) inflictself(REDUCE|1);,Safeguard,NORMAL|NORMAL,10,ORANGE,change_power,change_power,,_shield,0,YES,NO,,1,,,,,,,,,,,
Defense Mechanism_downgraded,Gain [shield]4 shield[;] on double|5[;] gain [reduce]1 reduce,1,inflictself(SHIELD|8); if(actualdice[0].basevalue == 5 && actualdice[1].basevalue == 5) inflictself(REDUCE|1);,Safeguard,NORMAL|NORMAL,10,ORANGE,,,,_shield,0,YES,NO,,,,,,,,,,,,,
Defense Mechanism_upgraded,Gain [shield]8 shield[;] on double|5[;] gain [reduce]1 reduce,1,inflictself(SHIELD|8); if(e.dicehistory[e.dicehistory.length - 2].basevalue == 5 && e.dicehistory[e.dicehistory.length - 1].basevalue == 5) inflictself(REDUCE|1);,Safeguard,COUNTDOWN,10,ORANGE,,,,_shield,0,YES,NO,cannotreuse,,,,,,,,,,,,
Defense Mechanism_weakened,Gain [shield]4 shield[;] on double|5[;] gain [reduce]1 reduce,1,inflictself(SHIELD|4); if(e.dicehistory[e.dicehistory.length - 2].basevalue == 5 && e.dicehistory[e.dicehistory.length - 1].basevalue == 5) inflictself(REDUCE|1);,Safeguard,COUNTDOWN,10,ORANGE,,,,_shield,0,YES,NO,cannotreuse,,,,,,,,,,,,
Shiny Nunchucks,Do [sword]3[;] +[dice]Dice_Trigger[]|for the sum of the dice,1,attack(3); sfxdamage(target|3); sfx(~_magic~|~~|0.1); if(d > 12 # d < 1) { self.textparticle(~what~); } else if(d <= 6) { inflictself(~dice_trigger_~ + d); } else { inflictself(~dice_trigger_6~); inflictself(~dice_trigger_~ + (d - 6)); },Copyright Strike,MAX3|MAX3,,RED,change_power,change_power,,none,0,NO,NO,,,,,,,,,,,,,
Shiny Nunchucks_upgraded,Do [sword]3[;] +[dice]Dice_Trigger(s)[]|for the sum of the dice,1,attack(3); sfxdamage(target|3); sfx(~_magic~|~~|0.1); if(d > 12 # d < 1) { self.textparticle(~what~); } else if(d <= 6) { inflictself(~dice_trigger_~ + d); } else { inflictself(~dice_trigger_6~); inflictself(~dice_trigger_~ + (d - 6)); },Copyright Strike,MAX4|MAX4,,RED,,,,none,0,NO,NO,,,,,,,,,,,,,
Shiny Nunchucks_downgraded,Do [sword]3 damage,1,attack(3); sfxdamage(target|3);,Copyright Strike,MAX3|MAX3,,RED,,,,none,0,NO,NO,,,,,,,,,,,,,
Autohook,Gain [recycle]Re-Equip for|every 4 items used|this fight (items used: <var:itemsused>),1,/*i decided; you know what; if i'm really going to implement all of these ridiculous reequip edgecases for stuff like whipcrack; i'm not letting them go to waste*/,Sustainability,,,GREEN,change_power,change_power,,none,0,NO,NO,,,,self.setvar(~itemuses~|0);,self.setvar(~itemuses~|0);,,,,self.setvar(~itemuses~|self.getvar(~itemuses~) + 1); if(self.getvar(~itemuses~) % 4 == 0) { sfx(~_recycle~); e.animate(~flashandshake~); inflictself(REEQUIPNEXT); },,,,
Autohook_upgraded,Gain [recycle]Re-Equip at start|of fight[;] and for every 4|items used this fight (<var:itemsused>),1,,Sustainability,,,GREEN,,,,none,0,NO,NO,,,,self.setvar(~itemuses~|0);,self.setvar(~itemuses~|0);,,e.animate(~flashandshake~); inflictself(REEQUIPNEXT); sfx(~_recycle~);,,self.setvar(~itemuses~|self.getvar(~itemuses~) + 1); if(self.getvar(~itemuses~) % 4 == 0) { sfx(~_recycle~); e.animate(~flashandshake~); inflictself(REEQUIPNEXT); },,,,
Autohook_downgraded,Gain [recycle]Re-Equip for|every 5 items used|this fight (items used: <var:itemsused>),1,,Sustainability,,,GREEN,,,,none,0,NO,NO,,,,self.setvar(~itemuses~|0);,self.setvar(~itemuses~|0);,,,,self.setvar(~itemuses~|self.getvar(~itemuses~) + 1); if(self.getvar(~itemuses~) % 5 == 0) { sfx(~_recycle~); e.animate(~flashandshake~); inflictself(REEQUIPNEXT); },,,,
Scrap Slam,Reroll <d6> dice[;] return this|(Always offered as scrap),1,var c = 0; var avail = []; for(mydice in self.dicepool) { if(mydice.available()) { avail.push(mydice); } } if(avail.length > 0) { var max = d; if(max > avail.length) { max = avail.length; } shuffle(avail); for(i in 0...max) { avail[i].animatereroll(rand([1|2|3|4|5|6]) | self.screenposition()| c * 0.05); c++; }   } givedice(d);,Double Whammy,MAX3,,GRAY,change_power,change_power,,none,0,YES,NO,appearsforparts,,,,,,,,,,,,
Scrap Slam_upgraded,Reroll <d6> dice[;] return this|(Always offered as scrap),1,var c = 0; var avail = []; for(mydice in self.dicepool) { if(mydice.available()) { avail.push(mydice); } } if(avail.length > 0) { var max = d; if(max > avail.length) { max = avail.length; } shuffle(avail); for(i in 0...max) { avail[i].animatereroll(rand([1|2|3|4|5|6]) | self.screenposition()| c * 0.05); c++; }   } givedice([actualdice[0].basevalue|actualdice[1].basevalue]);,Double Whammy,MIN4,,GRAY,,,,none,0,YES,NO,appearsforparts,,,,,,,,,,,,
Scrap Slam_downgraded,Reroll <d6> dice|(Always offered as scrap),1,var c = 0; var avail = []; for(mydice in self.dicepool) { if(mydice.available()) { avail.push(mydice); } } if(avail.length > 0) { var max = d; if(max > avail.length) { max = avail.length; } shuffle(avail); for(i in 0...max) { avail[i].animatereroll(rand([1|2|3|4|5|6]) | self.screenposition()| c * 0.05); c++; }   },Double Whammy,MAX3,,GRAY,,,,none,0,YES,NO,appearsforparts,,,,,,,,,,,,
Zombo,Inflict 2 of a random status[;]|then return the dice,1,var sl = [CURSE|LOCK|FIRE|ICE|WEAKEN|SHOCK|POISON|BLIND|~vanish~]; var s = e.getvar(~statustoinflict~); trace(e.getvar(~statustoinflict~)); trace(s); trace(sl[s]); var r = e.getvar(~amounttoinflict~); trace(e.getvar(~amounttoinflict~)); trace(r); givedice(d); if(sl[s] == ~vanish~) { sfx(~_vanish~); inflict(~ncr_vanish~|r); } else { inflict(sl[s]|r); sfx(~_~ + sl[s]);  },Stardust,REQUIRE5,,PINK,change_power,change_function,,none,0,NO,NO,,,,e.changecolour(~PINK~);,e.changecolour(~PINK~);,e.changeslots([rand([~REQUIRE1~|~REQUIRE2~|~REQUIRE3~|~REQUIRE4~|~REQUIRE5~|~REQUIRE6~])]); var sl = [0|1|2|2|2|2|3|3|3|3|4|4|4|5|5|5|6|6|7]; for(i in 0...1) { sl = sl.concat(sl); } sl.push(8); var s = rand(sl); trace(sl); trace(~hi~); trace(s); var r = 2; trace(r); e.setvar(~statustoinflict~|s); trace(e.getvar(~statustoinflict~)); e.setvar(~amounttoinflict~|r); trace(e.getvar(~amounttoinflict~)); if(s == 7 # s == 0 # s == 1) { e.changecolour(~GRAY~); } if(s == 2) { e.changecolour(~RED~); } if(s == 3) { e.changecolour(~BLUE~); } if(s == 4) { e.changecolour(~ORANGE~); } if(s == 5) { e.changecolour(~YELLOW~); } if(s == 6) { e.changecolour(~PURPLE~); } if(s == 8) { e.changecolour(~PINK~); },,,,,,,
Zombo_upgraded,Inflict 2 of a random status[;]|do [sword]3[;] then return the dice,1,var sl = [CURSE|LOCK|FIRE|ICE|WEAKEN|SHOCK|POISON|BLIND|~vanish~]; var s = e.getvar(~statustoinflict~); trace(e.getvar(~statustoinflict~)); trace(s); trace(sl[s]); var r = e.getvar(~amounttoinflict~); trace(e.getvar(~amounttoinflict~)); trace(r); givedice(d); if(sl[s] == ~vanish~) { sfx(~_vanish~); inflict(~ncr_vanish~|r); } else { inflict(sl[s]|r); sfx(~_~ + sl[s]);  } attack(3); sfxdamage(target|3);,Stardust,REQUIRE5,,PINK,,,,none,0,NO,NO,,,,e.changecolour(~PINK~);,e.changecolour(~PINK~);,e.changeslots([rand([~REQUIRE1~|~REQUIRE2~|~REQUIRE3~|~REQUIRE4~|~REQUIRE5~|~REQUIRE6~])]); var sl = [0|1|2|2|2|2|3|3|3|3|4|4|4|5|5|5|6|6|7]; for(i in 0...1) { sl = sl.concat(sl); } sl.push(8); var s = rand(sl); trace(sl); trace(~hi~); trace(s); var r = 2; trace(r); e.setvar(~statustoinflict~|s); trace(e.getvar(~statustoinflict~)); e.setvar(~amounttoinflict~|r); trace(e.getvar(~amounttoinflict~)); if(s == 7 # s == 0 # s == 1) { e.changecolour(~GRAY~); } if(s == 2) { e.changecolour(~RED~); } if(s == 3) { e.changecolour(~BLUE~); } if(s == 4) { e.changecolour(~ORANGE~); } if(s == 5) { e.changecolour(~YELLOW~); } if(s == 6) { e.changecolour(~PURPLE~); } if(s == 8) { e.changecolour(~PINK~); },,,,,,,
Zombo_downgraded,No effect.|Return the dice,1,givedice(d);,Stardust,REQUIRE5,,PINK,,,,none,0,NO,NO,,,,e.changecolour(~PINK~);,e.changecolour(~PINK~);,e.changeslots([rand([~REQUIRE1~|~REQUIRE2~|~REQUIRE3~|~REQUIRE4~|~REQUIRE5~|~REQUIRE6~])]);,,,,,,,
Gizmotron,Inflict [weaken]weaken & an extra|status depending on dice:|1[blind] 2[fire] 3[shock] 4[vanish] 5[ice] 6[weaken],2,var statlist = [~blind~|~fire~|~shock~|~vanish~|~ice~|~weaken~]; inflict(WEAKEN); if(statlist[d - 1] == ~vanish~) { inflict(~ncr_vanish~|r);  } else { inflict(statlist[d - 1]); } sfx(~_~ + statlist[d - 1]); /*this is perhaps the one item in this mod directly inspired by more fluff. actually there's probably some other more fluff-esque stuff here; so let's just say it's the first item directly inspired by more fluff AND 1979 guitar attachment marketing disasters. (ed: actually 'inflict a status depending on what number you use' probably isn't rare to come up with independently)*/,Guitar Solo,NORMAL,,ORANGE,change_power,change_function,,none,0,NO,NO,,,,,,,,,,,,,
Gizmotron_downgraded,Inflict a status|depending on dice:|1[blind] 2[fire] 3[shock] 4[vanish] 5[ice] 6[weaken],2,var statlist = [~blind~|~fire~|~shock~|~vanish~|~ice~|~weaken~]; if(statlist[d - 1] == ~vanish~) { inflict(~ncr_vanish~|r);  } else { inflict(statlist[d - 1]); } sfx(~_~ + statlist[d - 1]);,Guitar Solo,NORMAL,,ORANGE,,,,none,0,NO,NO,,,,,,,,,,,,,
Gizmotron_upgraded,Inflict [weaken]weaken & an extra|status depending on dice:|1[weaken] 2[blind] 3[fire] 4[shock] 5[vanish] 6[ice],2,var statlist = [~weaken~|~blind~|~fire~|~shock~|~vanish~|~ice~]; inflict(WEAKEN); if(statlist[d - 1] == ~vanish~) { inflict(~ncr_vanish~|r);  } else { inflict(statlist[d - 1]); } sfx(~_~ + statlist[d - 1]);,Guitar Solo,NORMAL,,ORANGE,,,,none,0,NO,NO,,,,,,,,,,,,,
Greed,Lose enough HP to fuel|your limit break[;] now|[gray](once per battle),1,if(!self.isplayer) { self.textparticle(~No effect!~); } else { if(self.limitready()) { self.textparticle(~Uhhh...~); } else { if(self.hp <= self.limitmax - self.limitvalue) { self.textparticle(~Not safe!~);  } else { pierceattackself(self.limitmax - self.limitvalue); sfx(~_curse~); } } },Pure Evil,EVEN,,GRAY,change_power,change_function,,none,0,YES,YES,,,,,,,,,,,,,
Greed_upgraded,Lose HP to fuel limit[;]|recover 1/2 of HP taken|[gray](once per battle),1,if(!self.isplayer) { self.textparticle(~No effect!~); } else { if(self.limitready()) { self.textparticle(~Uhhh...~); } else { if(self.hp <= self.limitmax - self.limitvalue) { self.textparticle(~Not safe!~);  } else { var slm = self.limitmax; var slv = self.limitvalue; pierceattackself(self.limitmax - self.limitvalue); sfx(~_curse~); attackself(-1 * (slm - slv)); } } },Pure Evil,EVEN,,GRAY,,,,none,0,YES,YES,,,,,,,,,,,,,
Greed_downgraded,Lose 6 HP[;] now|[gray](once per battle),1,pierceattackself(6);,Pure Evil,EVEN,,GRAY,,,,_curse,0,YES,YES,,,,,,,,,,,,,
King of Diamonds,Do [sword]<d6>. On 6[;] discard this[;]|& enemy gets [gold]1 next turn,2,attack(d); if(d == 6) { jinx(~King of Diamonds~|~enemy gets [gold]1 gold~|~Enemy gets [gold]1 gold~|~self.gold++; screenshake(); sfx(\~pickupgold\~);~|self|target|1|1); sfx(~_thinghappens~); },Harvest,NORMAL,,RED,reducesize,change_function,,_damage,0,NO,NO,,,,,,,,,,if(d == 6) { e.onceperbattle = true; },,,
King of Diamonds_downgraded,Do [sword]<d6> damage,2,attack(d);,Harvest,NORMAL,,RED,,,,_damage,0,NO,NO,,,,,,,,,,,,,
King of Diamonds_weakened,Do [sword]<d6> damage,1,attack(d);,Harvest,NORMAL,,RED,,,,_damage,0,NO,NO,,,,,,,,,,,,,
King of Diamonds_deckupgrade,Do [sword]<d6>. On 5[;] discard this[;]|& enemy gets [gold]1 next turn,2,attack(d); if(d == 5) { jinx(~King of Diamonds~|~enemy gets [gold]1 gold~|~Enemy gets [gold]1 gold~|~self.gold++; screenshake(); sfx(\~pickupgold\~);~|self|target|1|1); sfx(~_thinghappens~); } /*jester shouldn't be able to get any of the _ of diamonds cards except jack of diamonds; but whatever*/,Harvest,NORMAL,,RED,,,,_damage,0,NO,NO,,,,,,,,,,if(d == 5) { e.onceperbattle = true; },,,
Queen of Diamonds,Do [sword]<d6>. On 6[;] discard this[;]|& enemy gets [gold]1 next turn,2,attack(d); if(d == 6) { jinx(~Queen of Diamonds~|~enemy gets [gold]1 gold~|~Enemy gets [gold]1 gold~|~self.gold++; screenshake(); sfx(\~pickupgold\~);~|self|target|1|1); sfx(~_thinghappens~); },Harvest,NORMAL,,RED,reducesize,change_function,,_damage,0,NO,NO,,,,,,,,,,if(d == 6) { e.onceperbattle = true; },,,
Queen of Diamonds_downgraded,Do [sword]<d6> damage,2,attack(d);,Harvest,NORMAL,,RED,,,,_damage,0,NO,NO,,,,,,,,,,,,,
Queen of Diamonds_weakened,Do [sword]<d6> damage,1,attack(d);,Harvest,NORMAL,,RED,,,,_damage,0,NO,NO,,,,,,,,,,,,,
Queen of Diamonds_deckupgrade,Do [sword]<d6>. On 5[;] discard this[;]|& enemy gets [gold]1 next turn,2,attack(d); if(d == 5) { jinx(~Queen of Diamonds~|~enemy gets [gold]1 gold~|~Enemy gets [gold]1 gold~|~self.gold++; screenshake(); sfx(\~pickupgold\~);~|self|target|1|1); sfx(~_thinghappens~); },Harvest,NORMAL,,RED,,,,_damage,0,NO,NO,,,,,,,,,,if(d == 5) { e.onceperbattle = true; },,,
Jack of Diamonds,Do [sword]<d6>. On 6[;] discard this[;]|& enemy gets [gold]1 next turn,2,attack(d); if(d == 6) { jinx(~Jack of Diamonds~|~enemy gets [gold]1 gold~|~Enemy gets [gold]1 gold~|~self.gold++; screenshake(); sfx(\~pickupgold\~);~|self|target|1|1); sfx(~_thinghappens~); },Harvest,NORMAL,,RED,reducesize,change_function,,_damage,0,NO,NO,,,,,,,,,,if(d == 6) { e.onceperbattle = true; },,,
Jack of Diamonds_downgraded,Do [sword]<d6> damage,2,attack(d);,Harvest,NORMAL,,RED,,,,_damage,0,NO,NO,,,,,,,,,,,,,
Jack of Diamonds_weakened,Do [sword]<d6> damage,1,attack(d);,Harvest,NORMAL,,RED,,,,_damage,0,NO,NO,,,,,,,,,,,,,
Jack of Diamonds_deckupgrade,Do [sword]<d6>. On 5[;] discard this[;]|& enemy gets [gold]1 next turn,2,attack(d); if(d == 5) { jinx(~Jack of Diamonds~|~enemy gets [gold]1 gold~|~Enemy gets [gold]1 gold~|~self.gold++; screenshake(); sfx(\~pickupgold\~);~|self|target|1|1); sfx(~_thinghappens~); },Harvest,NORMAL,,RED,,,,_damage,0,NO,NO,,,,,,,,,,if(d == 5) { e.onceperbattle = true; },,,
Ace of Diamonds,Do [sword]<d6>. On 6[;] discard this[;]|& enemy gets [gold]1 next turn,2,attack(d); if(d == 6) { jinx(~Ace of Diamonds~|~enemy gets [gold]1 gold~|~Enemy gets [gold]1 gold~|~self.gold++; screenshake(); sfx(\~pickupgold\~);~|self|target|1|1); sfx(~_thinghappens~); } /*yes ace actually stands for 'asexual' but there are only so many cards in a pack of cards*/,Harvest,NORMAL,,RED,reducesize,change_function,,_damage,0,NO,NO,,,,,,,,,,if(d == 6) { e.onceperbattle = true; },,,
Ace of Diamonds_downgraded,Do [sword]<d6> damage,2,attack(d);,Harvest,NORMAL,,RED,,,,_damage,0,NO,NO,,,,,,,,,,,,,
Ace of Diamonds_weakened,Do [sword]<d6> damage,1,attack(d);,Harvest,NORMAL,,RED,,,,_damage,0,NO,NO,,,,,,,,,,,,,
Ace of Diamonds_deckupgrade,Do [sword]<d6>. On 5[;] discard this[;]|& enemy gets [gold]1 next turn,2,attack(d); if(d == 5) { jinx(~Ace of Diamonds~|~enemy gets [gold]1 gold~|~Enemy gets [gold]1 gold~|~self.gold++; screenshake(); sfx(\~pickupgold\~);~|self|target|1|1); sfx(~_thinghappens~); },Harvest,NORMAL,,RED,,,,_damage,0,NO,NO,,,,,,,,,,if(d == 5) { e.onceperbattle = true; },,,
e.name,Do [sword]<d6>. On 6[;] discard this[;]|error an enemy equipment|[80%][gray]''e.fulldescription''[],1,attack(d); if(d == 6) { inflict(~ncr_error~); },Broken Gadget,NORMAL,,GRAY,,,,_damage,0,NO,NO,,,,,,,,,,if(d == 6) { e.onceperbattle = true; },,,
Survivor's Guilt,Do [sword]<d6>[;] get [vanish]1 vanish|[gray](reusable),1,attack(d); inflictself(~ncr_vanish~); sfx(~_vanish~|~~|0.2);  /*this is just tombstone but not*/,Strobe Light,MAX3|FREE1,,PINK,increaserange,change_function,,_damage,-1,NO,NO,,1,,,,,,,,,,,
Survivor's Guilt_downgraded,Do [sword]<d6>[;] get [vanish]1 vanish|[gray](reusable),1,attack(d); inflictself(~ncr_vanish~); sfx(~_vanish~|~~|0.2);,Strobe Light,MAX3,,PINK,,,,_damage,-1,NO,NO,,,,,,,,,,,,,
Red Hot Dagger,Do [sword]<d6>[;] get [fire]1 burn|[gray](reusable),1,attack(d); var oldburn = 0; var oldaltburn = 0; if(self.status.length > 0) { for(stat in self.status) { if(stat.type == ~fire~) { oldburn = stat.value; } if(stat.type == ~alternate_fire~) { oldaltburn = stat.value; } } } inflictself(FIRE); var inflictwhat = ~~; for(stat in self.status) { if(stat.type == ~fire~ && stat.value != oldburn) { inflictwhat = stat.type; } if(stat.type == ~alternate_fire~ && stat.value != oldaltburn) { inflictwhat = stat.type; } } if(inflictwhat != ~~) { var dicelist = []; for(mydice in self.dicepool) { if(mydice.available() && mydice.burn != true && mydice.alternateburn != true) { dicelist.push(mydice); } } if(dicelist.length > 0) { shuffle(dicelist); dicelist[0].animate(inflictwhat); } if(self.status.length > 0) { for(stat in self.status) { if(stat.type == inflictwhat) { stat.value--; } } } },Hellfire,MAX3|FREE1,,RED,increaserange,change_function,,_damage,-1,NO,NO,,1,,,,,,,,,,,
Red Hot Dagger_downgraded,Do [sword]<d6>[;] get [fire]1 burn|[gray](reusable),1,attack(d); var oldburn = 0; var oldaltburn = 0; if(self.status.length > 0) { for(stat in self.status) { if(stat.type == ~fire~) { oldburn = stat.value; } if(stat.type == ~alternate_fire~) { oldaltburn = stat.value; } } } inflictself(FIRE); var inflictwhat = ~~; for(stat in self.status) { if(stat.type == ~fire~ && stat.value != oldburn) { inflictwhat = stat.type; } if(stat.type == ~alternate_fire~ && stat.value != oldaltburn) { inflictwhat = stat.type; } } if(inflictwhat != ~~) { var dicelist = []; for(mydice in self.dicepool) { if(mydice.available() && mydice.burn != true && mydice.alternateburn != true) { dicelist.push(mydice); } } if(dicelist.length > 0) { shuffle(dicelist); dicelist[0].animate(inflictwhat); } if(self.status.length > 0) { for(stat in self.status) { if(stat.type == inflictwhat) { stat.value--; } } } },Hellfire,MAX3,,RED,,,,_damage,-1,NO,NO,,,,,,,,,,,,,
Really Cold Dagger,Do [sword]<d6>[;] get [ice]1 freeze|[gray](Reuseable)|[80%][gray]''Uhh what's the downside here''[],1,attack(d); var oldfreeze = 0; var oldaltfreeze = 0; if(self.status.length > 0) { for(stat in self.status) { if(stat.type == ~ice~) { oldfreeze = stat.value; } if(stat.type == ~alternate_ice~) { oldaltfreeze = stat.value; } } } inflictself(ICE); var inflictwhat = ~~; for(stat in self.status) { if(stat.type == ~ice~ && stat.value != oldfreeze) { inflictwhat = stat.type; } if(stat.type == ~alternate_ice~ && stat.value != oldaltfreeze) { inflictwhat = stat.type; } } if(inflictwhat == ~ice~) { var dicelist = []; for(mydice in self.dicepool) { if(mydice.available() && mydice.burn != true && mydice.animateburn != true) { dicelist.push(mydice); } } if(dicelist.length > 0) { dicelist.sort(function(a|b) return -1 * (a.basevalue - b.basevalue)); dicelist[0].animate(~ice~); } } if(inflictwhat == ~alternate_ice~) { for(mydice in self.dicepool) { if(mydice.available() && mydice.burn != true && mydice.animateburn != true) { mydice.animate(~alternate_ice~); } } } if(self.status.length > 0) { for(stat in self.status) { if(stat.type == inflictwhat) { stat.value--; } } },Arctic Storm,MAX3|FREE1,,BRIGHTCYAN,increaserange,change_function,,_damage,-1,NO,NO,hidereuseable,1,,,,,,,,,,,
Really Cold Dagger_downgraded,Do [sword]<d6>[;] get [ice]1 freeze|[gray](Reuseable)|[80%][gray]''Uhh what's the downside here''[],1,attack(d); var oldfreeze = 0; var oldaltfreeze = 0; if(self.status.length > 0) { for(stat in self.status) { if(stat.type == ~ice~) { oldfreeze = stat.value; } if(stat.type == ~alternate_ice~) { oldaltfreeze = stat.value; } } } inflictself(ICE); var inflictwhat = ~~; for(stat in self.status) { if(stat.type == ~ice~ && stat.value != oldfreeze) { inflictwhat = stat.type; } if(stat.type == ~alternate_ice~ && stat.value != oldaltfreeze) { inflictwhat = stat.type; } } if(inflictwhat == ~ice~) { var dicelist = []; for(mydice in self.dicepool) { if(mydice.available() && mydice.burn != true && mydice.animateburn != true) { dicelist.push(mydice); } } if(dicelist.length > 0) { dicelist.sort(function(a|b) return -1 * (a.basevalue - b.basevalue)); dicelist[0].animate(~ice~); } } if(inflictwhat == ~alternate_ice~) { for(mydice in self.dicepool) { if(mydice.available() && mydice.burn != true && mydice.animateburn != true) { mydice.animate(~alternate_ice~); } } } if(self.status.length > 0) { for(stat in self.status) { if(stat.type == inflictwhat) { stat.value--; } } },Arctic Storm,MAX3,,BRIGHTCYAN,,,,_damage,-1,NO,NO,hidereuseable,,,,,,,,,,,,
Bizarro Blade,Do [sword]<d6> + 2 damage[;] but|get [confuse]Confused every turn,1,attack(d + 2);,Rubber Bullet,NORMAL,,GRAY,change_power,change_function,confuse,_damage,0,NO,NO,excludefromrandomlists,,,inflictself(CONFUSE); for(stat in self.status) { if(stat.type == ~confuse~ # stat.type == ~alternate_confuse~) { stat.remove_at_startturn = false; stat.remove_at_endturn = false; } },,,,if(getstatusself(CONFUSE) < 1) { inflictself(CONFUSE); for(stat in self.status) { if(stat.type == ~confuse~ # stat.type == ~alternate_confuse~) { stat.remove_at_endturn = false; } } },,,,,
Bizarro Blade_downgraded,Do [sword]<d6> damage[;] but|get [confuse]Confused every turn,1,attack(d);,Rubber Bullet,NORMAL,,GRAY,,,,_damage,0,NO,NO,excludefromrandomlists,,,inflictself(CONFUSE); for(stat in self.status) { if(stat.type == ~confuse~ # stat.type == ~alternate_confuse~) { stat.remove_at_startturn = false; stat.remove_at_endturn = false; } },,,,if(getstatusself(CONFUSE) < 1) { inflictself(CONFUSE); for(stat in self.status) { if(stat.type == ~confuse~ # stat.type == ~alternate_confuse~) { stat.remove_at_endturn = false; } } },,,,,
Bizarro Blade_upgraded,Do [sword]<d6> damage[;] but|get [confuse]Confused every turn,1,attack(d);,Rubber Bullet,NORMAL|FREE2,,GRAY,,,,_damage,0,NO,NO,excludefromrandomlists,,,inflictself(CONFUSE); for(stat in self.status) { if(stat.type == ~confuse~ # stat.type == ~alternate_confuse~) { stat.remove_at_startturn = false; stat.remove_at_endturn = false; } },,,,if(getstatusself(CONFUSE) < 1) { inflictself(CONFUSE); for(stat in self.status) { if(stat.type == ~confuse~ # stat.type == ~alternate_confuse~) { stat.remove_at_endturn = false; } } },,,,,
Bizarro Blade?,Do [sword]<d6> damage[;] but|get [confuse]Confused every turn,1,attack(d);,Rubber Bullet,NORMAL|FREE2,,GRAY,change_power,change_function,,_damage,0,NO,NO,alternateversion|excludefromrandomlists,,,inflictself(CONFUSE); for(stat in self.status) { if(stat.type == ~confuse~ # stat.type == ~alternate_confuse~) { stat.remove_at_startturn = false; stat.remove_at_endturn = false; } },,,,if(getstatusself(CONFUSE) < 1) { inflictself(CONFUSE); for(stat in self.status) { if(stat.type == ~confuse~ # stat.type == ~alternate_confuse~) { stat.remove_at_endturn = false; } } },,,,,
Bizarro Blade?_downgraded,Do [sword]<d6> damage[;] but|get [confuse]Confused every turn,1,attack(d);,Rubber Bullet,NORMAL,,GRAY,,,,_damage,0,NO,NO,alternateversion|excludefromrandomlists,,,inflictself(CONFUSE); for(stat in self.status) { if(stat.type == ~confuse~ # stat.type == ~alternate_confuse~) { stat.remove_at_startturn = false; stat.remove_at_endturn = false; } },,,,if(getstatusself(CONFUSE) < 1) { inflictself(CONFUSE); for(stat in self.status) { if(stat.type == ~confuse~ # stat.type == ~alternate_confuse~) { stat.remove_at_endturn = false; } } },,,,,
Bizarro Blade?_upgraded,Do [sword]<d6> damage[;] but|get [confuse]Confused every turn,1,attack(d);,Rubber Bullet,NORMAL|FREE3,,GRAY,,,,_damage,0,NO,NO,alternateversion|excludefromrandomlists,,,inflictself(CONFUSE); for(stat in self.status) { if(stat.type == ~confuse~ # stat.type == ~alternate_confuse~) { stat.remove_at_startturn = false; stat.remove_at_endturn = false; } },,,,if(getstatusself(CONFUSE) < 1) { inflictself(CONFUSE); for(stat in self.status) { if(stat.type == ~confuse~ # stat.type == ~alternate_confuse~) { stat.remove_at_endturn = false; } } },,,,,
gimme a solo,bewreworewoiejfwkenewiowwoww,1,Gadget.givegadget(self|~Guitar Solo~); /*i'm keeping this in here because apparently it made jacke crack up*/,Time Stop,NORMAL,,PINK,,,,none,0,YES,NO,excludefromrandomlists|testitem,,,,,,,,,,,,
Charity,Recover [heal]<d6> health|(Turn start: [heal]2 for enemy),1,attackself(-d); /*i'm not actually christian but i think that under the intolerance and extremity; christian morals were built on legitimate moral foundation; and the idea of thematic equipment corresponding to the virtues/sins intrigues me*/,Trinity,NORMAL,,YELLOW,change_power,change_function,,_heal,0,YES,NO,,,,,,,e.animate(~flashandshake~); attack(-2); sfx(~_heal~);,,,,,,
Charity_upgraded,Recover [heal]<d6> health|(Turn start: [heal]3 for enemy),1,attackself(-d);,Trinity,NORMAL|FREE2,,YELLOW,,,,_heal,0,YES,NO,,,,,,,e.animate(~flashandshake~); attack(-3); sfx(~_heal~);,,,,,,
Charity_downgraded,Recover [heal]<d6> health|(Turn start: [heal]2 for enemy),1,attackself(-d);,Trinity,MAX4,,YELLOW,,,,_heal,0,YES,NO,,,,,,,e.animate(~flashandshake~); attack(-2); sfx(~_heal~);,,,,,,
Humility,Next turn: get [weaken]2 weaken[;]|but recover [heal]<d6> health,1,jinx(~Humility~|~ get [weaken]2 weaken[;] heal [heal]%VAR%~|~ get [weaken]2 weaken[;] heal [heal]%VAR%~|~inflict(\~weaken\~|2); sfx(\~_heal\~); attack(-%VAR%); if(self.dicepool.length > 0) { self.applyequipmentcurses(); }~|self|self|1|d);,Trinity,NORMAL|FREE1,,YELLOW,change_power,change_function,,_thinghappens,0,YES,NO,,1,,,,,,,,,,,
Humility_upgraded,Next turn: get [weaken]1 weaken[;]|but recover [heal]<d6> health,1,jinx(~Humility~|~ get [weaken]1 weaken[;] heal [heal]%VAR%~|~ get [weaken]1 weaken[;] heal [heal]%VAR%~|~inflict(\~weaken\~|1); sfx(\~_heal\~); attack(-%VAR%); if(self.dicepool.length > 0) { self.applyequipmentcurses(); }~|self|self|1|d);,Trinity,NORMAL|FREE1,,YELLOW,,,,_thinghappens,0,YES,NO,,,,,,,,,,,,,
Humility_downgraded,Next turn: get [weaken]2 weaken[;]|but recover [heal]<d6> health,1,jinx(~Humility~|~ get [weaken]2 weaken[;] heal [heal]%VAR%~|~ get [weaken]2 weaken[;] heal [heal]%VAR%~|~inflict(\~weaken\~|2); sfx(\~_heal\~); attack(-%VAR%); if(self.dicepool.length > 0) { self.applyequipmentcurses(); }~|self|self|1|d);,Trinity,MAX4|FREE1,,YELLOW,,,,_thinghappens,0,YES,NO,,,,,,,,,,,,,
Patience,Recover [heal]10 health|every 3 turns,1,attackself(-10);,Trinity,,,YELLOW,change_power,change_function,,_heal,0,YES,NO,,,,,,,if((turn != 1) && (turn % 3 == 0)) { e.animate(~flashandshake~); e.doequipmentaction(self|target|-e.castdirection|[]|0|false); },,,,,,
Patience_upgraded,Recover [heal]14 health|every 3 turns,1,attackself(-14);,Trinity,,,YELLOW,,,,_heal,0,YES,NO,,,,,,,if((turn != 1) && (turn % 3 == 0)) { e.animate(~flashandshake~); e.doequipmentaction(self|target|-e.castdirection|[]|0|false); },,,,,,
Patience_downgraded,Recover [heal]7 health|every 3 turns,1,attackself(-7);,Trinity,,,YELLOW,,,,_heal,0,YES,NO,,,,,,,if((turn != 1) && (turn % 3 == 0)) { e.animate(~flashandshake~); e.doequipmentaction(self|target|-e.castdirection|[]|0|false); },,,,,,
Temperance,If you don't do damage|this turn[;] recover [heal]10|[gray](once per battle),1,,Trinity,,,YELLOW,change_power,change_function,,_heal,0,YES,YES,,1,,,,self.setvar(~temperanceenemyhp~|target.hp);,,if(self.getvar(~temperanceenemyhp~) == target.hp) { attackself(-10); sfx(~_heal~); e.usedthisbattle = true; },,,,,
Temperance_upgraded,If you don't do damage|this turn[;] recover [heal]15|[gray](once per battle),1,,Trinity,,,YELLOW,,,,_heal,0,YES,YES,,,,,,self.setvar(~temperanceenemyhp~|target.hp);,,if(self.getvar(~temperanceenemyhp~) == target.hp) { attackself(-15); sfx(~_heal~); e.usedthisbattle = true; },,,,,
Temperance_downgraded,If you don't do damage|this turn[;] recover [heal]7|[gray](once per battle),1,,Trinity,,,YELLOW,,,,_heal,0,YES,YES,,,,,,self.setvar(~temperanceenemyhp~|target.hp);,,if(self.getvar(~temperanceenemyhp~) == target.hp) { attackself(-7); sfx(~_heal~); e.usedthisbattle = true; },,,,,
Hope,At the end of this battle[;]|recover [heal]20 health|[gray](once per battle),1,e.setvar(~hopehealall~|20);,Trinity,COUNTDOWN,30,YELLOW,change_power,change_function,,_heal,0,YES,YES,excludefromrandomlists,,,,if(e.getvar(~hopehealall~) != 0) { self.hp += e.getvar(~hopehealall~); if(self.hp > self.maxhp) { self.hp = self.maxhp; } sfx(~_heal~); e.setvar(~hopehealall~|0); } else { trace(~nope~); },,,,,,,,
Hope_upgraded,At the end of this battle[;]|recover [heal]30 health|[gray](once per battle),1,e.setvar(~hopehealall~|30);,Trinity,COUNTDOWN,30,YELLOW,,,,_heal,0,YES,YES,excludefromrandomlists,,,,if(e.getvar(~hopehealall~) != 0) { self.hp += e.getvar(~hopehealall~); if(self.hp > self.maxhp) { self.hp = self.maxhp; } sfx(~_heal~); e.setvar(~hopehealall~|0); } else { trace(~nope~); },,,,,,,,
Hope_downgraded,At the end of this battle[;]|recover [heal]10 health|[gray](once per battle),1,e.setvar(~hopehealall~|10);,Trinity,COUNTDOWN,30,YELLOW,,,,_heal,0,YES,YES,excludefromrandomlists,,,,if(e.getvar(~hopehealall~) != 0) { self.hp += e.getvar(~hopehealall~); if(self.hp > self.maxhp) { self.hp = self.maxhp; } sfx(~_heal~); e.setvar(~hopehealall~|0); } else { trace(~nope~); },,,,,,,,
Wrath,Do [fire]<triple> damage[;] but|lose [heart]<d6> max HP & health|[gray](once per battle),1,attack(3 * d|FIRE); sfxdamage(target|3 * d); self.maxhp -= d; if(self.maxhp < 0) { self.maxhp = 0; } pierceattackself(d); if(self.hp > self.maxhp) { self.hp = self.maxhp; },Pure Evil,NORMAL,,GRAY,change_power,change_function,,_fire,0,NO,YES,,,self.maxhp -= d; if(self.maxhp < 0) { self.maxhp = 0; } pierceattackself(d); if(self.hp > self.maxhp) { self.hp = self.maxhp; },,,,,,,,,,
Wrath_upgraded,Do [fire]<quadruple> damage[;] but|lose [heart]<d6> max HP & health|[gray](once per battle),1,attack(4 * d|FIRE); sfxdamage(target|3 * d); self.maxhp -= d; if(self.maxhp < 0) { self.maxhp = 0; } pierceattackself(d); if(self.hp > self.maxhp) { self.hp = self.maxhp; },Pure Evil,NORMAL,,GRAY,,,,_fire,0,NO,YES,,,self.maxhp -= d; if(self.maxhp < 0) { self.maxhp = 0; } pierceattackself(d); if(self.hp > self.maxhp) { self.hp = self.maxhp; },,,,,,,,,,
Wrath_downgraded,Do [fire]<double> damage[;] but|lose [heart]<d6> max HP & health|[gray](once per battle),1,attack(2 * d|FIRE); sfxdamage(target|3 * d); self.maxhp -= d; if(self.maxhp < 0) { self.maxhp = 0; } pierceattackself(d); if(self.hp > self.maxhp) { self.hp = self.maxhp; },Pure Evil,NORMAL,,GRAY,,,,_fire,0,NO,YES,,,self.maxhp -= d; if(self.maxhp < 0) { self.maxhp = 0; } pierceattackself(d); if(self.hp > self.maxhp) { self.hp = self.maxhp; },,,,,,,,,,
Frail Bat,Do [sword]<quadruple> damage[;]|destroy this immediately,2,attack(d * 4); sfxdamage(target|d * 4); if(self.layout == ~DECK~) { var deleteindex = -1; for(i in 0...Deck.getcards(~all~).length) if(Deck.getcards(~all~)[i].equipment == e) { deleteindex = i; break; } Deck.getcards(~all~)[deleteindex].delete(); } else { e.name = ~ncrsaysremoveme~; removeequipment(~ncrsaysremoveme~); },Bubble Gun,NORMAL,,RED,reducesize,change_power,,jester_delete,0,NO,YES,excludefromrandomlists|cannotreuse,,,,,,,,,,,e.preventdefault = true; e.maintainfury = true,
Frail Bat_weakened,Do [sword]<triple> damage[;]|destroy this immediately,1,attack(d * 3); sfxdamage(target|d * 3); if(self.layout == ~DECK~) { var deleteindex = -1; for(i in 0...Deck.getcards(~all~).length) if(Deck.getcards(~all~)[i].equipment == e) { deleteindex = i; break; } Deck.getcards(~all~)[deleteindex].delete(); } else { e.name = ~ncrsaysremoveme~; removeequipment(~ncrsaysremoveme~); },Bubble Gun,NORMAL,,RED,,,,jester_delete,0,NO,YES,excludefromrandomlists|cannotreuse,,,,,,,,,,,e.preventdefault = true; e.maintainfury = true,
Frail Bat_downgraded,Do [sword]<triple> damage[;]|destroy this immediately,2,attack(d * 3); sfxdamage(target|d * 3); if(self.layout == ~DECK~) { var deleteindex = -1; for(i in 0...Deck.getcards(~all~).length) if(Deck.getcards(~all~)[i].equipment == e) { deleteindex = i; break; } Deck.getcards(~all~)[deleteindex].delete(); } else { e.name = ~ncrsaysremoveme~; removeequipment(~ncrsaysremoveme~); },Bubble Gun,NORMAL,,RED,,,,jester_delete,0,NO,YES,excludefromrandomlists|cannotreuse,,,,,,,,,,,e.preventdefault = true; e.maintainfury = true,
Frail Bat_deckupgrade,Do [sword]<quintuple> damage[;]|destroy this immediately,2,attack(d * 5); sfxdamage(target|d * 5); if(self.layout == ~DECK~) { var deleteindex = -1; for(i in 0...Deck.getcards(~all~).length) if(Deck.getcards(~all~)[i].equipment == e) { deleteindex = i; break; } Deck.getcards(~all~)[deleteindex].delete(); } else { e.name = ~ncrsaysremoveme~; removeequipment(~ncrsaysremoveme~); },Bubble Gun,NORMAL,,RED,,,,jester_delete,0,NO,YES,excludefromrandomlists|cannotreuse,,,,,,,,,,,e.preventdefault = true; e.maintainfury = true,
Hall of Busters,[]+1 dice[;] immune to errors|[gray](Objectively correct option)[],1,if(!simulation) { self.extradice++; } else { bonus(1000); },Focus,REQUIRE6,,GRAY,change_power,doublerequirements,,magic_gaindice,0,YES,NO,errorimmune,,,,,,,,,,,,
Hall of Busters_upgraded,[]+1 dice[;] immune to errors|[gray](Objectively correct option)[],1,if(!simulation) { self.extradice++; } else { bonus(1000); },Focus,EVEN,,GRAY,,,,magic_gaindice,0,YES,NO,errorimmune,,,,,,,,,,,,
Ultimai,Do [sword]<double>[;] or 4x on jackpot|[gray](Reuseable)[] [gray](Wrong)[],1,if (self.roll_jackpot > 0){ attack(d * 4); sfxdamage(target|d * 4); } else { attack(d * 2); sfxdamage(target|d * 2); } /*this is actually not very good compared to HoB since robot doesn't get 1s regularly the way uptick thief does. upgrade makes up for it though - 8 damage on a 2 when on jackpot; come on*/,Steal,REQUIRE1,,YELLOW,change_power,,,none,-1,NO,NO,hidereuseable,,,,,,,,,,,,
Ultimai_upgraded,Do [sword]<double>[;] or 4x on jackpot|[gray](Reuseable)[] [gray](Wrong)[],1,if (self.roll_jackpot > 0){ attack(d * 4); sfxdamage(target|d * 4); } else { attack(d * 2); sfxdamage(target|d * 2); },Steal,MAX2,,YELLOW,,,,none,-1,NO,NO,hidereuseable,,,,,,,,,,,,
Ultimai_downgraded,Do [sword]<d6>[;] or 2x on jackpot|[gray](Reuseable)[] [gray](Wrong)[],1,if (self.roll_jackpot > 0){ attack(d * 2); sfxdamage(target|d * 2); } else { attack(d); sfxdamage(target|d); },Steal,REQUIRE1,,YELLOW,,,,none,-1,NO,NO,hidereuseable,,,,,,,,,,,,
Harvest Scythe@notwitch,Consume card in slot <d6>|to do [sword]<quadruple> damage,1,var mult = 4; if(self.getskillcard() != null && self.getskillcard().skillcard == ~witch~) { self.textparticle(~how'd witch get this~); if(!Spellbook.isempty(d)) { self.textparticle(~No effect!~); sfxdamage(target|mult * d); attack(mult * d); Spellbook.erase(d); } } else { if(self.layout == ~DECK~) { if(d - 1 > Deck.gethandsize()) { self.textparticle(~No effect!~); } else { if(Deck.getcard(d - 1) != null) { sfxdamage(target|mult * d); attack(mult * d); Deck.getcard(d - 1).delete(); sfx(~jester_delete~); } else { self.textparticle(~No effect!~); } } } else { if(self.equipment.length >= d) { if(self.equipment[d - 1].skillcard == ~~) { self.equipment[d - 1].animate(~curse~); self.equipment[d - 1].name = ~ncrsaysdeleteme~; sfx(~jester_delete~); sfxdamage(target|mult * d); attack(mult * d); } else { self.textparticle(~No effect!~); } } else { self.textparticle(~No effect!~); } } },Less Fluff,NORMAL,,ORANGE,change_power,complicate,,none,0,NO,NO,excludefromrandomlists,,if(self.getskillcard() != null && self.getskillcard().skillcard == ~witch~) { self.textparticle(~how'd witch get this~); if(!Spellbook.isempty(d)) { self.textparticle(~No effect!~); Spellbook.erase(d); } } else { if(self.layout == ~DECK~) { if(d - 1 > Deck.gethandsize()) { self.textparticle(~No effect!~); } else { if(Deck.getcard(d - 1) != null) { Deck.getcard(d - 1).delete(); sfx(~jester_delete~); } else { self.textparticle(~No effect!~); } } } else { if(self.equipment.length >= d) { if(self.equipment[d - 1].skillcard == ~~) { self.equipment[d - 1].animate(~curse~); self.equipment[d - 1].name = ~ncrsaysdeleteme~; sfx(~jester_delete~); } else { self.textparticle(~No effect!~); } } else { self.textparticle(~No effect!~); } } },,,,,,,,,,
Harvest Scythe@notwitch_upgraded,Consume card in slot <d6>|to do [sword]<quintuple> damage,1,var mult = 5; if(self.getskillcard() != null && self.getskillcard().skillcard == ~witch~) { self.textparticle(~how'd witch get this~); if(!Spellbook.isempty(d)) { self.textparticle(~No effect!~); sfxdamage(target|mult * d); attack(mult * d); Spellbook.erase(d); } } else { if(self.layout == ~DECK~) { if(d - 1 > Deck.gethandsize()) { self.textparticle(~No effect!~); } else { if(Deck.getcard(d - 1) != null) { sfxdamage(target|mult * d); attack(mult * d); Deck.getcard(d - 1).delete(); sfx(~jester_delete~); } else { self.textparticle(~No effect!~); } } } else { if(self.equipment.length >= d) { if(self.equipment[d - 1].skillcard == ~~) { self.equipment[d - 1].animate(~curse~); self.equipment[d - 1].name = ~ncrsaysdeleteme~; sfx(~jester_delete~); sfxdamage(target|mult * d); attack(mult * d); } else { self.textparticle(~No effect!~); } } else { self.textparticle(~No effect!~); } } },Less Fluff,NORMAL,,ORANGE,,,,none,0,NO,NO,excludefromrandomlists,,if(self.getskillcard() != null && self.getskillcard().skillcard == ~witch~) { self.textparticle(~how'd witch get this~); if(!Spellbook.isempty(d)) { self.textparticle(~No effect!~); Spellbook.erase(d); } } else { if(self.layout == ~DECK~) { if(d - 1 > Deck.gethandsize()) { self.textparticle(~No effect!~); } else { if(Deck.getcard(d - 1) != null) { Deck.getcard(d - 1).delete(); sfx(~jester_delete~); } else { self.textparticle(~No effect!~); } } } else { if(self.equipment.length >= d) { if(self.equipment[d - 1].skillcard == ~~) { self.equipment[d - 1].animate(~curse~); self.equipment[d - 1].name = ~ncrsaysdeleteme~; sfx(~jester_delete~); } else { self.textparticle(~No effect!~); } } else { self.textparticle(~No effect!~); } } },,,,,,,,,,
Lunasa@notwitch,Replace the card in slot <slotdoubles>|with a random card,1,for(eq in self.equipment) { trace(eq.name); trace(eq.row); trace(eq.column); } if(self.getskillcard() != null && self.getskillcard().skillcard == ~witch~) {   self.textparticle(~how'd witch get this~);   Spellbook.changespellflash(d| rand(Spellbook.getspelllist()));  } else {    if(self.layout == ~DECK~) {    var exceptions = [~skillcard~|~excludefromrandomlists~|~alternateversion~|~robotonly~|~witchonly~|~inventoronly~|~onceperbattle~]; if(self.usecpuinsteadofdice) exceptions.remove(~robotonly~); if(self.getskillcard().skillcard == ~witch~) exceptions.remove(~witchonly~); if(self.getskillcard() != null && self.getskillcard().skillcard == ~inventor~) exceptions.remove(~inventoronly~); var neweq = new elements.Equipment(rand(getequipmentlist(null|[]|exceptions)));    var xlist = [];    var epos = 0;    var cardtochange = ~nope~;    for(i in 0...(Deck.gethandsize() - 1)) {     if(Deck.getcard(i) != null) {      xlist.push(Deck.getcard(i).equipment.x);     }    }    trace(1);    for(xx in xlist) {     if(e.x < xx) { break; }     else { epos++; }     }     trace(epos);    trace(d - 1);    if(d - 1 == epos) {     trace(~a~);     e.setvar(~changeme~|1);    }     if(d - 1 < epos) {     trace(~b~);     if(Deck.getcard(d - 1) == null) { self.textparticle(~No effect!~); } else {     Deck.getcard(d - 1).equipment.setvar(~changeme~|1); }    }    if(d - 1 > epos) {     trace(~c~);     if(Deck.getcard(d - 2) == null) { self.textparticle(~No effect!~); } else {     Deck.getcard(d - 2).equipment.setvar(~changeme~|1); }    }    trace(2);    for(mycard in Deck.getcards(~all~)) {     if(mycard.equipment.getvar(~changeme~) == 1) {      trace(mycard.equipment.name); cardtochange = mycard; break;     }    }    trace(3); if(cardtochange != ~nope~) {     neweq.row = cardtochange.equipment.row; neweq.column = cardtochange.equipment.column; neweq.x = cardtochange.equipment.x;     neweq.y = cardtochange.equipment.y;     trace(cardtochange.equipment.name);     cardtochange.equipment = neweq;     trace(cardtochange.equipment.name);     var dobefcombscript = new elements.Skill(~Trinity~);     dobefcombscript.script = neweq.scriptbeforecombat;     dobefcombscript.execute(self|target);     var dobefturnscript = new elements.Skill(~Against all odds_old~);     dobefturnscript.script = neweq.scriptbeforestartturn;     dobefturnscript.execute(self|target); var doonturnscript = new elements.Skill(~Against all odds_old~); doonturnscript.script = neweq.scriptonstartturn; doonturnscript.execute(self|target);     neweq.animate(~flashandshake~);    }   } else {    if(self.equipment.length >= d) {     if(self.equipment[d - 1].skillcard == ~~) {      var smallorlarge = ~small~;      if(self.equipment[d - 1].size > 1) {       smallorlarge = ~large~;      }    var exceptions = [~skillcard~|~excludefromrandomlists~|~alternateversion~|~robotonly~|~witchonly~|~inventoronly~|~onceperbattle~]; if(self.usecpuinsteadofdice) exceptions.remove(~robotonly~); if(self.getskillcard().skillcard == ~witch~) exceptions.remove(~witchonly~); if(self.getskillcard() != null && self.getskillcard().skillcard == ~inventor~) exceptions.remove(~inventoronly~);  var neweq = new elements.Equipment(rand(getequipmentlist(null|[smallorlarge]|exceptions)));      neweq.row = self.equipment[d - 1].row; neweq.column = self.equipment[d - 1].column; neweq.x = self.equipment[d - 1].x;      neweq.y = self.equipment[d - 1].y;      self.equipment[d - 1] = neweq;      var dobefcombscript = new elements.Skill(~Against all odds_old~);      dobefcombscript.script = neweq.scriptbeforecombat;      dobefcombscript.execute(self|target);      var dobefturnscript = new elements.Skill(~Against all odds_old~);      dobefturnscript.script = neweq.scriptbeforestartturn;      dobefturnscript.execute(self|target); var doonturnscript = new elements.Skill(~Against all odds_old~); doonturnscript.script = neweq.scriptonstartturn; doonturnscript.execute(self|target);      neweq.animate(~flashandshake~);     } else {      self.textparticle(~No effect!~);     }    } else {     self.textparticle(~No effect!~);    }   }  } trace(~--~); for(eq in self.equipment) { trace(eq.name); trace(eq.row); trace(eq.column); },Emulator,DOUBLES|DOUBLES,,ORANGE,change_power,change_power,,_thinghappens,0,YES,NO,excludefromrandomlists,,,,,,trace(~!!!~); for(eq in self.equipment) { trace(eq.name); trace(eq.row); trace(eq.column); },,,,,,
Lunasa@notwitch_upgraded,Replace the card in slot <d6>|with a random card,1,for(eq in self.equipment) { trace(eq.name); trace(eq.row); trace(eq.column); } if(self.getskillcard() != null && self.getskillcard().skillcard == ~witch~) {   self.textparticle(~how'd witch get this~);   Spellbook.changespellflash(d| rand(Spellbook.getspelllist()));  } else {    if(self.layout == ~DECK~) {    var exceptions = [~skillcard~|~excludefromrandomlists~|~alternateversion~|~robotonly~|~witchonly~|~inventoronly~|~onceperbattle~]; if(self.usecpuinsteadofdice) exceptions.remove(~robotonly~); if(self.getskillcard().skillcard == ~witch~) exceptions.remove(~witchonly~); if(self.getskillcard() != null && self.getskillcard().skillcard == ~inventor~) exceptions.remove(~inventoronly~); var neweq = new elements.Equipment(rand(getequipmentlist(null|[]|exceptions)));    var xlist = [];    var epos = 0;    var cardtochange = ~nope~;    for(i in 0...(Deck.gethandsize() - 1)) {     if(Deck.getcard(i) != null) {      xlist.push(Deck.getcard(i).equipment.x);     }    }    trace(1);    for(xx in xlist) {     if(e.x < xx) { break; }     else { epos++; }     }     trace(epos);    trace(d - 1);    if(d - 1 == epos) {     trace(~a~);     e.setvar(~changeme~|1);    }     if(d - 1 < epos) {     trace(~b~);     if(Deck.getcard(d - 1) == null) { self.textparticle(~No effect!~); } else {     Deck.getcard(d - 1).equipment.setvar(~changeme~|1); }    }    if(d - 1 > epos) {     trace(~c~);     if(Deck.getcard(d - 2) == null) { self.textparticle(~No effect!~); } else {     Deck.getcard(d - 2).equipment.setvar(~changeme~|1); }    }    trace(2);    for(mycard in Deck.getcards(~all~)) {     if(mycard.equipment.getvar(~changeme~) == 1) {      trace(mycard.equipment.name); cardtochange = mycard; break;     }    }    trace(3); if(cardtochange != ~nope~) {     neweq.row = cardtochange.equipment.row; neweq.column = cardtochange.equipment.column; neweq.x = cardtochange.equipment.x;     neweq.y = cardtochange.equipment.y;     trace(cardtochange.equipment.name);     cardtochange.equipment = neweq;     trace(cardtochange.equipment.name);     var dobefcombscript = new elements.Skill(~Trinity~);     dobefcombscript.script = neweq.scriptbeforecombat;     dobefcombscript.execute(self|target);     var dobefturnscript = new elements.Skill(~Against all odds_old~);     dobefturnscript.script = neweq.scriptbeforestartturn;     dobefturnscript.execute(self|target); var doonturnscript = new elements.Skill(~Against all odds_old~); doonturnscript.script = neweq.scriptonstartturn; doonturnscript.execute(self|target);     neweq.animate(~flashandshake~);    }   } else {    if(self.equipment.length >= d) {     if(self.equipment[d - 1].skillcard == ~~) {      var smallorlarge = ~small~;      if(self.equipment[d - 1].size > 1) {       smallorlarge = ~large~;      }    var exceptions = [~skillcard~|~excludefromrandomlists~|~alternateversion~|~robotonly~|~witchonly~|~inventoronly~|~onceperbattle~]; if(self.usecpuinsteadofdice) exceptions.remove(~robotonly~); if(self.getskillcard().skillcard == ~witch~) exceptions.remove(~witchonly~); if(self.getskillcard() != null && self.getskillcard().skillcard == ~inventor~) exceptions.remove(~inventoronly~);  var neweq = new elements.Equipment(rand(getequipmentlist(null|[smallorlarge]|exceptions)));      neweq.row = self.equipment[d - 1].row; neweq.column = self.equipment[d - 1].column; neweq.x = self.equipment[d - 1].x;      neweq.y = self.equipment[d - 1].y;      self.equipment[d - 1] = neweq;      var dobefcombscript = new elements.Skill(~Against all odds_old~);      dobefcombscript.script = neweq.scriptbeforecombat;      dobefcombscript.execute(self|target);      var dobefturnscript = new elements.Skill(~Against all odds_old~);      dobefturnscript.script = neweq.scriptbeforestartturn;      dobefturnscript.execute(self|target); var doonturnscript = new elements.Skill(~Against all odds_old~); doonturnscript.script = neweq.scriptonstartturn; doonturnscript.execute(self|target);      neweq.animate(~flashandshake~);     } else {      self.textparticle(~No effect!~);     }    } else {     self.textparticle(~No effect!~);    }   }  } trace(~--~); for(eq in self.equipment) { trace(eq.name); trace(eq.row); trace(eq.column); },Emulator,NORMAL,,ORANGE,,,,_thinghappens,0,YES,NO,excludefromrandomlists,,,,,,trace(~!!!~); for(eq in self.equipment) { trace(eq.name); trace(eq.row); trace(eq.column); },,,,,,
Lunasa@notwitch_downgraded,Replace the card in slot 1|with a random card,1,var d = 1; for(eq in self.equipment) { trace(eq.name); trace(eq.row); trace(eq.column); } if(self.getskillcard() != null && self.getskillcard().skillcard == ~witch~) {   self.textparticle(~how'd witch get this~);   Spellbook.changespellflash(d| rand(Spellbook.getspelllist()));  } else {    if(self.layout == ~DECK~) {    var exceptions = [~skillcard~|~excludefromrandomlists~|~alternateversion~|~robotonly~|~witchonly~|~inventoronly~|~onceperbattle~]; if(self.usecpuinsteadofdice) exceptions.remove(~robotonly~); if(self.getskillcard().skillcard == ~witch~) exceptions.remove(~witchonly~); if(self.getskillcard() != null && self.getskillcard().skillcard == ~inventor~) exceptions.remove(~inventoronly~); var neweq = new elements.Equipment(rand(getequipmentlist(null|[]|exceptions)));    var xlist = [];    var epos = 0;    var cardtochange = ~nope~;    for(i in 0...(Deck.gethandsize() - 1)) {     if(Deck.getcard(i) != null) {      xlist.push(Deck.getcard(i).equipment.x);     }    }    trace(1);    for(xx in xlist) {     if(e.x < xx) { break; }     else { epos++; }     }     trace(epos);    trace(d - 1);    if(d - 1 == epos) {     trace(~a~);     e.setvar(~changeme~|1);    }     if(d - 1 < epos) {     trace(~b~);     if(Deck.getcard(d - 1) == null) { self.textparticle(~No effect!~); } else {     Deck.getcard(d - 1).equipment.setvar(~changeme~|1); }    }    if(d - 1 > epos) {     trace(~c~);     if(Deck.getcard(d - 2) == null) { self.textparticle(~No effect!~); } else {     Deck.getcard(d - 2).equipment.setvar(~changeme~|1); }    }    trace(2);    for(mycard in Deck.getcards(~all~)) {     if(mycard.equipment.getvar(~changeme~) == 1) {      trace(mycard.equipment.name); cardtochange = mycard; break;     }    }    trace(3); if(cardtochange != ~nope~) {     neweq.row = cardtochange.equipment.row; neweq.column = cardtochange.equipment.column; neweq.x = cardtochange.equipment.x;     neweq.y = cardtochange.equipment.y;     trace(cardtochange.equipment.name);     cardtochange.equipment = neweq;     trace(cardtochange.equipment.name);     var dobefcombscript = new elements.Skill(~Trinity~);     dobefcombscript.script = neweq.scriptbeforecombat;     dobefcombscript.execute(self|target);     var dobefturnscript = new elements.Skill(~Against all odds_old~);     dobefturnscript.script = neweq.scriptbeforestartturn;     dobefturnscript.execute(self|target); var doonturnscript = new elements.Skill(~Against all odds_old~); doonturnscript.script = neweq.scriptonstartturn; doonturnscript.execute(self|target);     neweq.animate(~flashandshake~);    }   } else {    if(self.equipment.length >= d) {     if(self.equipment[d - 1].skillcard == ~~) {      var smallorlarge = ~small~;      if(self.equipment[d - 1].size > 1) {       smallorlarge = ~large~;      }    var exceptions = [~skillcard~|~excludefromrandomlists~|~alternateversion~|~robotonly~|~witchonly~|~inventoronly~|~onceperbattle~]; if(self.usecpuinsteadofdice) exceptions.remove(~robotonly~); if(self.getskillcard().skillcard == ~witch~) exceptions.remove(~witchonly~); if(self.getskillcard() != null && self.getskillcard().skillcard == ~inventor~) exceptions.remove(~inventoronly~);  var neweq = new elements.Equipment(rand(getequipmentlist(null|[smallorlarge]|exceptions)));      neweq.row = self.equipment[d - 1].row; neweq.column = self.equipment[d - 1].column; neweq.x = self.equipment[d - 1].x;      neweq.y = self.equipment[d - 1].y;      self.equipment[d - 1] = neweq;      var dobefcombscript = new elements.Skill(~Against all odds_old~);      dobefcombscript.script = neweq.scriptbeforecombat;      dobefcombscript.execute(self|target);      var dobefturnscript = new elements.Skill(~Against all odds_old~);      dobefturnscript.script = neweq.scriptbeforestartturn;      dobefturnscript.execute(self|target); var doonturnscript = new elements.Skill(~Against all odds_old~); doonturnscript.script = neweq.scriptonstartturn; doonturnscript.execute(self|target);      neweq.animate(~flashandshake~);     } else {      self.textparticle(~No effect!~);     }    } else {     self.textparticle(~No effect!~);    }   }  } trace(~--~); for(eq in self.equipment) { trace(eq.name); trace(eq.row); trace(eq.column); },Emulator,REQUIRE1|REQUIRE1,,ORANGE,,,,_thinghappens,0,YES,NO,excludefromrandomlists,,,,,,trace(~!!!~); for(eq in self.equipment) { trace(eq.name); trace(eq.row); trace(eq.column); },,,,,,
Stupid's Shock,Shock all equipment,2,inflict(SHOCK|ALL); /*this is jackeea's fault; he came up with this name*/,Electrify,COUNTDOWN,12,YELLOW,halfcountdown,change_function,,_shock,0,NO,NO,,,,,,,,,,,,,
Stupid's Shock_downgraded,Inflict [vanish]1 vanish,2,inflict(~ncr_vanish~),Electrify,COUNTDOWN,12,YELLOW,,,,_vanish,0,NO,NO,,,,,,,,,,,,,
Stupid's Shock_weakened,Inflict [vanish]1 vanish,2,inflict(~ncr_vanish~),Electrify,COUNTDOWN,6,YELLOW,,,,_vanish,0,NO,NO,,,,,,,,,,,,,
Wacko's Weaken,Weaken all equipment,2,inflict(WEAKEN|ALL);,Scream,COUNTDOWN,12,ORANGE,halfcountdown,change_function,weaken,_weaken,0,NO,NO,,,,,,,,,,,,,
Wacko's Weaken_downgraded,Inflict [vanish]1 vanish,2,inflict(~ncr_vanish~),Scream,COUNTDOWN,12,ORANGE,,,,_vanish,0,NO,NO,,,,,,,,,,,,,
Wacko's Weaken_weakened,Inflict [vanish]1 vanish,2,inflict(~ncr_vanish~),Scream,COUNTDOWN,6,ORANGE,,,,_vanish,0,NO,NO,,,,,,,,,,,,,
Wacko's Weaken?,Inflict [weaken]1 per card,2,inflict(WEAKEN|ALL);,Scream,COUNTDOWN,12,ORANGE,halfcountdown,change_function,,_weaken,0,NO,NO,alternateversion,,,,,,,,,,,,
Wacko's Weaken?_downgraded,Inflict [vanish]1 vanish,2,inflict(~ncr_vanish~),Scream,COUNTDOWN,12,ORANGE,,,,_vanish,0,NO,NO,alternateversion,,,,,,,,,,,,
Wacko's Weaken?_weakened,Inflict [vanish]1 vanish,2,inflict(~ncr_vanish~),Scream,COUNTDOWN,6,ORANGE,,,,_vanish,0,NO,NO,alternateversion,,,,,,,,,,,,
Open Sesame,Split a dice in two|(If [mana]>=4: split in three),1,if(getstatusself(MANA) >= 4) { givedice(split(d| 3)| ~splitdice~); } else { givedice(split(d)| ~splitdice~); },Steal,MIN4,,GREEN,change_power,change_function,,none,0,YES,NO,,1,,,,,,,,,,,
Open Sesame_upgraded,Split a dice in two|(If [mana]>=3: split in three),1,if(getstatusself(MANA) >= 3) { givedice(split(d| 3)| ~splitdice~); } else { givedice(split(d)| ~splitdice~); },Steal,MIN4,,GREEN,,,,none,0,YES,NO,,,,,,,,,,,,,
Open Sesame_downgraded,Split a dice in two|(Cost [mana]4: split in three),1,if(getstatusself(MANA) >= 4) { removestatusself(MANA|3); givedice(split(d| 3)| ~splitdice~); } else { givedice(split(d)| ~splitdice~); },Steal,MIN4,,GREEN,,,,none,0,YES,NO,,,,,,,,,,,,,
Woodchipper,Reduce countdowns by <d6>|(Cost [mana]2: reuse),1,boostcountdowns(d);,Turbo Boost,MAX4,,GREEN,change_power,change_function,,none,-1,YES,NO,hidereuseable,1,,,,,,,,if(getstatusself(MANA) < 2) { e.usesleft = 0; } else { removestatusself(MANA|2); },,,
Woodchipper_upgraded,Reduce countdowns by <d6>|(Cost [mana]2: reuse),1,boostcountdowns(d);,Turbo Boost,NORMAL,,GREEN,,,,none,-1,YES,NO,hidereuseable,,,,,,,,,if(getstatusself(MANA) < 2) { e.usesleft = 0; } else { removestatusself(MANA|2); },,,
Woodchipper_downgraded,Reduce countdowns by <d6>,1,boostcountdowns(d);,Turbo Boost,MAX4,,GREEN,,,,none,-1,YES,NO,hidereuseable,,,,,,,,,,,,
Dynamite,Reduce countdowns by <d6>|50% chance to boost twice,1,boostcountdowns(d); var odds = 50; if(getstatusself(~luck~) > 0){ odds = 100; } if(getstatusself(~luck+~) > 0){ odds = 100; }   if(chance(odds)) { sfx(~_thinghappens~); self.textparticle(~Success!~); boostcountdowns(d); },Turbo Boost,MAX4,,RED,change_power,change_function,,none,0,YES,NO,,1,,,,,,,,,,,
Dynamite_upgraded,Reduce countdowns by <d6>|50% chance to boost twice|,1,boostcountdowns(d); var odds = 50; if(getstatusself(~luck~) > 0){ odds = 100; } if(getstatusself(~luck+~) > 0){ odds = 100; }   if(chance(odds)) { sfx(~_thinghappens~); self.textparticle(~Success!~); boostcountdowns(d); },Turbo Boost,MAX4,,RED,,,,none,2,YES,NO,,,,,,,,,,,,,
Dynamite_downgraded,Reduce countdowns by <d6>,1,boostcountdowns(d);,Turbo Boost,MAX4,,RED,,,,none,0,YES,NO,,,,,,,,,,,,,
Nail Bat_deckupgrade,Do [sword]<d6> damage|(You lose [heart]3 hp each turn),2,attack(d); sfxdamage(target|d);,Lucky Shot,NORMAL|FREE5,,RED,,,,none,0,NO,NO,,,,,,,e.animate(~flashandshake~); pierceattackself(3); sfx(~_damage~);,,,,,,
Battle Cry_deckupgrade,Inflict [weaken]5 weaken|[gray](once per battle),2,inflict(WEAKEN| 5); sfx(~_weaken~|~~|0.2);,Scream,MIN5,,ORANGE,,,,none,0,NO,YES,,,,,,,,,,,,,
Particle Accelerator_deckupgrade,On 1-3: Do [sword]<var_tempparticleacceleratorkludge:particleaccelerator> damage|on 4-6: Double damage,2,if(d < 4) { attack(e.getvar(~particleaccelerator~)); sfxdamage(target|d); sfx(~_plasma~); } else { e.setvar(~particleaccelerator~| e.getvar(~particleaccelerator~) * 2); sfx(~jackpot_increasecounter~); },Plasma Gun,NORMAL,,RED,,,,none,0,NO,NO,,,,e.setvar(~particleaccelerator~| 1);,e.setvar(~particleaccelerator~| 1);,,,,,if(d < 4) { e.castdirection = 1; } else { e.castdirection = -1; },,,
Gemstone Staff_deckupgrade,Do [ice]8 damage|Freeze [ice]1 dice,2,attack(8| ICE); inflict(ICE| 1); sfx(~magic~); sfx(~_damage~|~~|0.1); sfx(~_ice~|~~|0.2); ,Flash Freeze,COUNTDOWN,8,BRIGHTCYAN,,,,none,0,NO,NO,,,,,,,,,,,,,
Hi Vis Jacket_deckupgrade,Add [shield]<d6> shield|(Gain [reduce]1 each turn),2,inflictself(SHIELD|d); sfx(~_shield~|~~|0.2);,Pillow Fort,NORMAL,,ORANGE,,,,none,0,YES,NO,,,,,,,e.animate(~flashandshake~); inflictself(REDUCE| 1); sfx(~_shield~);,,,,,,
Screwdriver_deckupgrade,Do [sword]<d6> damage[;]|on even[;] reactivate gadget,2,attack(d); if(d % 2 == 0) { Gadget.reactivate(self| ALL); } sfxdamage(target|d); /*i don't think gadgets actually work with jester*/,Efficiency,NORMAL,,PURPLE,,,,none,0,NO,NO,,,if(d % 2 == 0) { Gadget.reactivate(self| ALL); },,,,,,,,,,
Counterfeit_deckupgrade,Duplicate two dice,2,givedice([actualdice[0].basevalue|actualdice[0].basevalue|actualdice[1].basevalue|actualdice[1].basevalue]);,Clone Device,NORMAL|NORMAL,,GREEN,,,,none,0,YES,NO,,,,,,,,,,,,,
Befuddle_deckupgrade,Duplicate both dice,2,givedice([actualdice[0].basevalue|actualdice[0].basevalue|actualdice[1].basevalue|actualdice[1].basevalue]); /*deckupgrade DIRECTLY STOLEN from the deprecated morefluff version of befuddle! aren't i evil*/,Stardust,NORMAL|NORMAL,,GREEN,,,,none,0,YES,NO,,,,,,,,,,,,,
Peapod,Do [sword]2 damage (Cost [mana]1:|boost this countdown by 2)|,1,attack(2); if(getstatusself(MANA) >= 1) { removestatusself(MANA); e.setvar(~test~|true); for(eq in self.equipment) { if(e.getvar(~test~) == true && eq.getvar(~test~) == true && eq.ready) { var dicetoassign = new elements.Dice(); dicetoassign.basevalue = 2; self.dicepool.push(dicetoassign); eq.assigndice(dicetoassign); eq.animate(~flash~); eq.setvar(~test~|false); } } } e.setvar(~test~|false);,Pea Gun,COUNTDOWN,5,RED,change_power,change_function,,_damage,-1,NO,NO,,1,,,,,,,,for(eq in self.equipment) { if(eq.name == e.name && eq.namemodifier == e.namemodifier && (eq.y + 10) >= e.y && (eq.y - 10) <= e.y && (eq.x + 10) >= e.x && (eq.x - 10) <= e.x) { eq.setvar(~test~|true); } },,,
Peapod_upgraded,Do [sword]3 damage (Cost [mana]1:|boost this countdown by 2)|,1,attack(3); if(getstatusself(MANA) >= 1) { removestatusself(MANA); e.setvar(~test~|true); for(eq in self.equipment) { if(e.getvar(~test~) == true && eq.getvar(~test~) == true && eq.ready) { var dicetoassign = new elements.Dice(); dicetoassign.basevalue = 2; self.dicepool.push(dicetoassign); eq.assigndice(dicetoassign); eq.animate(~flash~); eq.setvar(~test~|false); } } } e.setvar(~test~|false);,Pea Gun,COUNTDOWN,5,RED,,,,_damage,-1,NO,NO,,,,,,,,,,for(eq in self.equipment) { if(eq.name == e.name && eq.namemodifier == e.namemodifier && (eq.y + 10) >= e.y && (eq.y - 10) <= e.y && (eq.x + 10) >= e.x && (eq.x - 10) <= e.x) { eq.setvar(~test~|true); } },,,
Peapod_downgraded,Do [sword]1 damage (Cost [mana]1:|boost this countdown by 2)|,1,attack(1); if(getstatusself(MANA) >= 1) { removestatusself(MANA); e.setvar(~test~|true); for(eq in self.equipment) { if(e.getvar(~test~) == true && eq.getvar(~test~) == true && eq.ready) { var dicetoassign = new elements.Dice(); dicetoassign.basevalue = 2; self.dicepool.push(dicetoassign); eq.assigndice(dicetoassign); eq.animate(~flash~); eq.setvar(~test~|false); } } } e.setvar(~test~|false);,Pea Gun,COUNTDOWN,5,RED,,,,_damage,-1,NO,NO,,,,,,,,,,for(eq in self.equipment) { if(eq.name == e.name && eq.namemodifier == e.namemodifier && (eq.y + 10) >= e.y && (eq.y - 10) <= e.y && (eq.x + 10) >= e.x && (eq.x - 10) <= e.x) { eq.setvar(~test~|true); } },,,
Do [sword][d6] damage,Sword. oops,2,attack(d); sfxdamage(target|d);,Vaporizer,NORMAL,,RED,change_power,change_function,,none,0,NO,NO,,,,,,,,,,,,,
Do [sword][d6] damage_upgraded,Ok I can do this.|[sword]Destroy One + [d6] hearts,2,attack(d); sfxdamage(target|d);,Vaporizer,NORMAL|FREE1,,RED,,,,none,0,NO,NO,,,,,,,,,,,,,
Do [sword][d6] damage_downgraded,attack(d); sfxdamage(target[;]d);|oh goddammit,2,self.textparticle(~Sword-~);,Vaporizer,NORMAL,,RED,,,,none,0,NO,NO,,,,,,,,,,,,,
Bass Guitar,Do [weaken]<d6> damage[;]|on 1[;] inflict [weaken]1 weaken,1,attack(d|WEAKEN); sfxdamage(target|d); if(d == 1) { inflict(WEAKEN); sfx(~_weaken~|~~|0.2); },Guitar Solo,MAX5,,ORANGE,change_power,change_power,,none,0,NO,NO,,1,,,,,,,,,,,
Bass Guitar_upgraded,Do [weaken]<d6> damage[;]|on 1[;] inflict [weaken]2 weaken,1,attack(d|WEAKEN); sfxdamage(target|d); if(d == 1) { inflict(WEAKEN|2); sfx(~_weaken~|~~|0.2); },Guitar Solo,MAX5,,ORANGE,,,,none,0,NO,NO,,,,,,,,,,,,,
Bass Guitar_downgraded,Do [weaken]<d6> damage,1,attack(d|WEAKEN); sfxdamage(target|d); ,Guitar Solo,MAX5,,ORANGE,,,,none,0,NO,NO,,,,,,,,,,,,,
Brass Knuckles,Do [sword]<d6> damage[;]|on 6[;] gain [reduce]1 reduce,2,attack(d); if(d == 6) { inflictself(REDUCE); sfx(~_shield~|~~|0.2); } sfxdamage(target|d); /*breakthrough says hi. whatever*/,Pillow Fort,NORMAL,,ORANGE,change_power,change_power,,none,0,NO,NO,,,,,,,,,,,,,
Brass Knuckles_upgraded,Do [sword]<d6> damage[;]|on even[;] gain [reduce]1 reduce,2,attack(d); if(d % 2 == 0) { inflictself(REDUCE); sfx(~_shield~|~~|0.2); } sfxdamage(target|d);,Pillow Fort,NORMAL,,ORANGE,,,,none,0,NO,NO,,,,,,,,,,,,,
Brass Knuckles_downgraded,Do [sword]<d6> damage,2,attack(d); sfxdamage(target|d); /*this and bass guitar were planned for a 'swap weaken and reduce' remix rule. but that was too much Effort and didn't make sense*/,Pillow Fort,NORMAL,,ORANGE,,,,none,0,NO,NO,,,,,,,,,,,,,
Loud Yelling,Weaken [weaken]2 equipment,1,inflict(WEAKEN|2);,Scream,REQUIRE5,,ORANGE,simplify,change_power,,_weaken,0,NO,NO,,1,,,,,,,,,,,
Loud Yelling_downgraded,Weaken [weaken]1 equipment,1,inflict(WEAKEN);,Scream,REQUIRE5,,ORANGE,,,,_weaken,0,NO,NO,,,,,,,,,,,,,
Freezeburn,Inflict [fire]1 burn|(Cost [mana]2: [ice]1 instead)|,1,if(getstatusself(MANA) >= 2) { removestatusself(MANA|2); inflict(ICE); sfx(~_ice~); } else { inflict(FIRE); sfx(~_fire~); },Blowtorch,EVEN,,PURPLE,change_power,change_power,,none,-1,NO,NO,,1,,,,,,,,,,,
Freezeburn_upgraded,Inflict [fire]1 burn|(Cost [mana]1: [ice]1 instead)|,1,if(getstatusself(MANA) >= 1) { removestatusself(MANA); inflict(ICE); sfx(~_ice~); } else { inflict(FIRE); sfx(~_fire~); },Blowtorch,EVEN,,PURPLE,,,,none,-1,NO,NO,,,,,,,,,,,,,
Freezeburn_downgraded,Inflict [fire]1 burn|,1,inflict(FIRE); sfx(~_fire~);,Blowtorch,EVEN,,PURPLE,,,,none,-1,NO,NO,,,,,,,,,,,,,
Christmas Spirit,Inflict [vanish]1 vanish|(Cost [mana]2: [ice]1 instead)|,1,/*dumbest item name ever*/ if(getstatusself(MANA) >= 2) { removestatusself(MANA|2); inflict(ICE); sfx(~_ice~); } else { sfx(~_vanish~); inflict(~ncr_vanish~); },Flash Freeze,EVEN,,PURPLE,change_power,change_power,,none,-1,NO,NO,,1,,,,,,,,,,,
Christmas Spirit_upgraded,Inflict [vanish]1 vanish|(Cost [mana]1: [ice]1 instead)|,1,if(getstatusself(MANA) >= 1) { removestatusself(MANA); inflict(ICE); sfx(~_ice~); } else { sfx(~_vanish~); inflict(~ncr_vanish~); },Flash Freeze,EVEN,,PURPLE,,,,none,-1,NO,NO,,,,,,,,,,,,,
Christmas Spirit_downgraded,Inflict [vanish]1 vanish|,1,sfx(~_vanish~); inflict(~ncr_vanish~);,Flash Freeze,EVEN,,PURPLE,,,,none,-1,NO,NO,,,,,,,,,,,,,
Wisp Essence,Inflict [vanish]1 vanish|(Cost [mana]2: [fire]1 instead)|,1,if(getstatusself(MANA) >= 2) { removestatusself(MANA|2); inflict(FIRE); sfx(~_fire~); } else { sfx(~_vanish~); inflict(~ncr_vanish~); },Hadoken,EVEN,,PINK,change_power,change_power,,none,-1,NO,NO,,1,,,,,,,,,,,
Wisp Essence_upgraded,Inflict [vanish]1 vanish|(Cost [mana]2: [fire]1 instead)|,1,if(getstatusself(MANA) >= 1) { removestatusself(MANA); inflict(FIRE); sfx(~_fire~); } else { sfx(~_vanish~); inflict(~ncr_vanish~); },Hadoken,EVEN,,PINK,,,,none,-1,NO,NO,,,,,,,,,,,,,
Wisp Essence_downgraded,Inflict [vanish]1 vanish|,1,sfx(~_vanish~); inflict(~ncr_vanish~);,Hadoken,EVEN,,PINK,,,,none,-1,NO,NO,,,,,,,,,,,,,
Magic Flute,Roll 2 ones|(Cost [mana]2: return last dice),1,givedice([1|1]);,Unlucky Roll,COUNTDOWN,6,GREEN,halfcountdown,change_function,,none,0,YES,NO,,1,,,,,,,,if(getstatusself(MANA) >= 2) { removestatusself(MANA|2); givedice(e.dicehistory[e.dicehistory.length - 1].basevalue); },,,
Magic Flute_downgraded,Roll 1 one|(Cost [mana]2: return last dice),1,givedice(1);,Unlucky Roll,COUNTDOWN,6,GREEN,,,,none,0,YES,NO,,,,,,,,,,if(getstatusself(MANA) >= 2) { removestatusself(MANA|2); givedice(e.dicehistory[e.dicehistory.length - 1].basevalue); },,,
Magic Flute_weakened,Roll 1 one|(Cost [mana]2: return last dice),1,givedice(1);,Unlucky Roll,COUNTDOWN,3,GREEN,,,,none,0,YES,NO,,,,,,,,,,if(getstatusself(MANA) >= 2) { removestatusself(MANA|2); givedice(e.dicehistory[e.dicehistory.length - 1].basevalue); },,,
Black Lotus@ncrmod,Gain [mana]<triple> mana|[gray](once per battle),2,inflictself(MANA|d * 3);,Glisten,MAX4,,GRAY,simplify,change_power,,_mana,0,YES,YES,,,,,,,,,,,,,
Black Lotus@ncrmod_downgraded,Gain [mana]<d6> mana|[gray](once per battle),2,inflictself(MANA|d);,Glisten,MAX4|FREE3,,GRAY,,,,_mana,0,YES,YES,,,,,,,,,,,,,
Poppy,Inflict [poison]<d6> poison|(Cost [mana]<d6>: reuse),1,inflict(POISON|d);,Acid Arrow,MAX2,,PURPLE,change_power,change_function,,none,-1,NO,NO,hidereuseable,1,,,,,,,,if(getstatusself(MANA) < d) { e.usesleft = 0; } else { removestatusself(MANA|d); },,,
Poppy_upgraded,Inflict [poison]<d6> poison|(Cost [mana]1: reuse),1,inflict(POISON|d);,Acid Arrow,MAX2,,PURPLE,,,,none,-1,NO,NO,hidereuseable,,,,,,,,,if(getstatusself(MANA) < 1) { e.usesleft = 0; } else { removestatusself(MANA|1); },,,
Poppy_downgraded,Inflict [poison]<d6> poison|(Cost [mana]3: reuse),1,inflict(POISON|d);,Acid Arrow,MAX2,,PURPLE,,,,none,-1,NO,NO,hidereuseable,,,,,,,,,if(getstatusself(MANA) < 3) { e.usesleft = 0; } else { removestatusself(MANA|3); },,,
Glitter Bomb,Do [sword]4 damage[;]|get [mana]4 mana,1,attack(4); sfxdamage(target|4); inflictself(MANA|4);,Glisten,COUNTDOWN,12,BRIGHTCYAN,threequartercountdown,change_function,,_mana,0,NO,NO,,1,,,,,,,,,,,
Glitter Bomb_downgraded,Do [sword]4 damage[;]|get [mana]2 mana,1,attack(4); sfxdamage(target|4); inflictself(MANA|2);,Glisten,COUNTDOWN,12,BRIGHTCYAN,,,,_mana,0,NO,NO,,,,,,,,,,,,,
Glitter Bomb_weakened,Do [sword]4 damage[;]|get [mana]2 mana,1,attack(4); sfxdamage(target|4); inflictself(MANA|2);,Glisten,COUNTDOWN,9,BRIGHTCYAN,,,,_mana,0,NO,NO,,,,,,,,,,,,,
Luckpick,Split a dice. 33% chance to|return original dice[;] too,1,var odds = 33; if(getstatusself(~luck~) > 0){ odds = 66; } if(getstatusself(~luck+~) > 0){ odds = 100; } var s = split(d); if(chance(odds)) { self.textparticle(~Success!~); givedice([d|s[0]|s[1]]|~splitdice~); } else { givedice(s|~splitdice~); },Razor Blade,NORMAL,,GREEN,change_power,change_function,,none,0,YES,NO,,,,,,,,,,,,,
Luckpick_upgraded,Split a dice. 66% chance to|return original dice[;] too,1,var odds = 66; if(getstatusself(~luck~) > 0){ odds = 100; } if(getstatusself(~luck+~) > 0){ odds = 100; } var s = split(d); if(chance(odds)) { self.textparticle(~Success!~); givedice([d|s[0]|s[1]]|~splitdice~); } else { givedice(s|~splitdice~); },Razor Blade,NORMAL,,GREEN,,,,none,0,YES,NO,,,,,,,,,,,,,
Luckpick_downgraded,Split a dice. 33% chance to|return just original dice,1,var odds = 33; if(getstatusself(~luck~) > 0){ odds = 66; } if(getstatusself(~luck+~) > 0){ odds = 100; } var s = split(d); if(chance(odds)) { self.textparticle(~No effect!~); givedice(d); } else { givedice(s|~splitdice~); },Razor Blade,NORMAL,,GREEN,,,,none,0,YES,NO,,,,,,,,,,,,,
Lotus Swing,Get [mana]<d6> in [jinx]<d6> turns|10% chance to get it now,1,var odds = 10; if(getstatusself(~luck~) > 0) odds = 20; if(getstatusself(~luck+~) > 0) odds = 100; if(chance(odds)) { self.textparticle(~Success!~); inflictself(MANA|d); sfx(~_mana~); } else { jinx(~Lotus Swing~|~get [mana]%VAR% mana~|~Get [mana]%VAR% mana~|~inflict(\~mana\~|d); sfx(\~_mana\~);~|self|self|d|d); sfx(~_thinghappens~); },Down Low,NORMAL,,PURPLE,add2,complicate,,none,0,YES,NO,,1,,,,,,,,,,,
Plight,Half of target's [poison]poison|becomes PU poison,1,var p = getstatus(POISON) / 2; if(p % 1 != 0) { p += 0.5; } removestatus(POISON|p); inflict(~alternate_poison~|p);,Emetic,COUNTDOWN,18,PURPLE,change_power,change_function,poison,_poison,0,NO,NO,,1,,,,,,,,,,,
Plight_downgraded,1/4 of target's [poison]poison|becomes PU poison,1,var p = getstatus(POISON) / 4; if(p % 1 != 0) { p += 0.5; } removestatus(POISON|p); inflict(~alternate_poison~|p);,Emetic,COUNTDOWN,18,PURPLE,,,,_poison,0,NO,NO,,,,,,,,,,,,,
Plight_upgraded,Half of target's [poison]poison|becomes PU poison,1,var p = getstatus(POISON) / 2; if(p % 1 != 0) { p += 0.5; } removestatus(POISON|p); inflict(~alternate_poison~|p);,Emetic,COUNTDOWN,12,PURPLE,,,,_poison,0,NO,NO,,,,,,,,,,,,,
Plight_weakened,1/4 of target's [poison]poison|becomes PU poison,1,var p = getstatus(POISON) / 4; if(p % 1 != 0) { p += 0.5; } removestatus(POISON|p); inflict(~alternate_poison~|p);,Emetic,COUNTDOWN,12,PURPLE,,,,_poison,0,NO,NO,,,,,,,,,,,,,
Plight?,Do [sword]1 damage for|every [poison]1 on enemy,1,attack(getstatus(~alternate_poison~)); sfx(~_poison~); /*the alternative; converting half of pu poison to normal poison; was a bit awkward - the newly generated poison could not be given a proper tooltip; for one*/,Emetic,COUNTDOWN,18,PURPLE,change_power,change_function,,_damage,0,NO,NO,alternateversion,1,,,,,,,,,,,
Plight?_downgraded,Do [sword]1 damage for|every [poison]2 on enemy,1,var p = getstatus(~alternate_poison~) / 2; if(p % 1 != 0) { p -= 0.5; } if(p < 1) { self.textparticle(~No effect!~); } else { attack(p); sfx(~_poison~); },Emetic,COUNTDOWN,18,PURPLE,,,,_damage,0,NO,NO,alternateversion,,,,,,,,,,,,
Plight?_upgraded,Do [sword]1 damage for|every [poison]1 on enemy,1,attack(getstatus(~alternate_poison~)); sfx(~_poison~);,Emetic,COUNTDOWN,12,PURPLE,,,,_damage,0,NO,NO,alternateversion,,,,,,,,,,,,
Plight?_weakened,Do [sword]1 damage for|every [poison]2 on enemy,1,var p = getstatus(~alternate_poison~) / 2; if(p % 1 != 0) { p -= 0.5; } if(p < 1) { self.textparticle(~No effect!~); } else { attack(p); sfx(~_poison~); },Emetic,COUNTDOWN,12,PURPLE,,,,_damage,0,NO,NO,alternateversion,,,,,,,,,,,,
Heaven on Earth,[weaken]Weaken all your items[;]|autoroll immediately,1,robotroll(true); inflictself(WEAKEN|ALL); self.applyequipmentcurses();,Burrower,EVEN,,ORANGE,change_power,change_function,weaken,none,0,YES,NO,robotonly,,,,,,,,,,,e.preventdefault = true; e.maintainfury = true;,
Heaven on Earth_upgraded,[weaken]Weaken 3 of your items[;]|autoroll immediately,1,robotroll(true); inflictself(WEAKEN|3); self.applyequipmentcurses();,Burrower,EVEN,,ORANGE,,,,none,0,YES,NO,robotonly,,,,,,,,,,,e.preventdefault = true; e.maintainfury = true;,
Heaven on Earth_downgraded,[weaken]Weaken all your items[;]|jackpot immediately|[80%][gray]''There ain't no heaven on Earth!''[],1,robotjackpot(); inflictself(WEAKEN|ALL); self.applyequipmentcurses();,Burrower,EVEN,,ORANGE,,,,none,0,YES,NO,robotonly,,,,,,,,,,,e.preventdefault = true; e.maintainfury = true;,
Heaven on Earth?,Receive [weaken]1 per equipment[;]|autoroll immediately,1,robotroll(true); inflictself(WEAKEN|self.equipment.length - 1); self.applyequipmentcurses();,Burrower,EVEN,,ORANGE,change_power,change_function,,none,0,YES,NO,robotonly,,,,,,,,,,,e.preventdefault = true; e.maintainfury = true;,
Heaven on Earth?_upgraded,Receive [weaken]1 per item (max 3)[;]|autoroll immediately,1,robotroll(true); inflictself(WEAKEN|self.equipment.length - 1 > 3 ? 3 : self.equipment.length - 1); self.applyequipmentcurses();,Burrower,EVEN,,ORANGE,,,,none,0,YES,NO,robotonly,,,,,,,,,,,e.preventdefault = true; e.maintainfury = true;,
Heaven on Earth?_downgraded,Receive [weaken]1 per equipment[;]|jackpot immediately|[80%][gray]''There ain't no heaven on Earth!''[],1,robotjackpot(); inflictself(WEAKEN|self.equipment.length - 1); self.applyequipmentcurses();,Burrower,EVEN,,ORANGE,,,,none,0,YES,NO,robotonly,,,,,,,,,,,e.preventdefault = true; e.maintainfury = true;,
Strange Apparatus,Inflict [shock]shock & an extra|status depending on dice:|1[blind] 2[fire] 3[weaken] 4[vanish] 5[ice] 6[shock],2,var statlist = [~blind~|~fire~|~weaken~|~vanish~|~ice~|~shock~]; inflict(SHOCK); if(statlist[d - 1] == ~vanish~) { inflict(~ncr_vanish~|r);  } else { inflict(statlist[d - 1]); } sfx(~_~ + statlist[d - 1]);,Discharge,NORMAL,,YELLOW,change_power,change_function,,none,0,NO,NO,,,,,,,,,,,,,
Strange Apparatus_downgraded,Inflict a status|depending on dice:|1[blind] 2[fire] 3[weaken] 4[vanish] 5[ice] 6[shock],2,var statlist = [~blind~|~fire~|~weaken~|~vanish~|~ice~|~shock~]; if(statlist[d - 1] == ~vanish~) { inflict(~ncr_vanish~|r);  } else { inflict(statlist[d - 1]); } sfx(~_~ + statlist[d - 1]);,Discharge,NORMAL,,YELLOW,,,,none,0,NO,NO,,,,,,,,,,,,,
Strange Apparatus_upgraded,Inflict [shock]shock & an extra|status depending on dice:|1[shock] 2[blind] 3[fire] 4[weaken] 5[vanish] 6[ice],2,var statlist = [~shock~|~blind~|~fire~|~weaken~|~vanish~|~ice~]; inflict(SHOCK); if(statlist[d - 1] == ~vanish~) { inflict(~ncr_vanish~|r);  } else { inflict(statlist[d - 1]); } sfx(~_~ + statlist[d - 1]);,Discharge,NORMAL,,YELLOW,,,,none,0,NO,NO,,,,,,,,,,,,,
Major Malfunction,[shock]Shock all your items[;]|autoroll immediately,1,robotroll(true); inflictself(SHOCK|6); self.applyequipmentcurses(); /*i just realized this is kind of the inverse of bucket of water; which is interesting*/,Jackhammer,EVEN,,YELLOW,change_power,change_function,,none,0,YES,NO,robotonly,,,,,,,,,,,e.preventdefault = true; e.maintainfury = true;,
Major Malfunction_upgraded,[shock]Shock 3 of your items[;]|autoroll immediately,1,robotroll(true); inflictself(SHOCK|3); self.applyequipmentcurses();,Jackhammer,EVEN,,YELLOW,,,,none,0,YES,NO,robotonly,,,,,,,,,,,e.preventdefault = true; e.maintainfury = true;,
Major Malfunction_downgraded,[shock]Shock all your items[;]|jackpot immediately[80%][gray]''These words may be too late''[],1,robotjackpot(); inflictself(SHOCK|6); self.applyequipmentcurses();,Jackhammer,EVEN,,YELLOW,,,,none,0,YES,NO,robotonly,,,,,,,,,,,e.preventdefault = true; e.maintainfury = true;,
Electric Guitar,Do [shock]<d6> damage[;]|on 1[;] inflict [shock]1 shock,1,attack(d|SHOCK); sfxdamage(target|d); if(d == 1) { inflict(SHOCK); sfx(~_shock~|~~|0.2); },Discharge,MAX5,,YELLOW,change_power,change_power,,none,0,NO,NO,,1,,,,,,,,,,,
Electric Guitar_upgraded,Do [shock]<d6> damage[;]|on 1[;] inflict [shock]2 shock,1,attack(d|SHOCK); sfxdamage(target|d); if(d == 1) { inflict(SHOCK|2); sfx(~_shock~|~~|0.2); },Discharge,MAX5,,YELLOW,,,,none,0,NO,NO,,,,,,,,,,,,,
Electric Guitar_downgraded,Do [shock]<d6> damage,1,attack(d|SHOCK); sfxdamage(target|d); ,Discharge,MAX5,,YELLOW,,,,none,0,NO,NO,,,,,,,,,,,,,
Loud Brostep,Shock [shock]2 equipment,1,inflict(SHOCK|2);,Electrify,REQUIRE5,,YELLOW,simplify,change_power,,_shock,0,NO,NO,,1,,,,,,,,,,,
Loud Brostep_downgraded,Shock [shock]1 equipment,1,inflict(SHOCK);,Electrify,REQUIRE5,,YELLOW,,,,_shock,0,NO,NO,,,,,,,,,,,,,
Power Socket Licking,Double [shock]shock|[gray](once per battle)|[80%][gray]''Good for you''[],1,inflict(SHOCK| getstatus(SHOCK));,Static Shock,COUNTDOWN,18,YELLOW,change_power,change_power,,_shock,0,NO,YES,,,,,,,,,,,,,
Power Socket Licking_upgraded,Double [shock]shock|[gray](once per battle)|[80%][gray]''Good for you''[],1,inflict(SHOCK| getstatus(SHOCK));,Static Shock,COUNTDOWN,12,YELLOW,,,,_shock,0,NO,YES,,,,,,,,,,,,,
Power Socket Licking_downgraded,Increase [shock]shock by 50%|[gray](once per battle)|[80%][gray]''Now it's even less useful!''[],1,inflict(SHOCK| getstatus(SHOCK) * 0.5);,Static Shock,COUNTDOWN,18,YELLOW,,,,_shock,0,NO,YES,,,,,,,,,,,,,
Power Socket Licking_weakened,Increase [shock]shock by 50%|[gray](once per battle)|[80%][gray]''Now it's even less useful!''[],1,inflict(SHOCK| getstatus(SHOCK) * 0.5);,Static Shock,COUNTDOWN,12,YELLOW,,,,_shock,0,NO,YES,,,,,,,,,,,,,
Blast Processing,Do [sword]<d6> damage. On 6[;]|decrease CPU by half,2,attack(d); if(d == 6) { adjustrobotcounter(-(self.roll_total / 2)); sfx(~jackpot_reducecounter~); } sfxdamage(target|d);,Electrify,NORMAL,,GRAY,change_power,change_power,,_plasma,0,NO,NO,,,if(d == 6) { adjustrobotcounter(-(self.roll_total / 2)); sfx(~jackpot_reducecounter~); },,,,,,,,,,
Blast Processing_upgraded,Do [sword]<d6> damage. On 4[;]|decrease CPU by half,2,attack(d); if(d == 4) { adjustrobotcounter(-(self.roll_total / 2)); sfx(~jackpot_reducecounter~); } sfxdamage(target|d);,Electrify,NORMAL,,GRAY,,,,_plasma,0,NO,NO,,,if(d == 4) { adjustrobotcounter(-(self.roll_total / 2)); sfx(~jackpot_reducecounter~); },,,,,,,,,,
Blast Processing_downgraded,Do [sword]<d6> damage,2,attack(d); sfxdamage(target|d);,Electrify,NORMAL,,GRAY,,,,_plasma,0,NO,NO,,,,,,,,,,,,,
Rainmaking,Do [sword]<slotdoubles>[;] return a dice|Inflict [vanish]1 vanish,2,attack(d); givedice(d); sfxdamage(target|d); inflict(~ncr_vanish~);,Hadoken,DOUBLES|DOUBLES,,PINK,change_power,change_power,,_vanish,0,NO,NO,,,,,,,,,,,,,
Rainmaking_upgraded,Do [sword] equal to higher dice[;]|return the lower dice|On doubles[;] inflict [vanish]1,2,picked = actualdice[0].basevalue > actualdice[1].basevalue ? 0 : 1; attack(actualdice[picked].basevalue); givedice(actualdice[1 - picked].basevalue); sfxdamage(target|actualdice[picked].basevalue); if(actualdice[0].basevalue == actualdice[1].basevalue) { sfx(~_vanish~); inflict(~ncr_vanish~); } /*pretty sure jackeea already has like 3 items that are ''do this thing with the higher dice then return the lower dice''. eh. better than the previous upgrade; ''pick a dice to do damage with then return the other''. who would use that*/,Hadoken,NORMAL|NORMAL,,PINK,,,,none,0,NO,NO,,,,,,,,,,,,,
Rainmaking_downgraded,Do [sword]<slotdoubles>[;] return a dice|Inflict [vanish]1 vanish,2,attack(4); givedice(4); sfxdamage(target|4); inflict(~ncr_vanish~);,Hadoken,REQUIRE4|REQUIRE4,,PINK,,,,_vanish,0,NO,NO,,,,,,,,,,,,,
Flamemaking,Do [sword]<slotdoubles>[;] return a dice|Inflict [fire]1 burn,2,attack(d); givedice(d); sfxdamage(target|d); inflict(FIRE); /*no clue what to name this*/,Blowtorch,DOUBLES|DOUBLES,,RED,change_power,change_power,,_fire,0,NO,NO,,,,,,,,,,,,,
Flamemaking_upgraded,Do [sword] equal to higher dice[;]|return the lower dice|On doubles[;] inflict [fire]1,2,picked = actualdice[0].basevalue > actualdice[1].basevalue ? 0 : 1; attack(actualdice[picked].basevalue); givedice(actualdice[1 - picked].basevalue); sfxdamage(target|actualdice[picked].basevalue); if(actualdice[0].basevalue == actualdice[1].basevalue) { sfx(~_fire~); inflict(FIRE); },Blowtorch,NORMAL|NORMAL,,RED,,,,none,0,NO,NO,,,,,,,,,,,,,
Flamemaking_downgraded,Do [sword]<slotdoubles>[;] return a dice|Inflict [fire]1 burn,2,attack(4); givedice(4); sfxdamage(target|4); inflict(FIRE);,Blowtorch,REQUIRE4|REQUIRE4,,RED,,,,_fire,0,NO,NO,,,,,,,,,,,,,
Flakemaking,Do [sword]<slotdoubles>[;] return a dice|Inflict [ice]1 freeze,2,attack(d); givedice(d); sfxdamage(target|d); inflict(ICE);,Flash Freeze,DOUBLES|DOUBLES,,BRIGHTCYAN,change_power,change_power,,_ice,0,NO,NO,,,,,,,,,,,,,
Flakemaking_upgraded,Do [sword] equal to higher dice[;]|return the lower dice|On doubles[;] inflict [ice]1,2,picked = actualdice[0].basevalue > actualdice[1].basevalue ? 0 : 1; attack(actualdice[picked].basevalue); givedice(actualdice[1 - picked].basevalue); sfxdamage(target|actualdice[picked].basevalue); if(actualdice[0].basevalue == actualdice[1].basevalue) { sfx(~_ice~); inflict(ICE); },Flash Freeze,NORMAL|NORMAL,,BRIGHTCYAN,,,,none,0,NO,NO,,,,,,,,,,,,,
Flakemaking_downgraded,Do [sword]<slotdoubles>[;] return a dice|Inflict [ice]1 freeze,2,attack(4); givedice(4); sfxdamage(target|4); inflict(ICE);,Flash Freeze,REQUIRE4|REQUIRE4,,BRIGHTCYAN,,,,_ice,0,NO,NO,,,,,,,,,,,,,
Shiked Spield@sword,Do [sword]<d6> damage. On 6[;]|switch to gaining [shield]shield,2,var swapto = ~Shiked Spield@shield~; if(d != 6) { attack(d); sfxdamage(target|d); } else { inflictself(SHIELD|d); sfx(~_shield~); if(getstatusself(FURY) < 1 && self.layout != ~DECK~) {    var eqtoreplace = ~~;    var onscreenreplace = false;    for(eq in self.equipment) {     /* determine if e is a copy of an equipment that is multiuse or had re-equip used on it; and if it is; store the original variable as eqtoreplace and enable the flag that tells us we're replacing an item already on screen. there's probably an easier way to do this but idk */     if(     e.name == eq.name &&      e.namemodifier == eq.namemodifier &&      (eq.x + 100) >= e.x &&      (eq.x - 100) <= e.x &&      eq != e) {       eqtoreplace = eq; onscreenreplace = true; break;     }    }    if(onscreenreplace) {     var neweq = new elements.Equipment(swapto);     neweq.x = eqtoreplace.x;     neweq.y = eqtoreplace.y;     neweq.row = eqtoreplace.row;     neweq.column = eqtoreplace.column;     if(self.equipment.indexOf(eqtoreplace) != -1) { /*dumb safeguard*/      self.equipment[self.equipment.indexOf(eqtoreplace)] = neweq; /*i don't know why this is necessary but it is; you're just not allowed to refer to equipment through variables when overwriting it with another equipment*/      neweq.animate(~flashandshake~); /*also two variables can't point to the same equipment i guess; doing eqtoreplace.animate(~flashandshake~) has no effect*/     }    } else {     var neweq = new elements.Equipment(swapto);     neweq.column = e.column;     neweq.row = e.row;     neweq.x = -9999;     neweq.y = -9999;     neweq.show = false;     neweq.availablethisturn = false;     if(self.equipment.indexOf(e) != -1) { /*dumb safeguard*/      self.equipment[self.equipment.indexOf(e)] = neweq;     }    }   }  },Plasma Gun,NORMAL,,RED,change_power,change_power,,none,0,NO,NO,,,,,,,,,,if(d != 6) { e.castdirection = 1; } else { e.castdirection = -1; },,donothing();,
Shiked Spield@shield,Gain [shield]<d6> shield. On 6[;]|switch to doing [sword]damage,2,var swapto = ~Shiked Spield@sword~; if(d != 6) { inflictself(SHIELD|d); sfx(~_shield~); } else { attack(d); sfxdamage(target|d); if(getstatusself(FURY) < 1 && self.layout != ~DECK~) {    var eqtoreplace = ~~;    var onscreenreplace = false;    for(eq in self.equipment) {     /* determine if e is a copy of an equipment that is multiuse or had re-equip used on it; and if it is; store the original variable as eqtoreplace and enable the flag that tells us we're replacing an item already on screen. there's probably an easier way to do this but idk */     if(     e.name == eq.name &&      e.namemodifier == eq.namemodifier &&      (eq.x + 100) >= e.x &&      (eq.x - 100) <= e.x &&      eq != e) {       eqtoreplace = eq; onscreenreplace = true; break;     }    }    if(onscreenreplace) {     var neweq = new elements.Equipment(swapto);     neweq.x = eqtoreplace.x;     neweq.y = eqtoreplace.y;     neweq.row = eqtoreplace.row;     neweq.column = eqtoreplace.column;     if(self.equipment.indexOf(eqtoreplace) != -1) { /*dumb safeguard*/      self.equipment[self.equipment.indexOf(eqtoreplace)] = neweq; /*i don't know why this is necessary but it is; you're just not allowed to refer to equipment through variables when overwriting it with another equipment*/      neweq.animate(~flashandshake~); /*also two variables can't point to the same equipment i guess; doing eqtoreplace.animate(~flashandshake~) has no effect*/     }    } else {     var neweq = new elements.Equipment(swapto);     neweq.column = e.column;     neweq.row = e.row;     neweq.x = -9999;     neweq.y = -9999;     neweq.show = false;     neweq.availablethisturn = false;     if(self.equipment.indexOf(e) != -1) { /*dumb safeguard*/      self.equipment[self.equipment.indexOf(e)] = neweq;     }    }   }  },Barricade,NORMAL,,ORANGE,change_power,change_power,,none,0,YES,NO,,,,,,,,,,if(d == 6) { e.castdirection = 1; } else { e.castdirection = -1; },,donothing();,
Shiked Spield@sword_upgraded,Do [sword]<d6> damage. On 5[;]|switch to gaining [shield]shield,2,var swapto = ~Shiked Spield@shield~; if(d != 5) { attack(d); sfxdamage(target|d); } else { inflictself(SHIELD|d); sfx(~_shield~); if(getstatusself(FURY) < 1 && self.layout != ~DECK~) {    var eqtoreplace = ~~;    var onscreenreplace = false;    for(eq in self.equipment) {     /* determine if e is a copy of an equipment that is multiuse or had re-equip used on it; and if it is; store the original variable as eqtoreplace and enable the flag that tells us we're replacing an item already on screen. there's probably an easier way to do this but idk */     if(     e.name == eq.name &&      e.namemodifier == eq.namemodifier &&      (eq.x + 100) >= e.x &&      (eq.x - 100) <= e.x &&      eq != e) {       eqtoreplace = eq; onscreenreplace = true; break;     }    }    if(onscreenreplace) {     var neweq = new elements.Equipment(swapto);     neweq.x = eqtoreplace.x;     neweq.y = eqtoreplace.y;     neweq.row = eqtoreplace.row;     neweq.column = eqtoreplace.column;     if(self.equipment.indexOf(eqtoreplace) != -1) { /*dumb safeguard*/      self.equipment[self.equipment.indexOf(eqtoreplace)] = neweq; /*i don't know why this is necessary but it is; you're just not allowed to refer to equipment through variables when overwriting it with another equipment*/      neweq.animate(~flashandshake~); /*also two variables can't point to the same equipment i guess; doing eqtoreplace.animate(~flashandshake~) has no effect*/     }    } else {     var neweq = new elements.Equipment(swapto);     neweq.column = e.column;     neweq.row = e.row;     neweq.x = -9999;     neweq.y = -9999;     neweq.show = false;     neweq.availablethisturn = false;     if(self.equipment.indexOf(e) != -1) { /*dumb safeguard*/      self.equipment[self.equipment.indexOf(e)] = neweq;     }    }   }  },Plasma Gun,NORMAL,,RED,,,,none,0,NO,NO,,,,,,,,,,if(d != 5) { e.castdirection = 1; } else { e.castdirection = -1; },,donothing();,
Shiked Spield@shield_upgraded,Gain [shield]<d6> shield. On 5[;]|switch to doing [sword]damage,2,var swapto = ~Shiked Spield@sword~; if(d != 5) { inflictself(SHIELD|d); sfx(~_shield~); } else { attack(d); sfxdamage(target|d); if(getstatusself(FURY) < 1 && self.layout != ~DECK~) {    var eqtoreplace = ~~;    var onscreenreplace = false;    for(eq in self.equipment) {     /* determine if e is a copy of an equipment that is multiuse or had re-equip used on it; and if it is; store the original variable as eqtoreplace and enable the flag that tells us we're replacing an item already on screen. there's probably an easier way to do this but idk */     if(     e.name == eq.name &&      e.namemodifier == eq.namemodifier &&      (eq.x + 100) >= e.x &&      (eq.x - 100) <= e.x &&      eq != e) {       eqtoreplace = eq; onscreenreplace = true; break;     }    }    if(onscreenreplace) {     var neweq = new elements.Equipment(swapto);     neweq.x = eqtoreplace.x;     neweq.y = eqtoreplace.y;     neweq.row = eqtoreplace.row;     neweq.column = eqtoreplace.column;     if(self.equipment.indexOf(eqtoreplace) != -1) { /*dumb safeguard*/      self.equipment[self.equipment.indexOf(eqtoreplace)] = neweq; /*i don't know why this is necessary but it is; you're just not allowed to refer to equipment through variables when overwriting it with another equipment*/      neweq.animate(~flashandshake~); /*also two variables can't point to the same equipment i guess; doing eqtoreplace.animate(~flashandshake~) has no effect*/     }    } else {     var neweq = new elements.Equipment(swapto);     neweq.column = e.column;     neweq.row = e.row;     neweq.x = -9999;     neweq.y = -9999;     neweq.show = false;     neweq.availablethisturn = false;     if(self.equipment.indexOf(e) != -1) { /*dumb safeguard*/      self.equipment[self.equipment.indexOf(e)] = neweq;     }    }   }  },Barricade,NORMAL,,ORANGE,,,,none,0,YES,NO,,,,,,,,,,if(d == 5) { e.castdirection = 1; } else { e.castdirection = -1; },,donothing();,
Shiked Spield@sword_downgraded,Do [sword]<d6> damage,2,attack(d); sfxdamage(target|d);,Plasma Gun,MAX4,,RED,,,,none,0,NO,NO,,,,,,,,,,,,donothing();,
Shiked Spield@shield_downgraded,Gain [shield]<d6> shield,2,inflictself(SHIELD|d); sfx(~_shield~);,Barricade,MAX4,,ORANGE,,,,none,0,YES,NO,,,,,,,,,,,,donothing();,
Pocket Protector,Gain [shield]2 shield|[gray](single usen't),1,inflictself(SHIELD|2);,Safeguard,MIN3,,ORANGE,change_power,change_power,,_shield,4,YES,NO,,1,,,,,,,,,,,
Pocket Protector_upgraded,Gain [shield]3 shield|[gray](single usen't),1,inflictself(SHIELD|3);,Safeguard,MIN3,,ORANGE,,,,_shield,4,YES,NO,,,,,,,,,,,,,
Pocket Protector_downgraded,Gain [shield]1 shield|[gray](single usen't),1,inflictself(SHIELD|1);,Safeguard,MIN3,,ORANGE,,,,_shield,4,YES,NO,,,,,,,,,,,,,
Strychnine,Inflict [poison]<timesused> poison[;]|+1 each turn,1,inflict(POISON|turn); e.timesused -= 1; /*someone from the dicecord suggested this a while ago when i showed off ice nine and pyrotechnix but i forget who and search isn't returning anything*/,Anthrax,NORMAL|NORMAL,9,PURPLE,change_power,change_power,,_poison,0,NO,NO,,1,,,,,,e.timesused += 1;,,,,,
Strychnine_downgraded,Inflict [poison]<timesused> poison[;]|+1 each turn,1,inflict(POISON|turn); e.timesused -= 1;,Anthrax,REQUIRE6|REQUIRE3,,PURPLE,,,,_poison,0,NO,NO,,,,,,,,e.timesused += 1;,,,,,
Strychnine_upgraded,Inflict [poison]<timesused> poison[;]|+1 each turn,1,inflict(POISON|turn); e.timesused -= 1;,Anthrax,COUNTDOWN,9,PURPLE,,,,_poison,0,NO,NO,,,,,,,,e.timesused += 1;,,,,,
Bulldozer,Do [weaken]8 damage[;] if filled|perfectly[;] inflict [weaken]3 weaken,2,attack(8|WEAKEN); var myname = ~dicehistorytemp~ + self.getvar(~fixedeqlist~).indexOf(e); trace(~----~); trace(e.dicehistory.length); trace(e.dicehistory); trace(self.getvar(myname)); trace(self.getvar(myname).length); trace(~----~); if((e.dicehistory.length < 1) && self.getvar(myname).length >= e.dicehistory.length && self.getvar(myname).length != null) { trace(~thingdoing!~); e.dicehistory = self.getvar(myname).concat(e.dicehistory); } self.setvar(myname|e.dicehistory.copy()); var sum = 0; for (i in 0...e.dicehistory.length) { sum = sum + e.dicehistory[i].basevalue; } if (sum == e.countdown) { inflict(WEAKEN|3); sfx(~_weaken~); } if(self.getvar(~furying~) < 1) { trace(~resetting!~); e.dicehistory = []; self.resetvar(myname); } self.setvar(~furying~|self.getvar(~furying~) - 1);,Scream,COUNTDOWN,16,ORANGE,change_power,change_power,,_damage,0,NO,NO,cannotreuse,,,var myfixedeqlist = self.getvar(~fixedeqlist~); if(myfixedeqlist.length > 0) { var myname = ~dicehistorytemp~ + myfixedeqlist.indexOf(e); self.resetvar(myname); } self.resetvar(~fixedeqlist~); self.setvar(~fixedeqlist~|self.equipment.copy());,var myfixedeqlist = self.getvar(~fixedeqlist~); if(myfixedeqlist.length > 0) { var myname = ~dicehistorytemp~ + myfixedeqlist.indexOf(e); self.resetvar(myname); } self.resetvar(~fixedeqlist~); ,if(e.timesused > 0) { var myname = ~dicehistorytemp~ + self.getvar(~fixedeqlist~).indexOf(e); e.dicehistory = []; self.resetvar(myname); } e.timesused = 0;,,,,,,self.setvar(~furying~|getstatusself(FURY)); trace(~fury!: ~ + self.getvar(~furying~));,var myname = ~dicehistorytemp~ + self.getvar(~fixedeqlist~).indexOf(e); trace(e.dicehistory.length); trace(e.dicehistory); trace(self.getvar(myname)); trace(self.getvar(myname).length); if((e.dicehistory.length == 1) && self.getvar(myname).length >= e.dicehistory.length && self.getvar(myname).length != null) { trace(~thingdoing!~); e.dicehistory = self.getvar(myname).concat(e.dicehistory); } self.setvar(myname|e.dicehistory.copy());
Bulldozer_upgraded,Do [weaken]8 damage[;] if filled|perfectly[;] inflict [weaken]3 weaken,2,attack(8|WEAKEN); var myname = ~dicehistorytemp~ + self.getvar(~fixedeqlist~).indexOf(e); trace(~----~); trace(e.dicehistory.length); trace(e.dicehistory); trace(self.getvar(myname)); trace(self.getvar(myname).length); trace(~----~); if((e.dicehistory.length < 1) && self.getvar(myname).length >= e.dicehistory.length && self.getvar(myname).length != null) { trace(~thingdoing!~); e.dicehistory = self.getvar(myname).concat(e.dicehistory); } self.setvar(myname|e.dicehistory.copy()); var sum = 0; for (i in 0...e.dicehistory.length) { sum = sum + e.dicehistory[i].basevalue; } if (sum == e.countdown) { inflict(WEAKEN|3); sfx(~_weaken~); } if(self.getvar(~furying~) < 1) { trace(~resetting!~); e.dicehistory = []; self.resetvar(myname); } self.setvar(~furying~|self.getvar(~furying~) - 1);,Scream,COUNTDOWN,12,ORANGE,,,,_damage,0,NO,NO,cannotreuse,,,var myfixedeqlist = self.getvar(~fixedeqlist~); if(myfixedeqlist.length > 0) { var myname = ~dicehistorytemp~ + myfixedeqlist.indexOf(e); self.resetvar(myname); } self.resetvar(~fixedeqlist~); self.setvar(~fixedeqlist~|self.equipment.copy());,var myfixedeqlist = self.getvar(~fixedeqlist~); if(myfixedeqlist.length > 0) { var myname = ~dicehistorytemp~ + myfixedeqlist.indexOf(e); self.resetvar(myname); } self.resetvar(~fixedeqlist~); ,if(e.timesused > 0) { var myname = ~dicehistorytemp~ + self.getvar(~fixedeqlist~).indexOf(e); e.dicehistory = []; self.resetvar(myname); } e.timesused = 0;,,,,,,self.setvar(~furying~|getstatusself(FURY)); trace(~fury!: ~ + self.getvar(~furying~));,var myname = ~dicehistorytemp~ + self.getvar(~fixedeqlist~).indexOf(e); trace(e.dicehistory.length); trace(e.dicehistory); trace(self.getvar(myname)); trace(self.getvar(myname).length); if((e.dicehistory.length == 1) && self.getvar(myname).length >= e.dicehistory.length && self.getvar(myname).length != null) { trace(~thingdoing!~); e.dicehistory = self.getvar(myname).concat(e.dicehistory); } self.setvar(myname|e.dicehistory.copy());
Bulldozer_downgraded,Do [weaken]8 damage[;] if filled|perfectly[;] inflict [weaken]1 weaken,2,attack(8|WEAKEN); var myname = ~dicehistorytemp~ + self.getvar(~fixedeqlist~).indexOf(e); trace(~----~); trace(e.dicehistory.length); trace(e.dicehistory); trace(self.getvar(myname)); trace(self.getvar(myname).length); trace(~----~); if((e.dicehistory.length < 1) && self.getvar(myname).length >= e.dicehistory.length && self.getvar(myname).length != null) { trace(~thingdoing!~); e.dicehistory = self.getvar(myname).concat(e.dicehistory); } self.setvar(myname|e.dicehistory.copy()); var sum = 0; for (i in 0...e.dicehistory.length) { sum = sum + e.dicehistory[i].basevalue; } if (sum == e.countdown) { inflict(WEAKEN|1); sfx(~_weaken~); } if(self.getvar(~furying~) < 1) { trace(~resetting!~); e.dicehistory = []; self.resetvar(myname); } self.setvar(~furying~|self.getvar(~furying~) - 1);,Scream,COUNTDOWN,16,ORANGE,,,,_damage,0,NO,NO,cannotreuse,,,,var myfixedeqlist = self.getvar(~fixedeqlist~); if(myfixedeqlist.length > 0) { var myname = ~dicehistorytemp~ + myfixedeqlist.indexOf(e); self.resetvar(myname); } self.resetvar(~fixedeqlist~); ,if(e.timesused > 0) { var myname = ~dicehistorytemp~ + self.getvar(~fixedeqlist~).indexOf(e); e.dicehistory = []; self.resetvar(myname); } e.timesused = 0;,,,,,,self.setvar(~furying~|getstatusself(FURY)); trace(~fury!: ~ + self.getvar(~furying~));,var myname = ~dicehistorytemp~ + self.getvar(~fixedeqlist~).indexOf(e); trace(e.dicehistory.length); trace(e.dicehistory); trace(self.getvar(myname)); trace(self.getvar(myname).length); if((e.dicehistory.length == 1) && self.getvar(myname).length >= e.dicehistory.length && self.getvar(myname).length != null) { trace(~thingdoing!~); e.dicehistory = self.getvar(myname).concat(e.dicehistory); } self.setvar(myname|e.dicehistory.copy());
Bulldozer_weakened,Do [weaken]8 damage[;] if filled|perfectly[;] inflict [weaken]1 weaken,2,attack(8|WEAKEN); var myname = ~dicehistorytemp~ + self.getvar(~fixedeqlist~).indexOf(e); trace(~----~); trace(e.dicehistory.length); trace(e.dicehistory); trace(self.getvar(myname)); trace(self.getvar(myname).length); trace(~----~); if((e.dicehistory.length < 1) && self.getvar(myname).length >= e.dicehistory.length && self.getvar(myname).length != null) { trace(~thingdoing!~); e.dicehistory = self.getvar(myname).concat(e.dicehistory); } self.setvar(myname|e.dicehistory.copy()); var sum = 0; for (i in 0...e.dicehistory.length) { sum = sum + e.dicehistory[i].basevalue; } if (sum == e.countdown) { inflict(WEAKEN1); sfx(~_weaken~); } if(self.getvar(~furying~) < 1) { trace(~resetting!~); e.dicehistory = []; self.resetvar(myname); } self.setvar(~furying~|self.getvar(~furying~) - 1);,Scream,COUNTDOWN,12,ORANGE,,,,_damage,0,NO,NO,cannotreuse,,,,var myfixedeqlist = self.getvar(~fixedeqlist~); if(myfixedeqlist.length > 0) { var myname = ~dicehistorytemp~ + myfixedeqlist.indexOf(e); self.resetvar(myname); } self.resetvar(~fixedeqlist~); ,if(e.timesused > 0) { var myname = ~dicehistorytemp~ + self.getvar(~fixedeqlist~).indexOf(e); e.dicehistory = []; self.resetvar(myname); } e.timesused = 0;,,,,,,self.setvar(~furying~|getstatusself(FURY)); trace(~fury!: ~ + self.getvar(~furying~));,var myname = ~dicehistorytemp~ + self.getvar(~fixedeqlist~).indexOf(e); trace(e.dicehistory.length); trace(e.dicehistory); trace(self.getvar(myname)); trace(self.getvar(myname).length); if((e.dicehistory.length == 1) && self.getvar(myname).length >= e.dicehistory.length && self.getvar(myname).length != null) { trace(~thingdoing!~); e.dicehistory = self.getvar(myname).concat(e.dicehistory); } self.setvar(myname|e.dicehistory.copy());
Bulldozer 40K,Do [weaken]40000 dmg[;] if filled|perfectly[;] inflict [weaken]20000[]|[80%][gray]''I don't get it.''[],2,attack(40000|WEAKEN); var myname = ~dicehistorytemp~ + self.getvar(~fixedeqlist~).indexOf(e); trace(~----~); trace(e.dicehistory.length); trace(e.dicehistory); trace(self.getvar(myname)); trace(self.getvar(myname).length); trace(~----~); if((e.dicehistory.length < 1) && self.getvar(myname).length >= e.dicehistory.length && self.getvar(myname).length != null) { trace(~thingdoing!~); e.dicehistory = self.getvar(myname).concat(e.dicehistory); } self.setvar(myname|e.dicehistory.copy()); var sum = 0; for (i in 0...e.dicehistory.length) { sum = sum + e.dicehistory[i].basevalue; } if (sum == e.countdown) { inflict(WEAKEN|20000); sfx(~_weaken~); } if(self.getvar(~furying~) < 1) { trace(~resetting!~); e.dicehistory = []; self.resetvar(myname); } self.setvar(~furying~|self.getvar(~furying~) - 1);,Scream,COUNTDOWN,99,ORANGE,change_power,change_power,,_damage,0,NO,NO,excludefromrandomlists|cannotreuse,,,var myfixedeqlist = self.getvar(~fixedeqlist~); if(myfixedeqlist.length > 0) { var myname = ~dicehistorytemp~ + myfixedeqlist.indexOf(e); self.resetvar(myname); } self.resetvar(~fixedeqlist~); self.setvar(~fixedeqlist~|self.equipment.copy());,var myfixedeqlist = self.getvar(~fixedeqlist~); if(myfixedeqlist.length > 0) { var myname = ~dicehistorytemp~ + myfixedeqlist.indexOf(e); self.resetvar(myname); } self.resetvar(~fixedeqlist~); ,if(e.timesused > 0) { var myname = ~dicehistorytemp~ + self.getvar(~fixedeqlist~).indexOf(e); e.dicehistory = []; self.resetvar(myname); } e.timesused = 0;,,,,,,self.setvar(~furying~|getstatusself(FURY)); trace(~fury!: ~ + self.getvar(~furying~));,var myname = ~dicehistorytemp~ + self.getvar(~fixedeqlist~).indexOf(e); trace(e.dicehistory.length); trace(e.dicehistory); trace(self.getvar(myname)); trace(self.getvar(myname).length); if((e.dicehistory.length == 1) && self.getvar(myname).length >= e.dicehistory.length && self.getvar(myname).length != null) { trace(~thingdoing!~); e.dicehistory = self.getvar(myname).concat(e.dicehistory); } self.setvar(myname|e.dicehistory.copy());
Bulldozer 40K_upgraded,Do [weaken]40000 dmg[;] if filled|perfectly[;] inflict [weaken]20000[]|[80%][gray]''I don't get it.''[],2,attack(40000|WEAKEN); var myname = ~dicehistorytemp~ + self.getvar(~fixedeqlist~).indexOf(e); trace(~----~); trace(e.dicehistory.length); trace(e.dicehistory); trace(self.getvar(myname)); trace(self.getvar(myname).length); trace(~----~); if((e.dicehistory.length < 1) && self.getvar(myname).length >= e.dicehistory.length && self.getvar(myname).length != null) { trace(~thingdoing!~); e.dicehistory = self.getvar(myname).concat(e.dicehistory); } self.setvar(myname|e.dicehistory.copy()); var sum = 0; for (i in 0...e.dicehistory.length) { sum = sum + e.dicehistory[i].basevalue; } if (sum == e.countdown) { inflict(WEAKEN|20000); sfx(~_weaken~); } if(self.getvar(~furying~) < 1) { trace(~resetting!~); e.dicehistory = []; self.resetvar(myname); } self.setvar(~furying~|self.getvar(~furying~) - 1);,Scream,COUNTDOWN,74,ORANGE,,,,_damage,0,NO,NO,excludefromrandomlists|cannotreuse,,,var myfixedeqlist = self.getvar(~fixedeqlist~); if(myfixedeqlist.length > 0) { var myname = ~dicehistorytemp~ + myfixedeqlist.indexOf(e); self.resetvar(myname); } self.resetvar(~fixedeqlist~); self.setvar(~fixedeqlist~|self.equipment.copy());,var myfixedeqlist = self.getvar(~fixedeqlist~); if(myfixedeqlist.length > 0) { var myname = ~dicehistorytemp~ + myfixedeqlist.indexOf(e); self.resetvar(myname); } self.resetvar(~fixedeqlist~); ,if(e.timesused > 0) { var myname = ~dicehistorytemp~ + self.getvar(~fixedeqlist~).indexOf(e); e.dicehistory = []; self.resetvar(myname); } e.timesused = 0;,,,,,,self.setvar(~furying~|getstatusself(FURY)); trace(~fury!: ~ + self.getvar(~furying~));,var myname = ~dicehistorytemp~ + self.getvar(~fixedeqlist~).indexOf(e); trace(e.dicehistory.length); trace(e.dicehistory); trace(self.getvar(myname)); trace(self.getvar(myname).length); if((e.dicehistory.length == 1) && self.getvar(myname).length >= e.dicehistory.length && self.getvar(myname).length != null) { trace(~thingdoing!~); e.dicehistory = self.getvar(myname).concat(e.dicehistory); } self.setvar(myname|e.dicehistory.copy());
Bulldozer 40K_downgraded,Do [weaken]40000 dmg[;] if filled|perfectly[;] inflict [weaken]2000[]|[80%][gray]''I don't get it.''[],2,attack(40000|WEAKEN); var myname = ~dicehistorytemp~ + self.getvar(~fixedeqlist~).indexOf(e); trace(~----~); trace(e.dicehistory.length); trace(e.dicehistory); trace(self.getvar(myname)); trace(self.getvar(myname).length); trace(~----~); if((e.dicehistory.length < 1) && self.getvar(myname).length >= e.dicehistory.length && self.getvar(myname).length != null) { trace(~thingdoing!~); e.dicehistory = self.getvar(myname).concat(e.dicehistory); } self.setvar(myname|e.dicehistory.copy()); var sum = 0; for (i in 0...e.dicehistory.length) { sum = sum + e.dicehistory[i].basevalue; } if (sum == e.countdown) { inflict(WEAKEN|2000); sfx(~_weaken~); } if(self.getvar(~furying~) < 1) { trace(~resetting!~); e.dicehistory = []; self.resetvar(myname); } self.setvar(~furying~|self.getvar(~furying~) - 1);,Scream,COUNTDOWN,99,ORANGE,,,,_damage,0,NO,NO,excludefromrandomlists|cannotreuse,,,,var myfixedeqlist = self.getvar(~fixedeqlist~); if(myfixedeqlist.length > 0) { var myname = ~dicehistorytemp~ + myfixedeqlist.indexOf(e); self.resetvar(myname); } self.resetvar(~fixedeqlist~); ,if(e.timesused > 0) { var myname = ~dicehistorytemp~ + self.getvar(~fixedeqlist~).indexOf(e); e.dicehistory = []; self.resetvar(myname); } e.timesused = 0;,,,,,,self.setvar(~furying~|getstatusself(FURY)); trace(~fury!: ~ + self.getvar(~furying~));,var myname = ~dicehistorytemp~ + self.getvar(~fixedeqlist~).indexOf(e); trace(e.dicehistory.length); trace(e.dicehistory); trace(self.getvar(myname)); trace(self.getvar(myname).length); if((e.dicehistory.length == 1) && self.getvar(myname).length >= e.dicehistory.length && self.getvar(myname).length != null) { trace(~thingdoing!~); e.dicehistory = self.getvar(myname).concat(e.dicehistory); } self.setvar(myname|e.dicehistory.copy());
Bulldozer 40K_weakened,Do [weaken]40000 dmg[;] if filled|perfectly[;] inflict [weaken]2000[]|[80%][gray]''I don't get it.''[],2,attack(40000|WEAKEN); var myname = ~dicehistorytemp~ + self.getvar(~fixedeqlist~).indexOf(e); trace(~----~); trace(e.dicehistory.length); trace(e.dicehistory); trace(self.getvar(myname)); trace(self.getvar(myname).length); trace(~----~); if((e.dicehistory.length < 1) && self.getvar(myname).length >= e.dicehistory.length && self.getvar(myname).length != null) { trace(~thingdoing!~); e.dicehistory = self.getvar(myname).concat(e.dicehistory); } self.setvar(myname|e.dicehistory.copy()); var sum = 0; for (i in 0...e.dicehistory.length) { sum = sum + e.dicehistory[i].basevalue; } if (sum == e.countdown) { inflict(WEAKEN|2000); sfx(~_weaken~); } if(self.getvar(~furying~) < 1) { trace(~resetting!~); e.dicehistory = []; self.resetvar(myname); } self.setvar(~furying~|self.getvar(~furying~) - 1);,Scream,COUNTDOWN,74,ORANGE,,,,_damage,0,NO,NO,excludefromrandomlists|cannotreuse,,,,var myfixedeqlist = self.getvar(~fixedeqlist~); if(myfixedeqlist.length > 0) { var myname = ~dicehistorytemp~ + myfixedeqlist.indexOf(e); self.resetvar(myname); } self.resetvar(~fixedeqlist~); ,if(e.timesused > 0) { var myname = ~dicehistorytemp~ + self.getvar(~fixedeqlist~).indexOf(e); e.dicehistory = []; self.resetvar(myname); } e.timesused = 0;,,,,,,self.setvar(~furying~|getstatusself(FURY)); trace(~fury!: ~ + self.getvar(~furying~));,var myname = ~dicehistorytemp~ + self.getvar(~fixedeqlist~).indexOf(e); trace(e.dicehistory.length); trace(e.dicehistory); trace(self.getvar(myname)); trace(self.getvar(myname).length); if((e.dicehistory.length == 1) && self.getvar(myname).length >= e.dicehistory.length && self.getvar(myname).length != null) { trace(~thingdoing!~); e.dicehistory = self.getvar(myname).concat(e.dicehistory); } self.setvar(myname|e.dicehistory.copy());
Sap Gloves,Do [sword]<d6> damage[;] gain|[shield]<d6>[orange]/2[] shield (rounds up),2,attack(d); var inflictamount = d * 0.5; if(inflictamount % 1 != 0) { inflictamount += 0.5; } inflictself(SHIELD|inflictamount); sfx(~_shield~|~~|0.1); /*this is the sort of generator filler that made me go 'wait haven't 500 people probably made this already' and by 500 people i mean jackeea. closest thing more fluff has to this is sunder; 'do x damage; recover health equal to half of x'; base max 5 then upgrades to normal. it's still possible other people have made exactly this item before but if they did i wasn't looking*/,Protection,MAX3|MAX3,,ORANGE,change_power,change_power,,_damage,0,NO,NO,,,,,,,,,,,,,
Sap Gloves_upgraded,Do [sword]<d6> damage[;] gain|[shield]<d6>[orange]/2[] shield (rounds up),2,attack(d); var inflictamount = d * 0.5; if(inflictamount % 1 != 0) { inflictamount += 0.5; } inflictself(SHIELD|inflictamount); sfx(~_shield~|~~|0.1);,Protection,NORMAL,,ORANGE,,,,_damage,0,NO,NO,,,,,,,,,,,,,
Sap Gloves_downgraded,Do [sword]<d6> damage,2,attack(d);,Protection,MAX3|MAX3,,ORANGE,,,,_damage,0,NO,NO,,,,,,,,,,,,,
Doppeldfire,Double and duplicate dice[;]|but [fire]burn resulting copies,1,var dicetogive = []; d * 2 > 6 ? dicetogive = [6|(d * 2) - 6|6|(d * 2) - 6] : dicetogive = [d * 2|d * 2]; inflictself(FIRE|dicetogive.length); givedice(dicetogive); /*made before jacke's marshsword; actually showcased it in the modding channel and he asked if he could repurpose the pun. also tertiary operators because screw you lol*/ /*i still look at this sometimes and go ''wait; why doesn't this have an ice equiva- god dammit''*/,Hellfire,MAX3,,RED,simplify,change_power,,_fire,0,YES,NO,,1,,,,,,,,,,,
Doppeldfire_downgraded,Duplicate dice[;]|but [fire]burn resulting copies,1,var dicetogive = [d|d]; inflictself(FIRE|dicetogive.length); givedice(dicetogive);,Hellfire,MAX3,,RED,,,,_fire,0,YES,NO,,,,,,,,,,,,,
Doppeldspook,Double and duplicate dice[;]|but receive [vanish]2 vanish|(other dupes vanish first),1,var dicetogive = []; d * 2 > 6 ? dicetogive = [6|(d * 2) - 6|6|(d * 2) - 6] : dicetogive = [d * 2|d * 2]; inflictself(~ncr_vanish~|dicetogive.length); givedice(dicetogive);,Strobe Light,MAX3,,PINK,change_power,change_power,,_vanish,0,YES,NO,,1,,,,,,,,,,,
Doppeldspook_upgraded,Double and duplicate dice[;]|but receive [vanish]2-4 vanish|(other dupes vanish first),1,var dicetogive = []; d * 2 > 6 ? dicetogive = [6|(d * 2) - 6|6|(d * 2) - 6] : dicetogive = [d * 2|d * 2]; inflictself(~ncr_vanish~|dicetogive.length); givedice(dicetogive);,Strobe Light,NORMAL,,PINK,,,,_vanish,0,YES,NO,,,,,,,,,,,,,
Doppeldspook_downgraded,Duplicate dice[;]|but receive [vanish]2 vanish|(other dupes vanish first),1,var dicetogive = [d|d]; inflictself(~ncr_vanish~|dicetogive.length); givedice(dicetogive);,Strobe Light,MAX3,,PINK,,,,_vanish,0,YES,NO,,,,,,,,,,,,,
Snare Drum,Inflict [weaken]weaken|and [lock]lock,2,inflict(WEAKEN); inflict(LOCK); sfx(~_weaken~); sfx(~_lock~|~~|0.1); /*[6:56 PM] Wisp: what should a card named 'snare drum' do [6:56 PM] Wisp: the idea to name a card that just popped in my head and i have no clue why [6:59 PM] Jackeea: Lock and weaken; which annoys me because I've got an equipment that does that and 'snare drum' would have been a much better name :sweat_smile: [7:04 PM] Wisp: i swear that pun was on the tip of my tongue; thank you*/,Copyright Strike,REQUIRE6,,ORANGE,increaserange,change_power,,none,0,NO,NO,,,,,,,,,,,,,
Snare Drum_downgraded,Inflict [weaken]weaken|or [lock]lock,2,chance(50) ? { inflict(WEAKEN); sfx(~_weaken~); } : { inflict(LOCK); sfx(~_lock~); },Copyright Strike,REQUIRE6,,ORANGE,,,,none,0,NO,NO,,,,,,,,,,,,,
Halligan Bar,Do [sword]<d6> damage. On 6[;]|reduce countdowns by 3,2,attack(d); if(d == 6) boostcountdowns(3); /*this is based off a cody idea but i forgot what it's named! so i literally just went and looked at tool names on wikipedia*/,Turbo Boost,NORMAL,,GREEN,change_power,change_power,,_damage,0,NO,NO,,,,,,,,,,,,,
Halligan Bar_upgraded,Do [sword]<d6> damage. On even[;]|reduce countdowns by <d6>/2,2,attack(d); if(d % 2 == 0) boostcountdowns(d / 2);,Turbo Boost,NORMAL,,GREEN,,,,_damage,0,NO,NO,,,,,,,,,,,,,
Halligan Bar_downgraded,Do [sword]<d6> damage. On 6[;]|reduce countdowns by 3,2,attack(d); if(d == 6) boostcountdowns(3); /*wanted to do 'increase countdowns by 3' however i am too lazy to make it work with revolver & whatnot!*/,Turbo Boost,REQUIRE6,,GREEN,,,,_damage,0,NO,NO,,,,,,,,,,,,,
Delicious Fruit,50% chance to heal [heal]4[;]|otherwise[;] lose [heart]2 health,1,var odds = 50; if(getstatusself(~luck~) > 0){ odds = 100; } else if(getstatusself(~luck+~) > 0){ odds = 100; } if(chance(odds)) { attackself(-4); sfx(~_heal~); } else { pierceattackself(2); sfxdamage(self|2); },Rubber Bullet,ODD,,RED,simplify,change_power,,none,0,YES,NO,,1,,,,,,,,,,,
Delicious Fruit_downgraded,50% chance to heal [heal]4[;]|otherwise[;] lose [heart]4 health,1,var odds = 50; if(getstatusself(~luck~) > 0){ odds = 100; } else if(getstatusself(~luck+~) > 0){ odds = 100; } if(chance(odds)) { attackself(-4); sfx(~_heal~); } else { pierceattackself(4); sfxdamage(self|2); },Rubber Bullet,ODD,,RED,,,,none,0,YES,NO,,,,,,,,,,,,,
Revolver@ncrmod_deckupgrade,Do damage equal to|2x excess value inserted,2,var myname = ~dicehistorytemp~ + self.getvar(~fixedeqlist~).indexOf(e); trace(~----~); trace(e.dicehistory.length); trace(e.dicehistory); trace(self.getvar(myname)); trace(self.getvar(myname).length); trace(~----~); if((e.dicehistory.length < 1) && self.getvar(myname).length >= e.dicehistory.length && self.getvar(myname).length != null) { trace(~thingdoing!~); e.dicehistory = self.getvar(myname).concat(e.dicehistory); } self.setvar(myname|e.dicehistory.copy()); var sum = 0; var i = 0; while(true) {  if(i > e.dicehistory.length - 1) { trace(~UHHHHHH~); break; }  sum = sum + e.dicehistory[i].basevalue; sum++; trace(sum); trace(~i: ~ + i); i++;  if(sum >= e.countdown) break; } trace(~SPAM~); trace(sum); if (sum - e.countdown > 0) {  attack(2 * (sum - e.countdown)); sfx(~_fire~|~~|0.1);  /*sfxdamage(2 * (sum - e.countdown));*/ } else self.textparticle(~No effect!~); if(self.getvar(~furying~) < 1) { trace(~resetting!~); e.dicehistory = []; self.resetvar(myname); } self.setvar(~furying~|self.getvar(~furying~) - 1);,Dice Bash,COUNTDOWN,9,RED,,,,_damage,0,NO,NO,cannotreuse,,,var myfixedeqlist = self.getvar(~fixedeqlist~); if(myfixedeqlist.length > 0) { var myname = ~dicehistorytemp~ + myfixedeqlist.indexOf(e); self.resetvar(myname); } self.resetvar(~fixedeqlist~); self.setvar(~fixedeqlist~|self.equipment.copy());,var myfixedeqlist = self.getvar(~fixedeqlist~); if(myfixedeqlist.length > 0) { var myname = ~dicehistorytemp~ + myfixedeqlist.indexOf(e); self.resetvar(myname); } self.resetvar(~fixedeqlist~); ,if(e.timesused > 0) { var myname = ~dicehistorytemp~ + self.getvar(~fixedeqlist~).indexOf(e); e.dicehistory = []; self.resetvar(myname); } e.timesused = 0; /*kludge if this card gets cursed or is dodged*/,,,,,,self.setvar(~furying~|getstatusself(FURY)); trace(~fury!: ~ + self.getvar(~furying~));,var myname = ~dicehistorytemp~ + self.getvar(~fixedeqlist~).indexOf(e); trace(e.dicehistory.length); trace(e.dicehistory); trace(self.getvar(myname)); trace(self.getvar(myname).length); if((e.dicehistory.length == 1) && self.getvar(myname).length >= e.dicehistory.length && self.getvar(myname).length != null) { trace(~thingdoing!~); e.dicehistory = self.getvar(myname).concat(e.dicehistory); } self.setvar(myname|e.dicehistory.copy());
Halligan Bar_deckupgrade,Do [sword]<d6> damage. On even[;]|reduce countdowns by 3,2,attack(d); if(d % 2 == 0) boostcountdowns(3);,Turbo Boost,NORMAL,,GREEN,,,,_damage,0,NO,NO,,,,,,,,,,,,,
Hush,[silence]Silence enemy|[gray](once per battle),1,inflict(~ncr_silence~); bonus(1000);,Confiscate,EVEN,,BRIGHTCYAN,change_power,complicate,,_silence,0,NO,YES,,,,,,,,,,,,,
Hush_upgraded,[silence]Silence enemy[;]|return the dice|[gray](once per battle),1,inflict(~ncr_silence~); givedice(d); bonus(1000);,Confiscate,EVEN,,BRIGHTCYAN,,,,_silence,0,NO,YES,,,,,,,,,,,,,
Smart Spike,Do [sword]<d6> damage. At half|HP or lower[;] [shield]<d6> instead,1,if(self.hp <= (self.maxhp / 2)) { inflictself(SHIELD|d); sfx(~_shield~); } else { attack(d); sfxdamage(target|d); },Neutron Star,MAX5,,RED,change_power,complicate,,none,0,NO,NO,,1,,,,,,,,if(self.hp <= (self.maxhp / 2)) { e.castdirection = -1; } else { e.castdirection = 1; },,,
Smart Spike_upgraded,Do [sword]<d6> dmg. At half|HP or less[;] [shield]<d6> instead,1,if(self.hp <= (self.maxhp / 2)) { inflictself(SHIELD|d); sfx(~_shield~); } else { attack(d); sfxdamage(target|d); },Neutron Star,NORMAL|FREE1,,RED,,,,none,0,NO,NO,,,,,,,,,,if(self.hp <= (self.maxhp / 2)) { e.castdirection = -1; } else { e.castdirection = 1; },,,
Technology 2,Do [sword]<d6> dmg. Permanent|+1 to slot max or free dice|every two turns,2,attack(d); self.textparticle(~todo lol~);,,,,,,,,none,,,,excludefromrandomlists|unfinished,,,,,,,,,,,,
Schlock,Inflict [shock]shock|and [lock]lock,2,inflict(SHOCK); inflict(LOCK); sfx(~_shock~); sfx(~_lock~|~~|0.1);,Copyright Strike,REQUIRE6,,YELLOW,increaserange,change_power,,none,0,NO,NO,,,,,,,,,,,,,
Schlock_downgraded,Inflict [shock]shock|or [lock]lock,2,chance(50) ? { inflict(SHOCK); sfx(~_shock~); } : { inflict(LOCK); sfx(~_lock~); },Copyright Strike,REQUIRE6,,YELLOW,,,,none,0,NO,NO,,,,,,,,,,,,,
Wail Bat,Do [sword]<d6> damage|(get [silence]Silenced each turn),2,attack(d); sfxdamage(target|d);,Confiscate,NORMAL|FREE3,,PURPLE,reducesize,change_power,,none,0,NO,NO,cannotsteal|excludefromrandomlists,,,,,var s = new elements.Skill(~Against all odds_old~); s.script = ~inflict(SILENCE);~; s.execute(target|self);,,,,,,,
Wail Bat_downgraded,Do [sword]<d6> damage|(get [silence]Silenced each turn),2,attack(d); sfxdamage(target|d);,Confiscate,NORMAL|FREE1,,PURPLE,,,,none,0,NO,NO,cannotsteal|excludefromrandomlists,,,,,var s = new elements.Skill(~Against all odds_old~); s.script = ~inflict(SILENCE);~; s.execute(target|self);,,,,,,,
Wail Bat_weakened,Do [sword]<d6> damage|(get [silence]Silenced each turn),1,attack(d); sfxdamage(target|d);,Confiscate,NORMAL|FREE1,,PURPLE,,,,none,0,NO,NO,cannotsteal|excludefromrandomlists,,,,,var s = new elements.Skill(~Against all odds_old~); s.script = ~inflict(SILENCE);~; s.execute(target|self);,,,,,,,
Hail Bat,Do [sword]<d6> damage|(get [ice]2 freeze each turn),2,attack(d); sfxdamage(target|d);,Arctic Storm,NORMAL|FREE3,,BRIGHTCYAN,reducesize,change_power,,none,0,NO,NO,,,,,,,var iceisalt = false; var dummyfighter = new elements.Fighter(~Wisp~); dummyfighter.addstatus(~ice~|1); trace(dummyfighter.status.length); if(dummyfighter.status.length > 0) { for(stat in dummyfighter.status) { if(stat.type == ~alternate_ice~) { iceisalt = true; } } } inflictself(ICE|2); var inflictwhat = iceisalt ? ~alternate_ice~ : ~ice~; if(inflictwhat == ~ice~) { var dicelist = []; for(mydice in self.dicepool) { if(mydice.available() && mydice.burn != true && mydice.alternateburn != true) { dicelist.push(mydice); } } if(dicelist.length > 0) { dicelist.sort(function(a|b) return -1 * (a.basevalue - b.basevalue)); dicelist[0].animate(~ice~); } if(dicelist.length > 1) { dicelist[1].animate(~ice~|0.2); } } if(inflictwhat == ~alternate_ice~) { for(mydice in self.dicepool) { if(mydice.available() && mydice.burn != true && mydice.alternateburn != true) { mydice.animate(~alternate_ice~); mydice.animate(~alternate_ice~|0.2); } } } if(self.status.length > 0) { for(stat in self.status) { if(stat.type == inflictwhat) { stat.value -= 2; } } },,,,,,
Fuel Bat,Do [sword]<d6> damage|(get [fire]2 burn each turn),2,attack(d); sfxdamage(target|d);,Heat Ray,NORMAL|FREE3,,RED,reducesize,change_power,,none,0,NO,NO,,,,,,,var fireisalt = false; var dummyfighter = new elements.Fighter(~Wisp~); dummyfighter.addstatus(~fire~|1); trace(dummyfighter.status.length); if(dummyfighter.status.length > 0) { for(stat in dummyfighter.status) { if(stat.type == ~alternate_fire~) { fireisalt = true; } } } inflictself(FIRE|2); var inflictwhat = fireisalt ? ~alternate_fire~ : ~fire~; var dicelist = []; if(self.dicepool.length > 0) { for(mydice in self.dicepool) { if(mydice.available() && mydice.burn != true && mydice.alternateburn != true) { dicelist.push(mydice); } } if(dicelist.length > 0) { dicelist[0].animate(inflictwhat); } if(dicelist.length > 1) { dicelist[1].animate(inflictwhat|0.2); } } e.animate(~flashandshake~); if(self.status.length > 0) { for(stat in self.status) { if(stat.type == inflictwhat) { stat.value -= 2; } } },,,,,,
Katsuhiro Bat,Do [sword]<d6> damage|(get [vanish]2 vanish each turn)|[80%][gray]''A nice card for cute children''[],2,attack(d); sfxdamage(target|d);,Strobe Light,NORMAL|FREE3,,PINK,reducesize,change_power,,none,0,NO,NO,,,,,,,inflictself(~ncr_vanish~|2); e.animate(~flashandshake~);,,,,,,
Katsuhiro Bat_downgraded,Do [sword]<d6> damage|(get [vanish]2 vanish each turn)|[80%][gray]''A nice card for cute children''[],2,attack(d); sfxdamage(target|d);,Strobe Light,NORMAL|FREE1,,PINK,,,,none,0,NO,NO,,,,,,,inflictself(~ncr_vanish~|2); e.animate(~flashandshake~);,,,,,,
Katsuhiro Bat_weakened,Do [sword]<d6> damage|(get [vanish]2 vanish each turn)|[80%][gray]''A nice card for cute children''[],1,attack(d); sfxdamage(target|d);,Strobe Light,NORMAL|FREE1,,PINK,,,,none,0,NO,NO,,,,,,,inflictself(~ncr_vanish~|2); e.animate(~flashandshake~);,,,,,,
Hail Bat_downgraded,Do [sword]<d6> damage|(get [ice]2 freeze each turn),2,attack(d); sfxdamage(target|d);,Arctic Storm,NORMAL|FREE1,,BRIGHTCYAN,,,,none,0,NO,NO,,,,,,,var iceisalt = false; var dummyfighter = new elements.Fighter(~Wisp~); dummyfighter.addstatus(~ice~|1); trace(dummyfighter.status.length); if(dummyfighter.status.length > 0) { for(stat in dummyfighter.status) { if(stat.type == ~alternate_ice~) { iceisalt = true; } } } inflictself(ICE|2); var inflictwhat = iceisalt ? ~alternate_ice~ : ~ice~; if(inflictwhat == ~ice~) { var dicelist = []; for(mydice in self.dicepool) { if(mydice.available() && mydice.burn != true && mydice.alternateburn != true) { dicelist.push(mydice); } } if(dicelist.length > 0) { dicelist.sort(function(a|b) return -1 * (a.basevalue - b.basevalue)); dicelist[0].animate(~ice~); } if(dicelist.length > 1) { dicelist[1].animate(~ice~|0.2); } } if(inflictwhat == ~alternate_ice~) { for(mydice in self.dicepool) { if(mydice.available() && mydice.burn != true && mydice.alternateburn != true) { mydice.animate(~alternate_ice~); mydice.animate(~alternate_ice~|0.2); } } } if(self.status.length > 0) { for(stat in self.status) { if(stat.type == inflictwhat) { stat.value -= 2; } } },,,,,,
Fuel Bat_downgraded,Do [sword]<d6> damage|(get [fire]2 burn each turn),2,attack(d); sfxdamage(target|d);,Heat Ray,NORMAL|FREE1,,RED,,,,none,0,NO,NO,,,,,,,var fireisalt = false; var dummyfighter = new elements.Fighter(~Wisp~); dummyfighter.addstatus(~fire~|1); trace(dummyfighter.status.length); if(dummyfighter.status.length > 0) { for(stat in dummyfighter.status) { if(stat.type == ~alternate_fire~) { fireisalt = true; } } } inflictself(FIRE|2); var inflictwhat = fireisalt ? ~alternate_fire~ : ~fire~; var dicelist = []; if(self.dicepool.length > 0) { for(mydice in self.dicepool) { if(mydice.available() && mydice.burn != true && mydice.alternateburn != true) { dicelist.push(mydice); } } if(dicelist.length > 0) { dicelist[0].animate(inflictwhat); } if(dicelist.length > 1) { dicelist[1].animate(inflictwhat|0.2); } } e.animate(~flashandshake~); if(self.status.length > 0) { for(stat in self.status) { if(stat.type == inflictwhat) { stat.value -= 2; } } },,,,,,
Hail Bat_weakened,Do [sword]<d6> damage|(get [ice]2 freeze each turn),1,attack(d); sfxdamage(target|d);,Arctic Storm,NORMAL|FREE1,,BRIGHTCYAN,,,,none,0,NO,NO,,,,,,,var iceisalt = false; var dummyfighter = new elements.Fighter(~Wisp~); dummyfighter.addstatus(~ice~|1); trace(dummyfighter.status.length); if(dummyfighter.status.length > 0) { for(stat in dummyfighter.status) { if(stat.type == ~alternate_ice~) { iceisalt = true; } } } inflictself(ICE|2); var inflictwhat = iceisalt ? ~alternate_ice~ : ~ice~; if(inflictwhat == ~ice~) { var dicelist = []; for(mydice in self.dicepool) { if(mydice.available() && mydice.burn != true && mydice.alternateburn != true) { dicelist.push(mydice); } } if(dicelist.length > 0) { dicelist.sort(function(a|b) return -1 * (a.basevalue - b.basevalue)); dicelist[0].animate(~ice~); } if(dicelist.length > 1) { dicelist[1].animate(~ice~|0.2); } } if(inflictwhat == ~alternate_ice~) { for(mydice in self.dicepool) { if(mydice.available() && mydice.burn != true && mydice.alternateburn != true) { mydice.animate(~alternate_ice~); mydice.animate(~alternate_ice~|0.2); } } } if(self.status.length > 0) { for(stat in self.status) { if(stat.type == inflictwhat) { stat.value -= 2; } } },,,,,,
Fuel Bat_weakened,Do [sword]<d6> damage|(get [fire]2 burn each turn),1,attack(d); sfxdamage(target|d);,Heat Ray,NORMAL|FREE1,,RED,,,,none,0,NO,NO,,,,,,,var fireisalt = false; var dummyfighter = new elements.Fighter(~Wisp~); dummyfighter.addstatus(~fire~|1); trace(dummyfighter.status.length); if(dummyfighter.status.length > 0) { for(stat in dummyfighter.status) { if(stat.type == ~alternate_fire~) { fireisalt = true; } } } inflictself(FIRE|2); var inflictwhat = fireisalt ? ~alternate_fire~ : ~fire~; var dicelist = []; if(self.dicepool.length > 0) { for(mydice in self.dicepool) { if(mydice.available() && mydice.burn != true && mydice.alternateburn != true) { dicelist.push(mydice); } } if(dicelist.length > 0) { dicelist[0].animate(inflictwhat); } if(dicelist.length > 1) { dicelist[1].animate(inflictwhat|0.2); } } e.animate(~flashandshake~); if(self.status.length > 0) { for(stat in self.status) { if(stat.type == inflictwhat) { stat.value -= 2; } } },,,,,,
Circuit Breaker,Do [sword] for 1st dice[;]|inflict [shock] for 2nd dice,1,attack(actualdice[0].basevalue); inflict(SHOCK|actualdice[1].basevalue); sfx(~_shock~|~~|0.1); sfxdamage(target|actualdice[0].basevalue);,Discharge,NORMAL|MAX2,,YELLOW,change_power,change_power,,none,0,NO,NO,,1,,,,,,,,,,,
Circuit Breaker_upgraded,Do [sword]<d6> damage[;]|inflict [shock] for 2nd dice,1,attack(d); inflict(SHOCK|actualdice[1].basevalue); sfx(~_shock~|~~|0.1); sfxdamage(target|d);,Discharge,NORMAL|MAX2,,YELLOW,,,,none,0,NO,NO,,,,,,,,,,,,,
Circuit Breaker_downgraded,Do [sword] for 1st dice[;]|self-inflict [shock] for 2nd dice,1,attack(actualdice[0].basevalue); inflictself(SHOCK|actualdice[1].basevalue); self.applyequipmentcurses(); sfx(~_shock~|~~|0.1); sfxdamage(target|actualdice[0].basevalue);,Discharge,NORMAL|MAX2,,YELLOW,,,,none,0,NO,NO,,,,,,,,,,,,,
Echochamber,Inflict [weaken]2 weaken|(start of turn: [weaken]1 on self),1,inflict(WEAKEN|2); sfx(~_weaken~);,Scream,ODD,,ORANGE,simplify,change_power,,none,0,NO,NO,,,,,,,e.animate(~flashandshake~); var weakenisalt = false; var dummyfighter = new elements.Fighter(~Wisp~); dummyfighter.addstatus(~weaken~|1); trace(dummyfighter.status.length); if(dummyfighter.status.length > 0) { for(stat in dummyfighter.status) { if(stat.type == ~alternate_weaken~) { weakenisalt = true; } } } inflictself(WEAKEN); if(weakenisalt) { sfx(~_weaken~); for(mystat in self.status) { if(mystat.type == ~alternate_weaken~) { stat.remove_at_endturn = false; stat.remove_at_startturn = true; } } } else { self.applyequipmentcurses(); },,,,,,
Echochamber_downgraded,Inflict [weaken]1 weaken|(start of turn: [weaken]1 on self),1,inflict(WEAKEN); sfx(~_weaken~);,Scream,ODD,,ORANGE,,,,none,0,NO,NO,,,,,,,e.animate(~flashandshake~); var weakenisalt = false; var dummyfighter = new elements.Fighter(~Wisp~); dummyfighter.addstatus(~weaken~|1); trace(dummyfighter.status.length); if(dummyfighter.status.length > 0) { for(stat in dummyfighter.status) { if(stat.type == ~alternate_weaken~) { weakenisalt = true; } } } inflictself(WEAKEN); if(weakenisalt) { sfx(~_weaken~); for(mystat in self.status) { if(mystat.type == ~alternate_weaken~) { stat.remove_at_endturn = false; stat.remove_at_startturn = true; } } } else { self.applyequipmentcurses(); },,,,,,
Gag Rule,[silence]Silence enemy,1,inflict(~ncr_silence~); bonus(1000);,Confiscate,COUNTDOWN,15,BRIGHTCYAN,change_power,change_power,,_silence,0,NO,NO,,1,,,,,,,,,,,
Gag Rule_upgraded,[silence]Silence enemy,1,inflict(~ncr_silence~); bonus(1000);,Confiscate,COUNTDOWN,12,BRIGHTCYAN,,,,_silence,0,NO,NO,,,,,,,,,,,,,
Gag Rule_downgraded,[shock]Shock enemy,1,inflict(SHOCK);,Confiscate,COUNTDOWN,15,BRIGHTCYAN,,,,_shock,0,NO,NO,,,,,,,,,,,,,
Gag Rule_weakened,[shock]Shock enemy,1,inflict(SHOCK);,Confiscate,COUNTDOWN,12,BRIGHTCYAN,,,,_shock,0,NO,NO,,,,,,,,,,,,,
Plasma Rifle,Do [sword]5 damage[;] return|the first dice put in this,1,var myname = ~dicehistorytemp~ + self.getvar(~fixedeqlist~).indexOf(e); trace(~----~); trace(e.dicehistory.length); trace(e.dicehistory); trace(self.getvar(myname)); trace(self.getvar(myname).length); trace(~----~); if((e.dicehistory.length < 1) && self.getvar(myname).length >= e.dicehistory.length && self.getvar(myname).length != null) { trace(~thingdoing!~); e.dicehistory = self.getvar(myname).concat(e.dicehistory); } self.setvar(myname|e.dicehistory.copy()); attack(5); sfx(~_damage~|~~|0.1); sfx(~_plasma~); givedice(e.dicehistory[0].basevalue); if(self.getvar(~furying~) < 1) { trace(~resetting!~); e.dicehistory = []; self.resetvar(myname); } self.setvar(~furying~|self.getvar(~furying~) - 1);,Dice Bash,COUNTDOWN,10,RED,change_power,change_power,,none,0,NO,NO,cannotreuse,,,var myfixedeqlist = self.getvar(~fixedeqlist~); if(myfixedeqlist.length > 0) { var myname = ~dicehistorytemp~ + myfixedeqlist.indexOf(e); self.resetvar(myname); } self.resetvar(~fixedeqlist~); self.setvar(~fixedeqlist~|self.equipment.copy());,var myfixedeqlist = self.getvar(~fixedeqlist~); if(myfixedeqlist.length > 0) { var myname = ~dicehistorytemp~ + myfixedeqlist.indexOf(e); self.resetvar(myname); } self.resetvar(~fixedeqlist~); ,,,,,,,self.setvar(~furying~|getstatusself(FURY)); trace(~fury!: ~ + self.getvar(~furying~));,var myname = ~dicehistorytemp~ + self.getvar(~fixedeqlist~).indexOf(e); trace(e.dicehistory.length); trace(e.dicehistory); trace(self.getvar(myname)); trace(self.getvar(myname).length); if((e.dicehistory.length == 1) && self.getvar(myname).length >= e.dicehistory.length && self.getvar(myname).length != null) { trace(~thingdoing!~); e.dicehistory = self.getvar(myname).concat(e.dicehistory); } self.setvar(myname|e.dicehistory.copy());
Plasma Rifle_upgraded,Do [sword]5 damage[;] return|the first dice put in this,1,var myname = ~dicehistorytemp~ + self.getvar(~fixedeqlist~).indexOf(e); trace(~----~); trace(e.dicehistory.length); trace(e.dicehistory); trace(self.getvar(myname)); trace(self.getvar(myname).length); trace(~----~); if((e.dicehistory.length < 1) && self.getvar(myname).length >= e.dicehistory.length && self.getvar(myname).length != null) { trace(~thingdoing!~); e.dicehistory = self.getvar(myname).concat(e.dicehistory); } self.setvar(myname|e.dicehistory.copy()); attack(5); sfx(~_damage~|~~|0.1); sfx(~_plasma~); givedice(e.dicehistory[0].basevalue); if(self.getvar(~furying~) < 1) { trace(~resetting!~); e.dicehistory = []; self.resetvar(myname); } self.setvar(~furying~|self.getvar(~furying~) - 1);,Dice Bash,COUNTDOWN,7,RED,,,,none,0,NO,NO,cannotreuse,,,var myfixedeqlist = self.getvar(~fixedeqlist~); if(myfixedeqlist.length > 0) { var myname = ~dicehistorytemp~ + myfixedeqlist.indexOf(e); self.resetvar(myname); } self.resetvar(~fixedeqlist~); self.setvar(~fixedeqlist~|self.equipment.copy());,var myfixedeqlist = self.getvar(~fixedeqlist~); if(myfixedeqlist.length > 0) { var myname = ~dicehistorytemp~ + myfixedeqlist.indexOf(e); self.resetvar(myname); } self.resetvar(~fixedeqlist~); ,,,,,,,self.setvar(~furying~|getstatusself(FURY)); trace(~fury!: ~ + self.getvar(~furying~));,var myname = ~dicehistorytemp~ + self.getvar(~fixedeqlist~).indexOf(e); trace(e.dicehistory.length); trace(e.dicehistory); trace(self.getvar(myname)); trace(self.getvar(myname).length); if((e.dicehistory.length == 1) && self.getvar(myname).length >= e.dicehistory.length && self.getvar(myname).length != null) { trace(~thingdoing!~); e.dicehistory = self.getvar(myname).concat(e.dicehistory); } self.setvar(myname|e.dicehistory.copy());
Plasma Rifle_downgraded,Do [sword]3 damage[;] return|the first dice put in this,1,var myname = ~dicehistorytemp~ + self.getvar(~fixedeqlist~).indexOf(e); trace(~----~); trace(e.dicehistory.length); trace(e.dicehistory); trace(self.getvar(myname)); trace(self.getvar(myname).length); trace(~----~); if((e.dicehistory.length < 1) && self.getvar(myname).length >= e.dicehistory.length && self.getvar(myname).length != null) { trace(~thingdoing!~); e.dicehistory = self.getvar(myname).concat(e.dicehistory); } self.setvar(myname|e.dicehistory.copy()); attack(3); sfx(~_damage~|~~|0.1); sfx(~_plasma~); givedice(e.dicehistory[0].basevalue); if(self.getvar(~furying~) < 1) { trace(~resetting!~); e.dicehistory = []; self.resetvar(myname); } self.setvar(~furying~|self.getvar(~furying~) - 1);,Dice Bash,COUNTDOWN,10,RED,,,,none,0,NO,NO,cannotreuse,,,var myfixedeqlist = self.getvar(~fixedeqlist~); if(myfixedeqlist.length > 0) { var myname = ~dicehistorytemp~ + myfixedeqlist.indexOf(e); self.resetvar(myname); } self.resetvar(~fixedeqlist~); self.setvar(~fixedeqlist~|self.equipment.copy());,var myfixedeqlist = self.getvar(~fixedeqlist~); if(myfixedeqlist.length > 0) { var myname = ~dicehistorytemp~ + myfixedeqlist.indexOf(e); self.resetvar(myname); } self.resetvar(~fixedeqlist~); ,,,,,,,self.setvar(~furying~|getstatusself(FURY)); trace(~fury!: ~ + self.getvar(~furying~));,var myname = ~dicehistorytemp~ + self.getvar(~fixedeqlist~).indexOf(e); trace(e.dicehistory.length); trace(e.dicehistory); trace(self.getvar(myname)); trace(self.getvar(myname).length); if((e.dicehistory.length == 1) && self.getvar(myname).length >= e.dicehistory.length && self.getvar(myname).length != null) { trace(~thingdoing!~); e.dicehistory = self.getvar(myname).concat(e.dicehistory); } self.setvar(myname|e.dicehistory.copy());
Plasma Rifle_weakened,Do [sword]3 damage[;] return|the first dice put in this,1,var myname = ~dicehistorytemp~ + self.getvar(~fixedeqlist~).indexOf(e); trace(~----~); trace(e.dicehistory.length); trace(e.dicehistory); trace(self.getvar(myname)); trace(self.getvar(myname).length); trace(~----~); if((e.dicehistory.length < 1) && self.getvar(myname).length >= e.dicehistory.length && self.getvar(myname).length != null) { trace(~thingdoing!~); e.dicehistory = self.getvar(myname).concat(e.dicehistory); } self.setvar(myname|e.dicehistory.copy()); attack(3); sfx(~_damage~|~~|0.1); sfx(~_plasma~); givedice(e.dicehistory[0].basevalue); if(self.getvar(~furying~) < 1) { trace(~resetting!~); e.dicehistory = []; self.resetvar(myname); } self.setvar(~furying~|self.getvar(~furying~) - 1);,Dice Bash,COUNTDOWN,7,RED,,,,none,0,NO,NO,cannotreuse,,,var myfixedeqlist = self.getvar(~fixedeqlist~); if(myfixedeqlist.length > 0) { var myname = ~dicehistorytemp~ + myfixedeqlist.indexOf(e); self.resetvar(myname); } self.resetvar(~fixedeqlist~); self.setvar(~fixedeqlist~|self.equipment.copy());,var myfixedeqlist = self.getvar(~fixedeqlist~); if(myfixedeqlist.length > 0) { var myname = ~dicehistorytemp~ + myfixedeqlist.indexOf(e); self.resetvar(myname); } self.resetvar(~fixedeqlist~); ,,,,,,,self.setvar(~furying~|getstatusself(FURY)); trace(~fury!: ~ + self.getvar(~furying~));,var myname = ~dicehistorytemp~ + self.getvar(~fixedeqlist~).indexOf(e); trace(e.dicehistory.length); trace(e.dicehistory); trace(self.getvar(myname)); trace(self.getvar(myname).length); if((e.dicehistory.length == 1) && self.getvar(myname).length >= e.dicehistory.length && self.getvar(myname).length != null) { trace(~thingdoing!~); e.dicehistory = self.getvar(myname).concat(e.dicehistory); } self.setvar(myname|e.dicehistory.copy());
Keyblade@1,Do [sword]3 damage[;]|return the dice,1,attack(3); givedice(d); sfxdamage(target|3);,Magic Dice,NORMAL,,RED,change_power,change_power,,none,0,NO,NO,excludefromrandomlists|playeraltversion,,,,giveequipment(~Lock 1~| true| false| e);,,,,,,,,
Keyblade@1_upgraded,Do [sword]4 damage[;]|return the dice,1,attack(4); givedice(d); sfxdamage(target|4);,Magic Dice,NORMAL,,RED,,,,none,0,NO,NO,excludefromrandomlists|playeraltversion,,,,giveequipment(~Lock 1+~| true| false| e);,,,,,,,,
Keyblade@1_downgraded,Do [sword]1 damage,1,attack(1); sfxdamage(target|1);,Magic Dice,NORMAL,,RED,,,,none,0,NO,NO,excludefromrandomlists|playeraltversion,,,,giveequipment(~Lock 1~| true| false| e);,,,,,,,,
Keyblade@2,Do [sword]3 damage[;]|return the dice,1,attack(3); givedice(d); sfxdamage(target|3);,Magic Dice,NORMAL,,RED,change_power,change_power,,none,0,NO,NO,excludefromrandomlists|playeraltversion,,,,giveequipment(~Lock 2~| true| false| e);,,,,,,,,
Keyblade@2_upgraded,Do [sword]4 damage[;]|return the dice,1,attack(4); givedice(d); sfxdamage(target|4);,Magic Dice,NORMAL,,RED,,,,none,0,NO,NO,excludefromrandomlists|playeraltversion,,,,giveequipment(~Lock 2+~| true| false| e);,,,,,,,,
Keyblade@2_downgraded,Do [sword]1 damage,1,attack(1); sfxdamage(target|1);,Magic Dice,NORMAL,,RED,,,,none,0,NO,NO,excludefromrandomlists|playeraltversion,,,,giveequipment(~Lock 2~| true| false| e);,,,,,,,,
Keyblade@3,Do [sword]3 damage[;]|return the dice,1,attack(3); givedice(d); sfxdamage(target|3);,Magic Dice,NORMAL,,RED,change_power,change_power,,none,0,NO,NO,excludefromrandomlists|playeraltversion,,,,giveequipment(~Lock 3~| true| false| e);,,,,,,,,
Keyblade@3_upgraded,Do [sword]4 damage[;]|return the dice,1,attack(4); givedice(d); sfxdamage(target|4);,Magic Dice,NORMAL,,RED,,,,none,0,NO,NO,excludefromrandomlists|playeraltversion,,,,giveequipment(~Lock 3+~| true| false| e);,,,,,,,,
Keyblade@3_downgraded,Do [sword]1 damage,1,attack(1); sfxdamage(target|1);,Magic Dice,NORMAL,,RED,,,,none,0,NO,NO,excludefromrandomlists|playeraltversion,,,,giveequipment(~Lock 3~| true| false| e);,,,,,,,,
Keyblade@4,Do [sword]3 damage[;]|return the dice,1,attack(3); givedice(d); sfxdamage(target|3);,Magic Dice,NORMAL,,RED,change_power,change_power,,none,0,NO,NO,excludefromrandomlists|playeraltversion,,,,giveequipment(~Lock 4~| true| false| e);,,,,,,,,
Keyblade@4_upgraded,Do [sword]4 damage[;]|return the dice,1,attack(4); givedice(d); sfxdamage(target|4);,Magic Dice,NORMAL,,RED,,,,none,0,NO,NO,excludefromrandomlists|playeraltversion,,,,giveequipment(~Lock 4+~| true| false| e);,,,,,,,,
Keyblade@4_downgraded,Do [sword]1 damage,1,attack(1); sfxdamage(target|1);,Magic Dice,NORMAL,,RED,,,,none,0,NO,NO,excludefromrandomlists|playeraltversion,,,,giveequipment(~Lock 4~| true| false| e);,,,,,,,,
Keyblade@5,Do [sword]3 damage[;]|return the dice,1,attack(3); givedice(d); sfxdamage(target|3);,Magic Dice,NORMAL,,RED,change_power,change_power,,none,0,NO,NO,excludefromrandomlists|playeraltversion,,,,giveequipment(~Lock 5~| true| false| e);,,,,,,,,
Keyblade@5_upgraded,Do [sword]4 damage[;]|return the dice,1,attack(4); givedice(d); sfxdamage(target|4);,Magic Dice,NORMAL,,RED,,,,none,0,NO,NO,excludefromrandomlists|playeraltversion,,,,giveequipment(~Lock 5+~| true| false| e);,,,,,,,,
Keyblade@5_downgraded,Do [sword]1 damage,1,attack(1); sfxdamage(target|1);,Magic Dice,NORMAL,,RED,,,,none,0,NO,NO,excludefromrandomlists|playeraltversion,,,,giveequipment(~Lock 5~| true| false| e);,,,,,,,,
Keyblade@6,Do [sword]3 damage[;]|return the dice,1,attack(3); givedice(d); sfxdamage(target|3);,Magic Dice,NORMAL,,RED,change_power,change_power,,none,0,NO,NO,excludefromrandomlists|playeraltversion,,,,giveequipment(~Lock 6~| true| false| e);,,,,,,,,
Keyblade@6_upgraded,Do [sword]4 damage[;]|return the dice,1,attack(4); givedice(d); sfxdamage(target|4);,Magic Dice,NORMAL,,RED,,,,none,0,NO,NO,excludefromrandomlists|playeraltversion,,,,giveequipment(~Lock 6+~| true| false| e);,,,,,,,,
Keyblade@6_downgraded,Do [sword]1 damage,1,attack(1); sfxdamage(target|1);,Magic Dice,NORMAL,,RED,,,,none,0,NO,NO,excludefromrandomlists|playeraltversion,,,,giveequipment(~Lock 6~| true| false| e);,,,,,,,,
Earth Crystal@crystallize,Do [weaken]<d6> dmg|[weaken]Weakens enemy,2,attack(d| WEAKEN); inflict(WEAKEN); sfxdamage(target|d); sfx(~_weaken~|~~|0.2);,Plasma Gun,ODD,,ORANGE,simplify,complicate,,none,0,NO,NO,excludefromrandomlists|playeraltversion,,,,giveequipment(~Crystallize~ + e.namemodifier| true| false| e);,,,,,,,,
Fire Crystal@crystallize,Deal [fire]<d6> damage|Burn [fire]1 dice,2,attack(d| FIRE); inflict(FIRE); sfxdamage(target|d); sfx(~_fire~|~~|0.2);,Ember,EVEN,,RED,simplify,complicate,,none,0,NO,NO,excludefromrandomlists|playeraltversion,,,,giveequipment(~Crystallize~ + e.namemodifier| true| false| e);,,,,,,,,
Air Crystal@crystallize,Do [shock]<d6> damage[;]|[]+[shock]1 shock,2,attack(d| SHOCK); inflict(SHOCK); sfxdamage(target|d); sfx(~_shock~|~~|0.2);,Zap,EVEN,,YELLOW,simplify,complicate,,none,0,NO,NO,excludefromrandomlists|playeraltversion,,,,giveequipment(~Crystallize~ + e.namemodifier| true| false| e);,,,,,,,,
Ice Crystal@crystallize,Do [ice]<d6> damage[;]|Freeze [ice]1 dice,2,attack(d| ICE); inflict(ICE); sfxdamage(target|d); sfx(~_ice~|~~|0.2);,Refrigerator,ODD,,BRIGHTCYAN,simplify,complicate,,none,0,NO,NO,excludefromrandomlists|playeraltversion,,,,giveequipment(~Crystallize~ + e.namemodifier| true| false| e);,,,,,,,,
Power Crystal@crystallize,Gain a random blessing,2, var randomstatus = SHIELD; if(getstatusself(FURY) == 0) { randomstatus = rand([SHIELD|FURY|REDUCE|REEQUIPNEXT|DODGE]); }else { randomstatus = rand([SHIELD|REDUCE|REEQUIPNEXT|DODGE]); } var a = 1; if (randomstatus == SHIELD) a = 4; if (randomstatus == REDUCE) a = 2; inflictself(randomstatus | a); sfx(~_~ + randomstatus.toLowerCase()|~~|0.2);,Power Up,EVEN,,PURPLE,simplify,complicate,,none,0,YES,NO,excludefromrandomlists|playeraltversion,,,,giveequipment(~Crystallize~ + e.namemodifier| true| false| e);,,,,,,,donothing();,
Smokey Crystal@crystallize,Curse enemy,2,inflict(CURSE); sfx(~_curse~);,Dramatic Pause,ODD,,PURPLE,simplify,complicate,,none,0,NO,NO,excludefromrandomlists|playeraltversion,,,,giveequipment(~Crystallize~ + e.namemodifier| true| false| e);,,,,,,,,
Life Crystal@crystallize,Recover [heal]<d6> health,2,attackself(-d); sfx(~_heal~);,Regenerate,MAX4,,GREEN,increaserange,complicate,,none,0,YES,NO,excludefromrandomlists|playeraltversion,,,,giveequipment(~Crystallize~ + e.namemodifier| true| false| e);,,,,,,,,
Hollow Crystal@crystallize,Do [sword]<d6> dmg,2,attack(d); sfxdamage(target|d);,Plasma Gun,NORMAL,,GRAY,add2,complicate,,none,0,NO,NO,excludefromrandomlists|playeraltversion,,,,giveequipment(~Crystallize~ + e.namemodifier| true| false| e);,,,,,,,,
Energy Crystal@crystallize,Deal [vanish]<d6> damage|Inflict [vanish]1 vanish,2,sfxdamage(target|d); attack(d|VANISH); inflict(~ncr_vanish~);,Delude,EVEN,,PINK,simplify,complicate,,_vanish,0,NO,NO,excludefromrandomlists|playeraltversion,,,,giveequipment(~Crystallize~ + e.namemodifier| true| false| e);,,,,,,,,
Book Bash,Do [sword]2 damage[;] put|this dice in your spellbook|,1,attack(2); sfxdamage(target|2); trace(self.getskillcard().skillcard); if(self.getskillcard().skillcard == ~witch~) self.getskillcard().assigndice(actualdice[0]); else self.textparticle(~Uhh...~); /*originally this was 3 dmg; one use. jacke said it was too much like keyblade and could be 1 dmg reusable; like a passive that does 1 dmg every time you insert a spell at the cost of taking up a spell slot. this is a compromise (also the latter would probably cost 2 to cast)*/,Stardust,NORMAL,,GREEN,change_power,removereusable,,none,2,,,witchonly,1,,,,,,,,,,e.maintainfury = true; e.preventdefault = true;,
Book Bash_upgraded,Do [sword]1 damage[;] put|this dice in your spellbook|,1,attack(1); sfxdamage(target|1); trace(self.getskillcard().skillcard); if(self.getskillcard().skillcard == ~witch~) self.getskillcard().assigndice(actualdice[0]); else self.textparticle(~Uhh...~);,Stardust,NORMAL,,GREEN,,,,none,4,,,witchonly,,,,,,,,,,,e.maintainfury = true; e.preventdefault = true;,
Rotary Dial,Move all spells down by|<d6> places[;] return dice,1,if(self.getskillcard().skillcard == ~witch~) { var myspells = []; for(i in 1...7) myspells.push(Spellbook.spellname(i)); for(i in 0...d) myspells.unshift(myspells.pop()); for(i in 0...myspells.length) { var newspell = myspells[i]; if(newspell != ~~) Spellbook.changespellflash(i + 1| newspell); else Spellbook.erase(i + 1); } if(d == 6) self.textparticle(~No effect!~); } else { self.textparticle(~Uhh...~); } givedice(d);,Stardust,MAX5,,ORANGE,change_power,change_power,,none,,YES,,witchonly,1,,,,,,,,,,,
Rotary Dial_upgraded,Move all spells down by|<d6> places[;] return dice|,1,if(self.getskillcard().skillcard == ~witch~) { var myspells = []; for(i in 1...7) myspells.push(Spellbook.spellname(i)); for(i in 0...d) myspells.unshift(myspells.pop()); for(i in 0...myspells.length) { var newspell = myspells[i]; if(newspell != ~~) Spellbook.changespellflash(i + 1| newspell); else Spellbook.erase(i + 1); } if(d == 6) self.textparticle(~No effect!~); } else { self.textparticle(~Uhh...~); } givedice(d);,Stardust,MAX5,,ORANGE,,,,none,2,YES,,witchonly,,,,,,,,,,,,
Rotary Dial_downgraded,Move all spells down by|<d6> places,1,if(self.getskillcard().skillcard == ~witch~) { var myspells = []; for(i in 1...7) myspells.push(Spellbook.spellname(i)); for(i in 0...d) myspells.unshift(myspells.pop()); for(i in 0...myspells.length) { var newspell = myspells[i]; if(newspell != ~~) Spellbook.changespellflash(i + 1| newspell); else Spellbook.erase(i + 1); } if(d == 6) self.textparticle(~No effect!~); } else { self.textparticle(~Uhh...~); },Stardust,MAX5,,ORANGE,,,,none,,YES,,witchonly,,,,,,,,,,,,
Bookmark,Do [sword]<d6> damage. On 6[;]|cast a random spell,1,attack(d); sfxdamage(target|d); if(d == 6) { var acceptablevalues = []; for(i in 1...7) if(!Spellbook.isempty(i)) acceptablevalues.push(i); if(acceptablevalues.length > 0 && self.getskillcard().skillcard == ~witch~) { var castdice = new elements.Dice(); castdice.basevalue = rand(acceptablevalues); self.getskillcard().assigndice(castdice); sfx(~_thinghappens~|~~|0.2); } else self.textparticle(~Uhh...~); },Stardust,NORMAL,,GREEN,change_power,change_power,,none,,,,witchonly,1,,,,,,,,,,,
Bookmark_upgraded,Do [sword]<d6> damage. On 4-6[;]|cast a random spell,1,attack(d); sfxdamage(target|d); if(d > 3) { var acceptablevalues = []; for(i in 1...7) if(!Spellbook.isempty(i)) acceptablevalues.push(i); if(acceptablevalues.length > 0 && self.getskillcard().skillcard == ~witch~) { var castdice = new elements.Dice(); castdice.basevalue = rand(acceptablevalues); self.getskillcard().assigndice(castdice); sfx(~_thinghappens~|~~|0.2); } else self.textparticle(~Uhh...~); },Stardust,NORMAL,,GREEN,,,,none,,,,witchonly,,,,,,,,,,,,
Bookmark_downgraded,Do [sword]<d6> damage,1,attack(d); sfxdamage(target|d);,Stardust,NORMAL,,GREEN,,,,none,,,,witchonly,,,,,,,,,,,,
Aether Portal,[shock]Shock yourself[;] clone dice|[gray](Reusable)|[80%][gray]''So we back in the mine''[],1,if(simulation) bonus(-50); givedice([d|d]); inflictself(SHOCK); self.applyequipmentcurses(); /*obvious reference to more fluff's 'nether portal'*/,Clone Device,MAX4,,YELLOW,simplify,change_power,,none,-1,YES,NO,hidereuseable,1,,,,,,,,,,,
Aether Portal_downgraded,[shock]Shock yourself[;] clone dice|[80%][gray]''So we back in the mine''[],1,if(simulation) bonus(-50); givedice([d|d]); inflictself(SHOCK); self.applyequipmentcurses(); /*i don't even remember what version of minecraft aether last worked with*/,Clone Device,MAX4,,YELLOW,,,,none,,YES,NO,hidereuseable,,,,,,,,,,,,
Ender Portal,[weaken]Weaken self[;] clone dice|[gray](Reusable)|[80%][gray]''So we back in the mine''[],1,if(simulation) bonus(-50); givedice([d|d]); inflictself(WEAKEN); self.applyequipmentcurses(); /*ender portal would be more fitting for 'get cursed'; and nether portal would be more fitting for 'get weakened'; but like i'm not in control of morefluff here*/,Clone Device,MAX4,,PURPLE,simplify,change_power,weaken,none,-1,YES,NO,hidereuseable,1,,,,,,,,,,,
Ender Portal_downgraded,[weaken]Weaken self[;] clone dice|[80%][gray]''So we back in the mine''[],1,if(simulation) bonus(-50); givedice([d|d]); inflictself(WEAKEN); self.applyequipmentcurses();,Clone Device,MAX4,,PURPLE,,,,none,,YES,NO,hidereuseable,,,,,,,,,,,,
Ender Portal?,Take [weaken]<d6> dmg[;] clone dice|[gray](Reusable)|[80%][gray]''So we back in the mine''[],1,if(simulation) bonus(-50); givedice([d|d]); attackself(d|WEAKEN); sfxdamage(self|d); sfx(~apply_weaken_to_equipment~|~~|0.2);,Clone Device,MAX4,,PURPLE,simplify,change_power,,none,4,YES,NO,hidereuseable|alternateversion,1,,,,,,,,,,,
Ender Portal?_downgraded,Take [weaken]<d6> dmg[;] clone dice|[80%][gray]''So we back in the mine''[],1,if(simulation) bonus(-50); givedice([d|d]); attackself(d|WEAKEN); sfxdamage(self|d); sfx(~apply_weaken_to_equipment~|~~|0.2);,Clone Device,MAX4,,PURPLE,,,,none,,YES,NO,hidereuseable|alternateversion,,,,,,,,,,,,
Duplicauld,Do [sword]1[;] roll 2 of a new dice,1,attack(1); sfxdamage(target|1); var newvalue = rand([1|2|3|4|5|6]); givedice([newvalue|newvalue]);,Replicate,MAX2,,PURPLE,change_power,change_power,,none,,,,,1,,,,,,,,,,,
Duplicauld_upgraded,Do [sword]1[;] roll 2 of a new dice|,1,attack(1); sfxdamage(target|1); var newvalue = rand([1|2|3|4|5|6]); givedice([newvalue|newvalue]);,Replicate,MAX2,,PURPLE,,,,none,2,,,,,,,,,,,,,,,
Duplicauld_downgraded,Do [sword]1[;] roll a new dice,1,attack(1); sfxdamage(target|1); givedice();,Replicate,MAX2,,PURPLE,,,,none,,,,,,,,,,,,,,,,
Manual Hook,Gain [recycle]Re-Equip[;]|spare 2 provided,1,inflictself(REEQUIPNEXT);,Sustainability,REQUIRE2|REQUIRE2|SPARE2,,GREEN,change_power,change_power,,_recycle,0,YES,NO,,,,,e.resetslots();,,e.slots = [~REQUIRE2~|~REQUIRE2~|~FREE2~];,e.resetslots();,,,,,
Manual Hook_upgraded,Gain [recycle]Re-Equip[;]|spare 2 provided,1,inflictself(REEQUIPNEXT);,Sustainability,EVEN|EVEN|SPARE2,,GREEN,,,,_recycle,0,YES,NO,,,,,e.resetslots();,,e.slots = [~REQUIRE2~|~REQUIRE2~|~FREE2~];,e.resetslots();,,,,,
Manual Hook_downgraded,No effect,1,self.textparticle(~No effect!~); /*you can't reach this right now for whatever reason - equip with spares just isn't targeted by weaken*/,Sustainability,REQUIRE2|REQUIRE2|SPARE2,,GREEN,,,,_recycle,0,YES,NO,,,,,e.resetslots();,,e.slots = [~REQUIRE2~|~REQUIRE2~|~FREE2~];,e.resetslots();,,,,,
Reverse Emulation,Mimic the gadget of the|last card the enemy used,1,self.textparticle(~No effect!~); /*reference to this elaborate joke video: https://www.youtube.com/watch?v=ar9WRwCiSr0 */,Boltzmann Brain,EVEN,,PURPLE,simplify,change_power,,none,0,YES,NO,hidereuseable,,,e.fulldescription = ~[quote]Broken Gadget[quote]~ + ~#~.substr(0|1) + ~No effect~; self.setvar(~phillip~|false);,e.fulldescription = ~[quote]Broken Gadget[quote]~ + ~#~.substr(0|1) + ~No effect~;,e.scriptrunner = null; var gadgettomimic = ~~; if(target.lastequipmentused != null) { gadgettomimic = target.lastequipmentused.gadget; } else { gadgettomimic = ~Broken Gadget~; }  e.onceperbattle = false; if(gadgettomimic == ~Gadget Roll~ # gadgettomimic == ~Mirror Smash~) { e.usesleft = 3; } trace(gadgettomimic); var descriptioncheck = new elements.Skill(gadgettomimic); if(descriptioncheck.description.indexOf(~(once)~) != -1) { e.onceperbattle = true; } e.fulldescription = ~[quote]~ + gadgettomimic + ~[quote]~ + ~#~.substr(0|1) + descriptioncheck.description;  e.castdirection = -1; var cfterms = [~attack(~|~sfxdamage(target~|~drain(~|~inflict(~|~\~|target|self|~]; for(term in cfterms) { if(descriptioncheck.script.indexOf(term) != -1) { e.castdirection = 1; break; } }  e.maintainfury = false; e.preventdefault = false; if(descriptioncheck.script.split(~inflictself(FURY)~).length > 1) { e.maintainfury = true; e.preventdefault = true; }  var specialcases = [~Phillips Head~|~Underwhelm~]; if(specialcases.indexOf(gadgettomimic) != -1) { if(gadgettomimic == ~Phillips Head~) { e.script = ~if(self.getvar(\~usedalready\~) == 0) { attack(3); sfxdamage(target|3); self.setvar(\~usedalready\~|1); } else { attack(6); sfxdamage(target|6); }~; } if(gadgettomimic == ~Underwhelm~) { e.script = ~if(!self.getvar(\~torrentunderwhelm\~) > 0) {self.setvar(\~torrentunderwhelm\~|5);} attack(self.getvar(\~torrentunderwhelm\~)); sfxdamage(target|self.getvar(\~torrentunderwhelm\~)); if(self.getvar(\~torrentunderwhelm\~) > 1) {self.setvar(\~torrentunderwhelm\~|self.getvar(\~torrentunderwhelm\~)-1);}~; } } else {  var mimicthis = descriptioncheck.script; trace(mimicthis); mimicthis = mimicthis.split(~Gadget.changegadget(~).join(~/~ + ~/Gadget.changegadget(~); trace(mimicthis); e.script = ~trace(\~aaaa\~); trace(e.script); if(!simulation) { var soundgadget = new elements.Skill(\~~ + gadgettomimic + ~\~); soundgadget.script = \~\~; soundgadget.execute(self|target); } ~ + mimicthis + ~ trace(\~~ + mimicthis + ~\~); trace(e.script);~; trace(e.script);  },if(target.lastequipmentused != null && target.lastequipmentused.gadget == ~Pure Evil~) { inflictself(CURSE); sfx(~_curse~); e.animate(~flashandshake~); } trace(e.script);,,var alreadyupdating = false; if(self.getskillcard() != null && self.getskillcard().name == ~Inventor Gadgets~) alreadyupdating = true; if(!onlimit && !alreadyupdating) { self.setvar(~invgadgets_eqsused~|self.getvar(~invgadgets_eqsused~) + 1); if(self.getvar(~invgadgets_eqsused~) % 2 == 0) { self.setvar(~invgadgets_eqsused_display~|self.getvar(~invgadgets_eqsused_display~) + 1); } },,,,
Reverse Emulation_downgraded,[quote]Broken Gadget[quote]|No effect,1,self.textparticle(~No effect!~);,Boltzmann Brain,EVEN,,PURPLE,,,,none,0,YES,NO,hidereuseable,,,,,,,,,,,,
Grovel,Do [weaken]<d6> damage[;]|on <d6>[;] inflict [weaken]1 weaken,2,attack(d|WEAKEN); e.setvar(~test~|true); if(!e.getvar(~sicknum~) > 0) { e.setvar(~sicknum~|d); var j = e.fulldescription.split(~on <d6>~); e.fulldescription = j.join(~on ~ + e.getvar(~sicknum~)); for(eq in self.equipment) { if(e.getvar(~test~) == true && eq.getvar(~test~) == true && eq.ready) { if(eq.fulldescription.split(~on ~ + e.getvar(~sicknum~)).length == 1) { eq.fulldescription = j.join(~on ~ + e.getvar(~sicknum~)); eq.setvar(~sicknum~|e.getvar(~sicknum~)); eq.animate(~flash~); } eq.setvar(~test~|false); break; } } } sfxdamage(target|d); if((e.getvar(~sicknum~) != e.fulldescription.substr(28|1) - 0) && (e.fulldescription.substr(28|1) > 0)) { e.setvar(~sicknum~|e.fulldescription.substr(28|1) - 0); } trace(e.getvar(~sicknum~)); if(d == e.getvar(~sicknum~) # d == e.fulldescription.substr(28|1) - 0) { inflict(WEAKEN); sfx(~_weaken~|~~|0.2); } e.setvar(~test~|false);,Scream,NORMAL,,ORANGE,reducesize,change_power,,none,0,NO,NO,,,,e.fulldescription = ~Do [weaken]<d6> damage[~ + ~;]~ + ~#~.substr(0|1) + ~on <d6>[~ + ~;] inflict [weaken]1 weaken~; e.setvar(~sicknum~|0);,e.fulldescription = ~Do [weaken]<d6> damage[~ + ~;]~ + ~#~.substr(0|1) + ~on <d6>[~ + ~;] inflict [weaken]1 weaken~; e.setvar(~sicknum~|0);,if(e.fulldescription.split(~on <d6>~).length > 1 && e.getvar(~sicknum~) > 0) { e.fulldescription = e.fulldescription.split(~on <d6>~).join(~on ~ + e.getvar(~sicknum~)); },e.setvar(~oldrow~|e.row); e.setvar(~oldcolumn~|e.column);,,e.setvar(~oldrow~|e.row); e.setvar(~oldcolumn~|e.column);,for(eq in self.equipment) { if(eq.name == e.name && eq.namemodifier == e.namemodifier && (eq.y + 10) >= e.y && (eq.y - 10) <= e.y && (eq.x + 10) >= e.x && (eq.x - 10) <= e.x) { eq.setvar(~test~|true); } },,,e.setvar(~oldrow~|e.row); e.setvar(~oldcolumn~|e.column);
Grovel_downgraded,Do [weaken]<d6> damage,2,attack(d|WEAKEN); sfxdamage(target|d);,Scream,NORMAL,,ORANGE,,,,none,0,NO,NO,,,,,e.fulldescription = ~Do [weaken]<d6> damage[~ + ~;]~ + ~#~.substr(0|1) + ~on <d6>[~ + ~;] inflict [weaken]1 weaken~; e.setvar(~sicknum~|0);,,,,,,,,
Grovel_weakened,Do [weaken]<d6> damage,1,attack(d|WEAKEN); sfxdamage(target|d);,Scream,NORMAL,,ORANGE,,,,none,0,NO,NO,,,,,e.fulldescription = ~Do [weaken]<d6> damage[~ + ~;]~ + ~#~.substr(0|1) + ~on <d6>[~ + ~;] inflict [weaken]1 weaken~; e.setvar(~sicknum~|0);,,,,,,,,
Grovel_deckupgrade,Do [weaken]<d6> damage[;]|on <d6>[;] inflict [weaken]2 weaken,2,attack(d|WEAKEN); e.setvar(~test~|true); if(!e.getvar(~sicknum~) > 0) { e.setvar(~sicknum~|d); var j = e.fulldescription.split(~on <d6>~); e.fulldescription = j.join(~on ~ + e.getvar(~sicknum~)); for(eq in self.equipment) { if(e.getvar(~test~) == true && eq.getvar(~test~) == true && eq.ready) { if(eq.fulldescription.split(~on ~ + e.getvar(~sicknum~)).length == 1) { eq.fulldescription = j.join(~on ~ + e.getvar(~sicknum~)); eq.setvar(~sicknum~|e.getvar(~sicknum~)); eq.animate(~flash~); } eq.setvar(~test~|false); break; } } } sfxdamage(target|d); if((e.getvar(~sicknum~) != e.fulldescription.substr(28|1) - 0) && (e.fulldescription.substr(28|1) > 0)) { e.setvar(~sicknum~|e.fulldescription.substr(28|1) - 0); } trace(e.getvar(~sicknum~)); if(d == e.getvar(~sicknum~) # d == e.fulldescription.substr(28|1) - 0) { inflict(WEAKEN|2); sfx(~_weaken~|~~|0.2); } e.setvar(~test~|false);,Scream,NORMAL,,ORANGE,,,,none,0,NO,NO,,,,e.fulldescription = ~Do [weaken]<d6> damage[~ + ~;]~ + ~#~.substr(0|1) + ~on <d6>[~ + ~;] inflict [weaken]1 weaken~; e.setvar(~sicknum~|0);,e.fulldescription = ~Do [shock]<d6> damage[~ + ~;]~ + ~#~.substr(0|1) + ~on <d6>[~ + ~;] inflict [shock]1 shock~; e.setvar(~sicknum~|0);,if(e.fulldescription.split(~on <d6>~).length > 1 && e.getvar(~sicknum~) > 0) { e.fulldescription = e.fulldescription.split(~on <d6>~).join(~on ~ + e.getvar(~sicknum~)); },e.setvar(~oldrow~|e.row); e.setvar(~oldcolumn~|e.column);,,e.setvar(~oldrow~|e.row); e.setvar(~oldcolumn~|e.column);,for(eq in self.equipment) { if(eq.name == e.name && eq.namemodifier == e.namemodifier && (eq.y + 10) >= e.y && (eq.y - 10) <= e.y && (eq.x + 10) >= e.x && (eq.x - 10) <= e.x) { eq.setvar(~test~|true); } },,,e.setvar(~oldrow~|e.row); e.setvar(~oldcolumn~|e.column);
Ghost Story,Inflict [shock] shock[;]|[vanish] vanish[;] and [ice] freeze,1,inflict(SHOCK); inflict(ICE); inflict(~ncr_vanish~); ,Oh No!,COUNTDOWN,7,PINK,change_power,change_power,,_multistatus,0,NO,NO,,1,,,,,,,,,,,
Ghost Story_upgraded,Inflict [shock]2 shock[;]|[vanish]2 vanish[;] [ice]2 freeze,1,inflict(SHOCK| 2); inflict(ICE| 2); inflict(~ncr_vanish~|2);,Oh No!,COUNTDOWN,7,PINK,,,,_multistatus,0,NO,NO,,,,,,,,,,,,,
Ghost Story_downgraded,Inflict [shock] shock[;]|[vanish] vanish[;] or [ice] freeze,1,var randstatus = rand([SHOCK|~vanish~|ICE]); if(randstatus != ~vanish~) { inflict(randstatus|1); } else { inflict(~ncr_vanish~); } sfx(~_~ + randstatus.toLowerCase()|~~|0.2);,Oh No!,COUNTDOWN,7,PINK,,,,none,0,NO,NO,,,,,,,,,,,,,
Ghost Town,Inflict [weaken] weaken[;]|[vanish] vanish[;] and [ice] freeze,1,inflict(WEAKEN); inflict(ICE); inflict(~ncr_vanish~); ,Oh No!,COUNTDOWN,7,PURPLE,change_power,change_power,,_multistatus,0,NO,NO,,1,,,,,,,,,,,
Ghost Town_upgraded,Inflict [weaken]2 weaken[;]|[vanish]2 vanish[;] [ice]2 freeze,1,inflict(WEAKEN| 2); inflict(ICE| 2); inflict(~ncr_vanish~|2);,Oh No!,COUNTDOWN,7,PURPLE,,,,_multistatus,0,NO,NO,,,,,,,,,,,,,
Ghost Town_downgraded,Inflict [weaken] weaken[;]|[vanish] vanish[;] or [ice] freeze,1,var randstatus = rand([WEAKEN|~vanish~|ICE]); if(randstatus != ~vanish~) { inflict(randstatus|1); } else { inflict(~ncr_vanish~); } sfx(~_~ + randstatus.toLowerCase()|~~|0.2);,Oh No!,COUNTDOWN,7,PURPLE,,,,none,0,NO,NO,,,,,,,,,,,,,
Haunted Oven,Inflict [shock] shock[;]|[vanish] vanish[;] and [fire] burn,1,inflict(SHOCK); inflict(FIRE); inflict(~ncr_vanish~); ,Oh No!,COUNTDOWN,7,PINK,change_power,change_power,,_multistatus,0,NO,NO,,1,,,,,,,,,,,
Haunted Oven_upgraded,Inflict [shock]2 shock[;]|[vanish]2 vanish[;] [fire]2 burn,1,inflict(SHOCK| 2); inflict(FIRE| 2); inflict(~ncr_vanish~|2);,Oh No!,COUNTDOWN,7,PINK,,,,_multistatus,0,NO,NO,,,,,,,,,,,,,
Haunted Oven_downgraded,Inflict [shock] shock[;]|[vanish] vanish[;] or [fire] burn,1,var randstatus = rand([SHOCK|~vanish~|FIRE]); if(randstatus != ~vanish~) { inflict(randstatus|1); } else { inflict(~ncr_vanish~); } sfx(~_~ + randstatus.toLowerCase()|~~|0.2);,Oh No!,COUNTDOWN,7,PINK,,,,none,0,NO,NO,,,,,,,,,,,,,
Haunted Bonfire,Inflict [weaken] weaken[;]|[vanish] vanish[;] and [fire] burn,1,inflict(WEAKEN); inflict(FIRE); inflict(~ncr_vanish~); ,Oh No!,COUNTDOWN,7,PURPLE,change_power,change_power,,_multistatus,0,NO,NO,,1,,,,,,,,,,,
Haunted Bonfire_upgraded,Inflict [weaken]2 weaken[;]|[vanish]2 vanish[;] [fire]2 burn,1,inflict(WEAKEN| 2); inflict(FIRE| 2); inflict(~ncr_vanish~|2);,Oh No!,COUNTDOWN,7,PURPLE,,,,_multistatus,0,NO,NO,,,,,,,,,,,,,
Haunted Bonfire_downgraded,Inflict [weaken] weaken[;]|[vanish] vanish[;] or [fire] burn,1,var randstatus = rand([WEAKEN|~vanish~|FIRE]); if(randstatus != ~vanish~) { inflict(randstatus|1); } else { inflict(~ncr_vanish~); } sfx(~_~ + randstatus.toLowerCase()|~~|0.2);,Oh No!,COUNTDOWN,7,PURPLE,,,,none,0,NO,NO,,,,,,,,,,,,,
Sacred Grounds,Do [sword]<d6> damage[;] inflict|[vanish]Vanish and [weaken]Weaken,1,attack(d); inflict(~ncr_vanish~); inflict(WEAKEN| 1); sfx(~_vanish~|~~|0.2); sfx(~_weaken~|~~|0.2);,Hadoken,MAX4,,PINK,change_power,change_power,,_damage,0,NO,NO,,1,,,,,,,,,,,
Sacred Grounds_upgraded,Do [sword]<d6> damage[;] inflict|[vanish]Vanish and [weaken]Weaken,1,attack(d); inflict(~ncr_vanish~); inflict(WEAKEN| 1); sfx(~_vanish~|~~|0.2); sfx(~_weaken~|~~|0.2);,Hadoken,NORMAL,,PINK,,,,_damage,0,NO,NO,,,,,,,,,,,,,
Sacred Grounds_downgraded,Do [sword]<d6> damage,1,attack(d);,Hadoken,REQUIRE5,,PINK,,,,_damage,0,NO,NO,,,,,,,,,,,,,
Bass Boost,Do [sword] for 1st dice[;]|inflict [weaken] for 2nd dice,1,attack(actualdice[0].basevalue); inflict(WEAKEN|actualdice[1].basevalue); sfx(~_weaken~|~~|0.2); sfxdamage(target|actualdice[0].basevalue);,Guitar Solo,NORMAL|MAX2,,ORANGE,change_power,change_power,,none,0,NO,NO,,1,,,,,,,,,,,
Bass Boost_upgraded,Do [sword]<d6> damage[;]|inflict [weaken] for 2nd dice,1,attack(d); inflict(WEAKEN|actualdice[1].basevalue); sfx(~_weaken~|~~|0.2); sfxdamage(target|d);,Guitar Solo,NORMAL|MAX2,,ORANGE,,,,none,0,NO,NO,,,,,,,,,,,,,
Bass Boost_downgraded,Do [sword] for 1st dice[;]|self-inflict [weaken] for 2nd dice,1,attack(actualdice[0].basevalue); inflictself(WEAKEN|actualdice[1].basevalue); var weakenisalt = false; var dummyfighter = new elements.Fighter(~Wisp~); dummyfighter.addstatus(~weaken~|1); trace(dummyfighter.status.length); if(dummyfighter.status.length > 0) { for(stat in dummyfighter.status) { if(stat.type == ~alternate_weaken~) { weakenisalt = true; } } } inflictself(WEAKEN); if(weakenisalt) { for(mystat in self.status) { if(mystat.type == ~alternate_weaken~) { stat.remove_at_endturn = false; stat.remove_at_startturn = true; } } } else { self.applyequipmentcurses(); } sfx(~_weaken~|~~|0.2); sfxdamage(target|actualdice[0].basevalue);,Guitar Solo,NORMAL|MAX2,,ORANGE,,,,none,0,NO,NO,,,,,,,,,,,,,
Shock Humour,Inflict [shock]2 shock|(start of turn: [shock]1 on self),1,inflict(SHOCK|2); sfx(~_shock~);,Electrify,EVEN,,YELLOW,simplify,change_power,,none,0,NO,NO,,,,,,,inflictself(SHOCK); self.applyequipmentcurses();,,,,,,
Shock Humour_downgraded,Inflict [shock]1 shock|(start of turn: [shock]1 on self),1,inflict(SHOCK); sfx(~_shock~);,Electrify,EVEN,,YELLOW,,,,none,0,NO,NO,,,,,,,inflictself(SHOCK); self.applyequipmentcurses();,,,,,,
Dry Lightning,Inflict [fire]1 burn per|[shock]1 shock on enemy,1,inflict(FIRE|getstatus(SHOCK));,Hellfire,COUNTDOWN,18,RED,change_power,change_function,,_fire,0,NO,NO,,,,,,,,,,,,,
Dry Lightning_upgraded,Inflict [fire]1 burn per|[shock]1 shock on enemy,1,inflict(FIRE|getstatus(SHOCK));,Hellfire,COUNTDOWN,12,RED,,,,_fire,0,NO,NO,,,,,,,,,,,,,
Dry Lightning_downgraded,Inflict [fire]1 burn per|[shock]2 shock on enemy,1,var f = getstatus(SHOCK) * 0.5; if (f % 1 != 0) { f = f - 0.5; } inflict(FIRE|f);,Hellfire,COUNTDOWN,18,RED,,,,_fire,0,NO,NO,,,,,,,,,,,,,
Dry Lightning_weakened,Inflict [fire]1 burn per|[shock]2 shock on enemy,1,var f = getstatus(SHOCK) * 0.5; if (f % 1 != 0) { f = f - 0.5; } inflict(FIRE|f);,Hellfire,COUNTDOWN,12,RED,,,,_fire,0,NO,NO,,,,,,,,,,,,,
Thundersnow,Inflict [ice]1 freeze per|[shock]1 shock on enemy,1,inflict(ICE|getstatus(SHOCK));  /*apparently this is a real term that means 'thunder but when it's snowing instead of when it's raining'*/,Arctic Storm,COUNTDOWN,18,BRIGHTCYAN,change_power,change_function,,_ice,0,NO,NO,,,,,,,,,,,,,
Thundersnow_upgraded,Inflict [ice]1 freeze per|[shock]1 shock on enemy,1,inflict(ICE|getstatus(SHOCK));,Arctic Storm,COUNTDOWN,12,BRIGHTCYAN,,,,_ice,0,NO,NO,,,,,,,,,,,,,
Thundersnow_downgraded,Inflict [ice]1 freeze per|[shock]2 shock on enemy,1,var f = getstatus(SHOCK) * 0.5; if (f % 1 != 0) { f = f - 0.5; } inflict(ICE|f);,Arctic Storm,COUNTDOWN,18,BRIGHTCYAN,,,,_ice,0,NO,NO,,,,,,,,,,,,,
Thundersnow_weakened,Inflict [ice]1 freeze per|[shock]2 shock on enemy,1,var f = getstatus(SHOCK) * 0.5; if (f % 1 != 0) { f = f - 0.5; } inflict(ICE|f);,Arctic Storm,COUNTDOWN,12,BRIGHTCYAN,,,,_ice,0,NO,NO,,,,,,,,,,,,,
Coil,Inflict [shock]<d6> shock,2,inflict(SHOCK|d); /* would do a joke about that ai dril twitter account for shock version of dril; but dril doesn't actually appear anywhere in ncrmod since it's special and excluded from all generators! what a surprise */,Jackhammer,MAX3,,YELLOW,change_power,change_function,,_shock,0,NO,NO,,,,,,,,,,,,,
Coil_downgraded,Do [shock]<d6> damage,2,attack(d|SHOCK);,Jackhammer,MAX3,,YELLOW,,,,_shock,0,NO,NO,,,,,,,,,,,,,
Coil_upgraded,Do [shock]<d6> damage[;] then|inflict [shock]<d6> shock,2,attack(d|SHOCK); inflict(SHOCK|d);,Jackhammer,MAX3,,YELLOW,,,,_shock,0,NO,NO,,,,,,,,,,,,,
Clockwork,Inflict [vanish]1 vanish per|[shock]1 shock on enemy,1,inflict(~ncr_vanish~|getstatus(SHOCK));,Strobe Light,COUNTDOWN,18,PINK,change_power,change_function,,_vanish,0,NO,NO,,,,,,,,,,,,,
Clockwork_upgraded,Inflict [vanish]1 vanish per|[shock]1 shock on enemy,1,inflict(~ncr_vanish~|getstatus(SHOCK));,Strobe Light,COUNTDOWN,12,PINK,,,,_vanish,0,NO,NO,,,,,,,,,,,,,
Clockwork_downgraded,Inflict [vanish]1 vanish per|[shock]2 shock on enemy,1,var f = getstatus(SHOCK) * 0.5; if (f % 1 != 0) { f = f - 0.5; } inflict(~ncr_vanish~|f); /*the f is still for france?*/,Strobe Light,COUNTDOWN,18,PINK,,,,_vanish,0,NO,NO,,,,,,,,,,,,,
Clockwork_weakened,Inflict [vanish]1 vanish per|[shock]2 shock on enemy,1,var f = getstatus(SHOCK) * 0.5; if (f % 1 != 0) { f = f - 0.5; } inflict(~ncr_vanish~|f);,Strobe Light,COUNTDOWN,12,PINK,,,,_vanish,0,NO,NO,,,,,,,,,,,,,
Jacob's Ladder,Do [shock]<d6> damage[;] if below 3[;]|inflict [shock]<d6> shock instead,2,if(d > 2) { attack(d); sfxdamage(target|d); } else { inflict(SHOCK|d); sfx(~_shock~); },Electrify,NORMAL,,YELLOW,change_power,change_power,,none,0,NO,NO,,,,,,,,,,,,,
Jacob's Ladder_upgraded,Do [shock]<d6> damage[;] if below 3[;]|also inflict [shock]<d6> shock,2,attack(d); sfxdamage(target|d); if(d <= 2) { inflict(SHOCK|d); sfx(~_shock~); },Electrify,NORMAL,,YELLOW,,,,none,0,NO,NO,,,,,,,,,,,,,
Jacob's Ladder_downgraded,Do [shock]<d6> damage,2,attack(d); sfxdamage(target|d);,Electrify,MIN3,,YELLOW,,,,none,0,NO,NO,,,,,,,,,,,,,
Shock Therapy,Next turn: get [shock]2 shock[;]|but recover [heal]<d6> health,1,jinx(~Shock Therapy~|~ get [shock]2 shock[;] heal [heal]%VAR%~|~ get [shock]2 shock[;] heal [heal]%VAR%~|~inflict(\~shock\~|2); sfx(\~_heal\~); attack(-%VAR%); if(self.dicepool.length > 0) { self.applyequipmentcurses(); }~|self|self|1|d);,Trinity,NORMAL|FREE1,,YELLOW,change_power,change_function,,_thinghappens,0,YES,NO,,1,,,,,,,,,,,
Shock Therapy_upgraded,Next turn: get [shock]1 shock[;]|but recover [heal]<d6> health,1,jinx(~Shock Therapy~|~ get [shock]1 shock[;] heal [heal]%VAR%~|~ get [shock]1 shock[;] heal [heal]%VAR%~|~inflict(\~shock\~|1); sfx(\~_heal\~); attack(-%VAR%); if(self.dicepool.length > 0) { self.applyequipmentcurses(); }~|self|self|1|d);,Trinity,NORMAL|FREE1,,YELLOW,,,,_thinghappens,0,YES,NO,,,,,,,,,,,,,
Shock Therapy_downgraded,Next turn: get [shock]2 shock[;]|but recover [heal]<d6> health,1,jinx(~Shock Therapy~|~ get [shock]2 shock[;] heal [heal]%VAR%~|~ get [shock]2 shock[;] heal [heal]%VAR%~|~inflict(\~shock\~|2); sfx(\~_heal\~); attack(-%VAR%); if(self.dicepool.length > 0) { self.applyequipmentcurses(); }~|self|self|1|d);,Trinity,MAX4|FREE1,,YELLOW,,,,_thinghappens,0,YES,NO,,,,,,,,,,,,,
999,On start turn[;]|everyone heals [heal]6,1,/*maybe redundant to charity? idk. there was a discussion in the dicecord about what if there was a mod that was all just themed equipment based on the names of random dicecord members. there's this nice guy who goes by scp-999 for some reason so this is like a shoutout to them*/,Embrace,,,ORANGE,change_power,noeffect,,none,0,NO,NO,,,,,,,sfx(~_heal~); attack(-6); attackself(-6); e.animate(~flashandshake~);,,,,,,
999_upgraded,Heal everyone by [heal]6[;]|return the dice,1,attack(-6); attackself(-6); givedice(d); /*might not be thematic for 999's upgrade to be something that makes it heal *less* often? didn't want to make it apply more to you than the enemy; though; because that would be even less thematic*/,Embrace,NORMAL,,ORANGE,,,,_heal,0,NO,NO,,,,,,,,,,,,,
Security Hole,Error an enemy equipment|(only shows on error),1,inflict(~ncr_error~);,Boltzmann Brain,COUNTDOWN,12,GRAY,change_power,change_power,,roboterror,0,NO,NO,errorimmune|robotonly,,,,,e.availablethisturn = false; e.unavailabletext = e.displayname; e.unavailabledetails = [~This card is only usable when~|~you exceed your max CPU.~];,,,if (self.roll_total >= self.roll_target && self.roll_jackpot <= 0 && e.availablethisturn == false) { e.availablethisturn = true; e.animate(~flashandshake~); },,,,
Security Hole_upgraded,Error an enemy equipment|(only shows on error),1,inflict(~ncr_error~);,Boltzmann Brain,COUNTDOWN,8,GRAY,,,,roboterror,0,NO,NO,errorimmune|robotonly,,,,,e.availablethisturn = false; e.unavailabletext = e.displayname; e.unavailabledetails = [~This card is only usable when~|~you exceed your max CPU.~];,,,if (self.roll_total >= self.roll_target && self.roll_jackpot <= 0 && e.availablethisturn == false) { e.availablethisturn = true; e.animate(~flashandshake~); },,,,
Security Hole_downgraded,Lock an enemy dice|(only shows on error),1,inflict(LOCK);,Boltzmann Brain,COUNTDOWN,12,GRAY,,,,_lock,0,NO,NO,errorimmune|robotonly,,,,,e.availablethisturn = false; e.unavailabletext = e.displayname; e.unavailabledetails = [~This card is only usable when~|~you exceed your max CPU.~];,,,if (self.roll_total >= self.roll_target && self.roll_jackpot <= 0 && e.availablethisturn == false) { e.availablethisturn = true; e.animate(~flashandshake~); },,,,
Security Hole_weakened,Lock an enemy dice|(only shows on error),1,inflict(LOCK);,Boltzmann Brain,COUNTDOWN,8,GRAY,,,,_lock,0,NO,NO,errorimmune|robotonly,,,,,e.availablethisturn = false; e.unavailabletext = e.displayname; e.unavailabledetails = [~This card is only usable when~|~you exceed your max CPU.~];,,,if (self.roll_total >= self.roll_target && self.roll_jackpot <= 0 && e.availablethisturn == false) { e.availablethisturn = true; e.animate(~flashandshake~); },,,,
Combatfeit,Duplicate a dice,2,givedice([d| d]);,Clone Device,NORMAL,,GRAY,,,,none,0,YES,NO,skillcard|cannotsteal,,,,,,,,,,,,
Megapick,Split all dice above <slotdoubles>,1,var dicelist = []; for (mydice in self.dicepool){ if (mydice.available() && mydice.basevalue > d){ dicelist.push(mydice); } } if(dicelist.length > 0) { for(mydice in dicelist) { mydice.removedice(self.screenposition()); givedice(split(mydice.basevalue)); } } else { self.textparticle(~No effect!~); ],Razor Blade,DOUBLES|DOUBLES,,GREEN,change_power,change_power,,none,0,YES,NO,,1,,,,,,,,,,,
Megapick_downgraded,Split both dice,1,givedice(split(d).concat(split(d))|~splitdice~);,Razor Blade,DOUBLES|DOUBLES,,GREEN,,,,none,0,YES,NO,,,,,,,,,,,,,
Megapick_upgraded,Split all dice above <slotdoubles>[;]|return a dice,1,var dicelist = []; for (mydice in self.dicepool){ if (mydice.available() && mydice.basevalue > d){ dicelist.push(mydice); } } if(dicelist.length > 0) { for(mydice in dicelist) { mydice.removedice(self.screenposition()); givedice(split(mydice.basevalue)); } } else { self.textparticle(~No effect!~); ] givedice(d);,Razor Blade,DOUBLES|DOUBLES,,GREEN,,,,none,0,YES,NO,,,,,,,,,,,,,
Magic Cyanide,Do [sword]2 damage. If above 4[;]|inflict [poison]2 poison instead,1,if(d <= 4) { attack(2); sfxdamage(target|2); } else { inflict(POISON|2); sfx(~_poison~); },Anthrax,MIN3,,PURPLE,change_power,change_power,,none,0,NO,NO,,1,,,,,,,,,,,
Magic Cyanide_upgraded,Do [sword]2 damage. If above 4[;]|inflict [poison]2 poison instead|,1,if(d <= 4) { attack(2); sfxdamage(target|2); } else { inflict(POISON|2); sfx(~_poison~); },Anthrax,MIN3,,PURPLE,,,,none,2,NO,NO,,,,,,,,,,,,,
Magic Cyanide_downgraded,Do [sword]2 damage,1,attack(2);,Anthrax,RANGE34,,PURPLE,,,,none,0,NO,NO,,,,,,,,,,,,,
Murk,Roll a new [blind]blind dice|,1,givedice(); self.dicepool[self.dicepool.length - 1].blind = true; self.symbolparticle(~blind~); sfx(~_blind~);,Random Roll,NORMAL,,GRAY,change_power,removereusable,,none,4,YES,NO,,1,,,,,,,,,,,
Murk_upgraded,Roll 4 new [blind]blind dice,1,givedice([rand([1|2|3|4|5|6])|rand([1|2|3|4|5|6])|rand([1|2|3|4|5|6])|rand([1|2|3|4|5|6])]); for(i in 1...5) { if(self.dicepool[self.dicepool.length - i] != null) { self.dicepool[self.dicepool.length - i].blind = true; } } self.symbolparticle(~blind~); sfx(~_blind~);,Random Roll,NORMAL,,GRAY,,,,none,0,YES,NO,,,,,,,,,,,,,
Snatch,Do [sword]<d6> damage[;]|on 3[;] borrow equipment,2,attack(d); sfxdamage(target|d); if(!simulation && d == 3){ if(target != null) { var enemyequipment = []; for (eq in target.equipment){ if(!eq.hastag(~cannotsteal~) && eq.skillcard == ~~ && eq.availablenextturn){ enemyequipment.push(eq); } } if(enemyequipment.length > 0){ var randomequipment = rand(enemyequipment); randomequipment.availablenextturn = false; randomequipment.unavailabletext = ~Snatched!~; var stealphrases = [[~Think of it this way:~|~sharing is fun!~]|[~Mind if I borrow this?~]|[~That ~ + randomequipment.name + ~ looks~|~an awful lot like mine.~]|[~I.O.U. 1 ~ + randomequipment.name]|[~It's not your property[;]~|~it's the show's property!~]|[~I'll take this off your~|~hands for a stick of gum.~]]; if(self.name == ~Thief~) { stealphrases.push([~I'm a thief!~|~It's what I do.~]); stealphrases.push([~What's yours is mine[;] and~|~what's mine is also mine.~]); } randomequipment.unavailabledetails = rand(stealphrases).concat([~Signed[;] {enemyname}~]); sfx(~_thinghappens~); giveequipment(randomequipment.name + randomequipment.namemodifier); }}} else { if(d == 3) bonus(1000); },Reversal,MAX3,,PURPLE,change_power,change_power,,none,0,NO,NO,,,,,,,,,,delay(1.0);,,e.preventdefault = true; e.maintainfury = true;,
Snatch_upgraded,Do [sword]<d6> damage[;]|on 4[;] borrow equipment,2,attack(d); sfxdamage(target|d); if(!simulation && d == 4){ if(target != null) { var enemyequipment = []; for (eq in target.equipment){ if(!eq.hastag(~cannotsteal~) && eq.skillcard == ~~ && eq.availablenextturn){ enemyequipment.push(eq); } } if(enemyequipment.length > 0){ var randomequipment = rand(enemyequipment); randomequipment.availablenextturn = false; randomequipment.unavailabletext = ~Snatched!~; var stealphrases = [[~Think of it this way:~|~sharing is fun!~]|[~Mind if I borrow this?~]|[~That ~ + randomequipment.name + ~ looks~|~an awful lot like mine.~]|[~I.O.U. 1 ~ + randomequipment.name]|[~It's not your property[;]~|~it's the show's property!~]|[~I'll take this off your~|~hands for a stick of gum.~]]; if(self.name == ~Thief~) { stealphrases.push([~I'm a thief!~|~It's what I do.~]); stealphrases.push([~What's yours is mine[;] and~|~what's mine is also mine.~]); } randomequipment.unavailabledetails = rand(stealphrases).concat([~Signed[;] {enemyname}~]); sfx(~_thinghappens~); giveequipment(randomequipment.name + randomequipment.namemodifier); }}} else { if(d == 4) bonus(1000); },Reversal,MAX4,,PURPLE,,,,none,0,NO,NO,,,,,,,,,,delay(1.0);,,e.preventdefault = true; e.maintainfury = true;,
Snatch_downgraded,Borrow equipment until next turn,2,if(!simulation && d == 3){ if(target != null) { var enemyequipment = []; for (eq in target.equipment){ if(!eq.hastag(~cannotsteal~) && eq.skillcard == ~~ && eq.availablenextturn){ enemyequipment.push(eq); } } if(enemyequipment.length > 0){ var randomequipment = rand(enemyequipment); randomequipment.availablenextturn = false; randomequipment.unavailabletext = ~Snatched!~; var stealphrases = [[~Think of it this way:~|~sharing is fun!~]|[~Mind if I borrow this?~]|[~That ~ + randomequipment.name + ~ looks~|~an awful lot like mine.~]|[~I.O.U. 1 ~ + randomequipment.name]|[~It's not your property[;]~|~it's the show's property!~]|[~I'll take this off your~|~hands for a stick of gum.~]]; if(self.name == ~Thief~) { stealphrases.push([~I'm a thief!~|~It's what I do.~]); stealphrases.push([~What's yours is mine[;] and~|~what's mine is also mine.~]); } randomequipment.unavailabledetails = rand(stealphrases).concat([~Signed[;] {enemyname}~]); sfx(~_thinghappens~); giveequipment(randomequipment.name + randomequipment.namemodifier); }}} else { if(d == 3) bonus(1000); },Reversal,REQUIRE3,,PURPLE,,,,none,0,NO,NO,,,,,,,,,,delay(1.0);,,e.preventdefault = true; e.maintainfury = true;,
Oingo Boingo Rageblade,Do [sword]2x<slotdoubles> damage[;]|on double 6[;] gain [fury]Fury|[80%][gray]''oingo boingo rageblade''[],2,attack(d * 2); sfxdamage(target|d * 2); if(actualdice[0] != null && actualdice[0].basevalue == 6 && actualdice[1] != null && actualdice[1].basevalue == 6) { inflictself(FURY); sfx(~_fury~); },Fury,DOUBLES|DOUBLES,,RED,change_power,change_power,,none,,,,excludefromrandomlists,,,,,,,,,,,if(actualdice[0] != null && actualdice[0].basevalue == 6 && actualdice[1] != null && actualdice[1].basevalue == 6) { e.preventdefault = true; e.maintainfury = true; },
Oingo Boingo Rageblade_upgraded,Do [sword]2x<slotdoubles> damage[;]|on double 4 or 6[;] gain [fury]Fury|[80%][gray]''oingo boingo rageblade''[],2,attack(d * 2); sfxdamage(target|d * 2); if((actualdice[0] != null && actualdice[0].basevalue == 6 && actualdice[1] != null && actualdice[1].basevalue == 6) # (actualdice[0] != null && actualdice[0].basevalue == 4 && actualdice[1] != null && actualdice[1].basevalue == 4)) { inflictself(FURY); sfx(~_fury~); } /*double 4 was actually a typo; i meant double 5. then i decided 4 is cooler and we need more 4s*/,Fury,DOUBLES|DOUBLES,,RED,,,,none,,,,excludefromrandomlists,,,,,,,,,,,if((actualdice[0] != null && actualdice[0].basevalue == 6 && actualdice[1] != null && actualdice[1].basevalue == 6) # (actualdice[0] != null && actualdice[0].basevalue == 4 && actualdice[1] != null && actualdice[1].basevalue == 4)) { e.preventdefault = true; e.maintainfury = true; },
Oingo Boingo Rageblade_downgraded,Do [sword]12 damage[;] gain [fury]Fury|[80%][gray]''oingo boingo rageblade''[],2,attack(12); sfxdamage(target|12); inflictself(FURY); sfx(~_fury~);,Fury,REQUIRE6|REQUIRE6,,RED,,,,none,,,,excludefromrandomlists,,,,,,,,,,,e.preventdefault = true; e.maintainfury = true;,
Starter,Set dice range to|1[;] 2[;] 3[;] 4[;] 5[;] 6|then remove this,1,,N/A,,,GRAY,,,,none,,,,excludefromrandomlists,,,var dicerange = e.fulldescription.split(~#~.substr(0|1))[1].split(~[~ + ~;] ~); for(num in dicerange) { num -= 0; } /*cursed*/ Rules.playerdicerange(dicerange); if(Rules.overworldbutton_name == ~Dice~) { Rules.rulescreen_text[3] = ~[yellow]~ + e.name + ~[] (~ + dicerange[0] + ~[;] ~ + dicerange[1] + ~[;] ~ + dicerange[2] + ~[;] ~ + dicerange[3] + ~[;] ~ + dicerange[4] + ~[;] ~ + dicerange[5] + ~)~; removeequipment(e.name); },,,,,,,,,
Halftone,Set dice range to|1[;] 1[;] 1[;] 6[;] 6[;] 6|then remove this,1,,N/A,,,GRAY,,,,none,,,,excludefromrandomlists,,,var dicerange = e.fulldescription.split(~#~.substr(0|1))[1].split(~[~ + ~;] ~); for(num in dicerange) { num -= 0; } Rules.playerdicerange(dicerange); if(Rules.overworldbutton_name == ~Dice~) { Rules.rulescreen_text[3] = ~[yellow]~ + e.name + ~[] (~ + dicerange[0] + ~[;] ~ + dicerange[1] + ~[;] ~ + dicerange[2] + ~[;] ~ + dicerange[3] + ~[;] ~ + dicerange[4] + ~[;] ~ + dicerange[5] + ~)~; removeequipment(e.name); },,,,,,,,,
San Fransisco,Set dice range to|3[;] 3[;] 3[;] 4[;] 4[;] 4|then remove this,1,,N/A,,,GRAY,,,,none,,,,excludefromrandomlists,,,var dicerange = e.fulldescription.split(~#~.substr(0|1))[1].split(~[~ + ~;] ~); for(num in dicerange) { num -= 0; } Rules.playerdicerange(dicerange); if(Rules.overworldbutton_name == ~Dice~) { Rules.rulescreen_text[3] = ~[yellow]~ + e.name + ~[] (~ + dicerange[0] + ~[;] ~ + dicerange[1] + ~[;] ~ + dicerange[2] + ~[;] ~ + dicerange[3] + ~[;] ~ + dicerange[4] + ~[;] ~ + dicerange[5] + ~)~; removeequipment(e.name); },,,,,,,,,
Cerulean,Set dice range to|1[;] 1[;] 4[;] 5[;] 5[;] 5|then remove this,1,,N/A,,,GRAY,,,,none,,,,excludefromrandomlists,,,var dicerange = e.fulldescription.split(~#~.substr(0|1))[1].split(~[~ + ~;] ~); for(num in dicerange) { num -= 0; } Rules.playerdicerange(dicerange); if(Rules.overworldbutton_name == ~Dice~) { Rules.rulescreen_text[3] = ~[yellow]~ + e.name + ~[] (~ + dicerange[0] + ~[;] ~ + dicerange[1] + ~[;] ~ + dicerange[2] + ~[;] ~ + dicerange[3] + ~[;] ~ + dicerange[4] + ~[;] ~ + dicerange[5] + ~)~; removeequipment(e.name); },,,,,,,,,
Havana,Set dice range to|1[;] 2[;] 3[;] 5[;] 5[;] 5|then remove this,1,,N/A,,,GRAY,,,,none,,,,excludefromrandomlists,,,var dicerange = e.fulldescription.split(~#~.substr(0|1))[1].split(~[~ + ~;] ~); for(num in dicerange) { num -= 0; } Rules.playerdicerange(dicerange); if(Rules.overworldbutton_name == ~Dice~) { Rules.rulescreen_text[3] = ~[yellow]~ + e.name + ~[] (~ + dicerange[0] + ~[;] ~ + dicerange[1] + ~[;] ~ + dicerange[2] + ~[;] ~ + dicerange[3] + ~[;] ~ + dicerange[4] + ~[;] ~ + dicerange[5] + ~)~; removeequipment(e.name); },,,,,,,,,
Beauty,Set dice range to|1[;] 2[;] 3[;] 3[;] 6[;] 6|then remove this,1,,N/A,,,GRAY,,,,none,,,,excludefromrandomlists,,,var dicerange = e.fulldescription.split(~#~.substr(0|1))[1].split(~[~ + ~;] ~); for(num in dicerange) { num -= 0; } Rules.playerdicerange(dicerange); if(Rules.overworldbutton_name == ~Dice~) { Rules.rulescreen_text[3] = ~[yellow]~ + e.name + ~[] (~ + dicerange[0] + ~[;] ~ + dicerange[1] + ~[;] ~ + dicerange[2] + ~[;] ~ + dicerange[3] + ~[;] ~ + dicerange[4] + ~[;] ~ + dicerange[5] + ~)~; removeequipment(e.name); },,,,,,,,,
Lucky Lou,Set dice range to|2[;] 2[;] 3[;] 3[;] 5[;] 6|then remove this,1,,N/A,,,GRAY,,,,none,,,,excludefromrandomlists,,,var dicerange = e.fulldescription.split(~#~.substr(0|1))[1].split(~[~ + ~;] ~); for(num in dicerange) { num -= 0; } Rules.playerdicerange(dicerange); if(Rules.overworldbutton_name == ~Dice~) { Rules.rulescreen_text[3] = ~[yellow]~ + e.name + ~[] (~ + dicerange[0] + ~[;] ~ + dicerange[1] + ~[;] ~ + dicerange[2] + ~[;] ~ + dicerange[3] + ~[;] ~ + dicerange[4] + ~[;] ~ + dicerange[5] + ~)~; removeequipment(e.name); },,,,,,,,,
Valley Girl,Set dice range to|1[;] 1[;] 3[;] 5[;] 5[;] 6|then remove this,1,,N/A,,,GRAY,,,,none,,,,excludefromrandomlists,,,var dicerange = e.fulldescription.split(~#~.substr(0|1))[1].split(~[~ + ~;] ~); for(num in dicerange) { num -= 0; } Rules.playerdicerange(dicerange); if(Rules.overworldbutton_name == ~Dice~) { Rules.rulescreen_text[3] = ~[yellow]~ + e.name + ~[] (~ + dicerange[0] + ~[;] ~ + dicerange[1] + ~[;] ~ + dicerange[2] + ~[;] ~ + dicerange[3] + ~[;] ~ + dicerange[4] + ~[;] ~ + dicerange[5] + ~)~; removeequipment(e.name); },,,,,,,,,
Freedom,Set dice range to|2[;] 3[;] 3[;] 4[;] 4[;] 5|then remove this,1,,N/A,,,GRAY,,,,none,,,,excludefromrandomlists,,,var dicerange = e.fulldescription.split(~#~.substr(0|1))[1].split(~[~ + ~;] ~); for(num in dicerange) { num -= 0; } Rules.playerdicerange(dicerange); if(Rules.overworldbutton_name == ~Dice~) { Rules.rulescreen_text[3] = ~[yellow]~ + e.name + ~[] (~ + dicerange[0] + ~[;] ~ + dicerange[1] + ~[;] ~ + dicerange[2] + ~[;] ~ + dicerange[3] + ~[;] ~ + dicerange[4] + ~[;] ~ + dicerange[5] + ~)~; removeequipment(e.name); },,,,,,,,,
Montreal,Set dice range to|1[;] 1[;] 2[;] 5[;] 6[;] 6|then remove this,1,,N/A,,,GRAY,,,,none,,,,excludefromrandomlists,,,var dicerange = e.fulldescription.split(~#~.substr(0|1))[1].split(~[~ + ~;] ~); for(num in dicerange) { num -= 0; } Rules.playerdicerange(dicerange); if(Rules.overworldbutton_name == ~Dice~) { Rules.rulescreen_text[3] = ~[yellow]~ + e.name + ~[] (~ + dicerange[0] + ~[;] ~ + dicerange[1] + ~[;] ~ + dicerange[2] + ~[;] ~ + dicerange[3] + ~[;] ~ + dicerange[4] + ~[;] ~ + dicerange[5] + ~)~; removeequipment(e.name); },,,,,,,,,
Celery,Set dice range to|1[;] 3[;] 3[;] 3[;] 5[;] 6|then remove this,1,,N/A,,,GRAY,,,,none,,,,excludefromrandomlists,,,var dicerange = e.fulldescription.split(~#~.substr(0|1))[1].split(~[~ + ~;] ~); for(num in dicerange) { num -= 0; } Rules.playerdicerange(dicerange); if(Rules.overworldbutton_name == ~Dice~) { Rules.rulescreen_text[3] = ~[yellow]~ + e.name + ~[] (~ + dicerange[0] + ~[;] ~ + dicerange[1] + ~[;] ~ + dicerange[2] + ~[;] ~ + dicerange[3] + ~[;] ~ + dicerange[4] + ~[;] ~ + dicerange[5] + ~)~; removeequipment(e.name); },,,,,,,,,
Trefoil,Set dice range to|2[;] 3[;] 3[;] 3[;] 5[;] 5|then remove this,1,,N/A,,,GRAY,,,,none,,,,excludefromrandomlists,,,var dicerange = e.fulldescription.split(~#~.substr(0|1))[1].split(~[~ + ~;] ~); for(num in dicerange) { num -= 0; } Rules.playerdicerange(dicerange); if(Rules.overworldbutton_name == ~Dice~) { Rules.rulescreen_text[3] = ~[yellow]~ + e.name + ~[] (~ + dicerange[0] + ~[;] ~ + dicerange[1] + ~[;] ~ + dicerange[2] + ~[;] ~ + dicerange[3] + ~[;] ~ + dicerange[4] + ~[;] ~ + dicerange[5] + ~)~; removeequipment(e.name); },,,,,,,,,
Jackpot@platonicdice,Set dice range to|2[;] 3[;] 3[;] 3[;] 4[;] 6|then remove this,1,,N/A,,,GRAY,,,,none,,,,excludefromrandomlists,,,var dicerange = e.fulldescription.split(~#~.substr(0|1))[1].split(~[~ + ~;] ~); for(num in dicerange) { num -= 0; } Rules.playerdicerange(dicerange); if(Rules.overworldbutton_name == ~Dice~) { Rules.rulescreen_text[3] = ~[yellow]Jackpot[] (~ + dicerange[0] + ~[;] ~ + dicerange[1] + ~[;] ~ + dicerange[2] + ~[;] ~ + dicerange[3] + ~[;] ~ + dicerange[4] + ~[;] ~ + dicerange[5] + ~)~; removeequipment(e.name); },,,,,,,,,
Gold Dust,Set dice range to|1[;] 3[;] 3[;] 4[;] 4[;] 6|then remove this,1,,N/A,,,GRAY,,,,none,,,,excludefromrandomlists,,,var dicerange = e.fulldescription.split(~#~.substr(0|1))[1].split(~[~ + ~;] ~); for(num in dicerange) { num -= 0; } Rules.playerdicerange(dicerange); if(Rules.overworldbutton_name == ~Dice~) { Rules.rulescreen_text[3] = ~[yellow]~ + e.name + ~[] (~ + dicerange[0] + ~[;] ~ + dicerange[1] + ~[;] ~ + dicerange[2] + ~[;] ~ + dicerange[3] + ~[;] ~ + dicerange[4] + ~[;] ~ + dicerange[5] + ~)~; removeequipment(e.name); },,,,,,,,,
Serenity,Set dice range to|3[;] 3[;] 3[;] 3[;] 3[;] 6|then remove this,1,,N/A,,,GRAY,,,,none,,,,excludefromrandomlists,,,var dicerange = e.fulldescription.split(~#~.substr(0|1))[1].split(~[~ + ~;] ~); for(num in dicerange) { num -= 0; } Rules.playerdicerange(dicerange); if(Rules.overworldbutton_name == ~Dice~) { Rules.rulescreen_text[3] = ~[yellow]~ + e.name + ~[] (~ + dicerange[0] + ~[;] ~ + dicerange[1] + ~[;] ~ + dicerange[2] + ~[;] ~ + dicerange[3] + ~[;] ~ + dicerange[4] + ~[;] ~ + dicerange[5] + ~)~; removeequipment(e.name); },,,,,,,,,
Rocket,Set dice range to|2[;] 2[;] 3[;] 4[;] 4[;] 6|then remove this,1,,N/A,,,GRAY,,,,none,,,,excludefromrandomlists,,,var dicerange = e.fulldescription.split(~#~.substr(0|1))[1].split(~[~ + ~;] ~); for(num in dicerange) { num -= 0; } Rules.playerdicerange(dicerange); if(Rules.overworldbutton_name == ~Dice~) { Rules.rulescreen_text[3] = ~[yellow]~ + e.name + ~[] (~ + dicerange[0] + ~[;] ~ + dicerange[1] + ~[;] ~ + dicerange[2] + ~[;] ~ + dicerange[3] + ~[;] ~ + dicerange[4] + ~[;] ~ + dicerange[5] + ~)~; removeequipment(e.name); },,,,,,,,,
Li Li,Set dice range to|3[;] 3[;] 3[;] 3[;] 4[;] 5|then remove this,1,,N/A,,,GRAY,,,,none,,,,excludefromrandomlists,,,var dicerange = e.fulldescription.split(~#~.substr(0|1))[1].split(~[~ + ~;] ~); for(num in dicerange) { num -= 0; } Rules.playerdicerange(dicerange); if(Rules.overworldbutton_name == ~Dice~) { Rules.rulescreen_text[3] = ~[yellow]~ + e.name + ~[] (~ + dicerange[0] + ~[;] ~ + dicerange[1] + ~[;] ~ + dicerange[2] + ~[;] ~ + dicerange[3] + ~[;] ~ + dicerange[4] + ~[;] ~ + dicerange[5] + ~)~; removeequipment(e.name); },,,,,,,,,
Promenade,Set dice range to|1[;] 2[;] 4[;] 4[;] 5[;] 5|then remove this,1,,N/A,,,GRAY,,,,none,,,,excludefromrandomlists,,,var dicerange = e.fulldescription.split(~#~.substr(0|1))[1].split(~[~ + ~;] ~); for(num in dicerange) { num -= 0; } Rules.playerdicerange(dicerange); if(Rules.overworldbutton_name == ~Dice~) { Rules.rulescreen_text[3] = ~[yellow]~ + e.name + ~[] (~ + dicerange[0] + ~[;] ~ + dicerange[1] + ~[;] ~ + dicerange[2] + ~[;] ~ + dicerange[3] + ~[;] ~ + dicerange[4] + ~[;] ~ + dicerange[5] + ~)~; removeequipment(e.name); },,,,,,,,,
Constance,Set dice range to|1[;] 3[;] 3[;] 4[;] 5[;] 5|then remove this,1,,N/A,,,GRAY,,,,none,,,,excludefromrandomlists,,,var dicerange = e.fulldescription.split(~#~.substr(0|1))[1].split(~[~ + ~;] ~); for(num in dicerange) { num -= 0; } Rules.playerdicerange(dicerange); if(Rules.overworldbutton_name == ~Dice~) { Rules.rulescreen_text[3] = ~[yellow]~ + e.name + ~[] (~ + dicerange[0] + ~[;] ~ + dicerange[1] + ~[;] ~ + dicerange[2] + ~[;] ~ + dicerange[3] + ~[;] ~ + dicerange[4] + ~[;] ~ + dicerange[5] + ~)~; removeequipment(e.name); },,,,,,,,,
Lumberjack,Set dice range to|2[;] 2[;] 3[;] 4[;] 5[;] 5|then remove this,1,,N/A,,,GRAY,,,,none,,,,excludefromrandomlists,,,var dicerange = e.fulldescription.split(~#~.substr(0|1))[1].split(~[~ + ~;] ~); for(num in dicerange) { num -= 0; } Rules.playerdicerange(dicerange); if(Rules.overworldbutton_name == ~Dice~) { Rules.rulescreen_text[3] = ~[yellow]~ + e.name + ~[] (~ + dicerange[0] + ~[;] ~ + dicerange[1] + ~[;] ~ + dicerange[2] + ~[;] ~ + dicerange[3] + ~[;] ~ + dicerange[4] + ~[;] ~ + dicerange[5] + ~)~; removeequipment(e.name); },,,,,,,,,
Pumpernickel,Set dice range to|1[;] 2[;] 4[;] 4[;] 4[;] 6|then remove this,1,,N/A,,,GRAY,,,,none,,,,excludefromrandomlists,,,var dicerange = e.fulldescription.split(~#~.substr(0|1))[1].split(~[~ + ~;] ~); for(num in dicerange) { num -= 0; } Rules.playerdicerange(dicerange); if(Rules.overworldbutton_name == ~Dice~) { Rules.rulescreen_text[3] = ~[yellow]~ + e.name + ~[] (~ + dicerange[0] + ~[;] ~ + dicerange[1] + ~[;] ~ + dicerange[2] + ~[;] ~ + dicerange[3] + ~[;] ~ + dicerange[4] + ~[;] ~ + dicerange[5] + ~)~; removeequipment(e.name); },,,,,,,,,
Citrus,Set dice range to|1[;] 1[;] 3[;] 4[;] 6[;] 6|then remove this,1,,N/A,,,GRAY,,,,none,,,,excludefromrandomlists,,,var dicerange = e.fulldescription.split(~#~.substr(0|1))[1].split(~[~ + ~;] ~); for(num in dicerange) { num -= 0; } Rules.playerdicerange(dicerange); if(Rules.overworldbutton_name == ~Dice~) { Rules.rulescreen_text[3] = ~[yellow]~ + e.name + ~[] (~ + dicerange[0] + ~[;] ~ + dicerange[1] + ~[;] ~ + dicerange[2] + ~[;] ~ + dicerange[3] + ~[;] ~ + dicerange[4] + ~[;] ~ + dicerange[5] + ~)~; removeequipment(e.name); },,,,,,,,,
Gogo,Set dice range to|1[;] 1[;] 4[;] 4[;] 5[;] 6|then remove this,1,,N/A,,,GRAY,,,,none,,,,excludefromrandomlists,,,var dicerange = e.fulldescription.split(~#~.substr(0|1))[1].split(~[~ + ~;] ~); for(num in dicerange) { num -= 0; } Rules.playerdicerange(dicerange); if(Rules.overworldbutton_name == ~Dice~) { Rules.rulescreen_text[3] = ~[yellow]~ + e.name + ~[] (~ + dicerange[0] + ~[;] ~ + dicerange[1] + ~[;] ~ + dicerange[2] + ~[;] ~ + dicerange[3] + ~[;] ~ + dicerange[4] + ~[;] ~ + dicerange[5] + ~)~; removeequipment(e.name); },,,,,,,,,
Old Bill,Set dice range to|2[;] 2[;] 2[;] 3[;] 6[;] 6|then remove this,1,,N/A,,,GRAY,,,,none,,,,excludefromrandomlists,,,var dicerange = e.fulldescription.split(~#~.substr(0|1))[1].split(~[~ + ~;] ~); for(num in dicerange) { num -= 0; } Rules.playerdicerange(dicerange); if(Rules.overworldbutton_name == ~Dice~) { Rules.rulescreen_text[3] = ~[yellow]~ + e.name + ~[] (~ + dicerange[0] + ~[;] ~ + dicerange[1] + ~[;] ~ + dicerange[2] + ~[;] ~ + dicerange[3] + ~[;] ~ + dicerange[4] + ~[;] ~ + dicerange[5] + ~)~; removeequipment(e.name); },,,,,,,,,
Delaware,Set dice range to|2[;] 2[;] 2[;] 5[;] 5[;] 5|then remove this,1,,N/A,,,GRAY,,,,none,,,,excludefromrandomlists,,,var dicerange = e.fulldescription.split(~#~.substr(0|1))[1].split(~[~ + ~;] ~); for(num in dicerange) { num -= 0; } Rules.playerdicerange(dicerange); if(Rules.overworldbutton_name == ~Dice~) { Rules.rulescreen_text[3] = ~[yellow]~ + e.name + ~[] (~ + dicerange[0] + ~[;] ~ + dicerange[1] + ~[;] ~ + dicerange[2] + ~[;] ~ + dicerange[3] + ~[;] ~ + dicerange[4] + ~[;] ~ + dicerange[5] + ~)~; removeequipment(e.name); },,,,,,,,,
Blossom,Set dice range to|1[;] 2[;] 2[;] 4[;] 6[;] 6|then remove this,1,,N/A,,,GRAY,,,,none,,,,excludefromrandomlists,,,var dicerange = e.fulldescription.split(~#~.substr(0|1))[1].split(~[~ + ~;] ~); for(num in dicerange) { num -= 0; } Rules.playerdicerange(dicerange); if(Rules.overworldbutton_name == ~Dice~) { Rules.rulescreen_text[3] = ~[yellow]~ + e.name + ~[] (~ + dicerange[0] + ~[;] ~ + dicerange[1] + ~[;] ~ + dicerange[2] + ~[;] ~ + dicerange[3] + ~[;] ~ + dicerange[4] + ~[;] ~ + dicerange[5] + ~)~; removeequipment(e.name); },,,,,,,,,
Shotput,Set dice range to|1[;] 2[;] 2[;] 5[;] 5[;] 6|then remove this,1,,N/A,,,GRAY,,,,none,,,,excludefromrandomlists,,,var dicerange = e.fulldescription.split(~#~.substr(0|1))[1].split(~[~ + ~;] ~); for(num in dicerange) { num -= 0; } Rules.playerdicerange(dicerange); if(Rules.overworldbutton_name == ~Dice~) { Rules.rulescreen_text[3] = ~[yellow]~ + e.name + ~[] (~ + dicerange[0] + ~[;] ~ + dicerange[1] + ~[;] ~ + dicerange[2] + ~[;] ~ + dicerange[3] + ~[;] ~ + dicerange[4] + ~[;] ~ + dicerange[5] + ~)~; removeequipment(e.name); },,,,,,,,,
Fido,Set dice range to|2[;] 2[;] 2[;] 4[;] 5[;] 6|then remove this,1,,N/A,,,GRAY,,,,none,,,,excludefromrandomlists,,,var dicerange = e.fulldescription.split(~#~.substr(0|1))[1].split(~[~ + ~;] ~); for(num in dicerange) { num -= 0; } Rules.playerdicerange(dicerange); if(Rules.overworldbutton_name == ~Dice~) { Rules.rulescreen_text[3] = ~[yellow]~ + e.name + ~[] (~ + dicerange[0] + ~[;] ~ + dicerange[1] + ~[;] ~ + dicerange[2] + ~[;] ~ + dicerange[3] + ~[;] ~ + dicerange[4] + ~[;] ~ + dicerange[5] + ~)~; removeequipment(e.name); },,,,,,,,,
Bournville,Set dice range to|2[;] 3[;] 4[;] 4[;] 4[;] 4|then remove this,1,,N/A,,,GRAY,,,,none,,,,excludefromrandomlists,,,var dicerange = e.fulldescription.split(~#~.substr(0|1))[1].split(~[~ + ~;] ~); for(num in dicerange) { num -= 0; } Rules.playerdicerange(dicerange); if(Rules.overworldbutton_name == ~Dice~) { Rules.rulescreen_text[3] = ~[yellow]~ + e.name + ~[] (~ + dicerange[0] + ~[;] ~ + dicerange[1] + ~[;] ~ + dicerange[2] + ~[;] ~ + dicerange[3] + ~[;] ~ + dicerange[4] + ~[;] ~ + dicerange[5] + ~)~; removeequipment(e.name); },,,,,,,,,
Lincoln,Set dice range to|2[;] 2[;] 4[;] 4[;] 4[;] 5|then remove this,1,,N/A,,,GRAY,,,,none,,,,excludefromrandomlists,,,var dicerange = e.fulldescription.split(~#~.substr(0|1))[1].split(~[~ + ~;] ~); for(num in dicerange) { num -= 0; } Rules.playerdicerange(dicerange); if(Rules.overworldbutton_name == ~Dice~) { Rules.rulescreen_text[3] = ~[yellow]~ + e.name + ~[] (~ + dicerange[0] + ~[;] ~ + dicerange[1] + ~[;] ~ + dicerange[2] + ~[;] ~ + dicerange[3] + ~[;] ~ + dicerange[4] + ~[;] ~ + dicerange[5] + ~)~; removeequipment(e.name); },,,,,,,,,
Paris,Set dice range to|1[;] 4[;] 4[;] 4[;] 4[;] 4|then remove this,1,,N/A,,,GRAY,,,,none,,,,excludefromrandomlists,,,var dicerange = e.fulldescription.split(~#~.substr(0|1))[1].split(~[~ + ~;] ~); for(num in dicerange) { num -= 0; } Rules.playerdicerange(dicerange); if(Rules.overworldbutton_name == ~Dice~) { Rules.rulescreen_text[3] = ~[yellow]~ + e.name + ~[] (~ + dicerange[0] + ~[;] ~ + dicerange[1] + ~[;] ~ + dicerange[2] + ~[;] ~ + dicerange[3] + ~[;] ~ + dicerange[4] + ~[;] ~ + dicerange[5] + ~)~; removeequipment(e.name); },,,,,,,,,
November,Set dice range to|1[;] 3[;] 4[;] 4[;] 4[;] 5|then remove this,1,,N/A,,,GRAY,,,,none,,,,excludefromrandomlists,,,var dicerange = e.fulldescription.split(~#~.substr(0|1))[1].split(~[~ + ~;] ~); for(num in dicerange) { num -= 0; } Rules.playerdicerange(dicerange); if(Rules.overworldbutton_name == ~Dice~) { Rules.rulescreen_text[3] = ~[yellow]~ + e.name + ~[] (~ + dicerange[0] + ~[;] ~ + dicerange[1] + ~[;] ~ + dicerange[2] + ~[;] ~ + dicerange[3] + ~[;] ~ + dicerange[4] + ~[;] ~ + dicerange[5] + ~)~; removeequipment(e.name); },,,,,,,,,
Rosepetal Blade,Pluck flower petals[;]|do [sword]??? damage,1,var p = 2; for(d in [actualdice[0]|actualdice[1]]){ if(d.basevalue == 3 # d.basevalue == 5){ p += d.basevalue - 1;} } if(p > 0) { attack(p); sfxdamage(target|p); } else { self.textparticle(~No effect!~); },Drunken Boxing,NORMAL|NORMAL|FREE3,,RED,change_power,change_power,,none,,,,,1,,,,,,,,,,,
Rosepetal Blade_downgraded,Pluck flower petals[;]|do [sword]??? damage,1,var p = 0; for(d in [actualdice[0]|actualdice[1]]){ if(d.basevalue == 3 # d.basevalue == 5){ p += d.basevalue - 1;} } if(p > 0) { attack(p); sfxdamage(target|p); } else { self.textparticle(~No effect!~); },Drunken Boxing,NORMAL|NORMAL,,RED,,,,none,,,,,,,,,,,,,,,,
Rosepetal Blade_upgraded,Pluck flower petals[;]|do [sword]??? damage,1,var p = 4; for(d in [actualdice[0]|actualdice[1]]){ if(d.basevalue == 3 # d.basevalue == 5){ p += d.basevalue - 1;} } if(p > 0) { attack(p); sfxdamage(target|p); } else { self.textparticle(~No effect!~); },Drunken Boxing,NORMAL|NORMAL|FREE5,,RED,,,,none,,,,,,,,,,,,,,,,
Spin Attack,Do [sword]<d6> damage. On 6[;]|[lock]counter a random dice|that's not countered yet,2,attack(d); sfxdamage(target|d); if(d == 6) { var availablecounters = [1|2|3|4|5|6]; for(num in availablecounters) { if(getstatus(~counter_~ + num) > 0) { availablecounters.remove(num); } } if(availablecounters.length == 0) { self.textparticle(~No effect!~); } else { inflict(~counter_~ + rand(availablecounters)); sfx(~_lock~|~~|0.2); } },Copyright Strike,NORMAL,,PURPLE,change_power,change_power,,none,,,,,,,,,,,,,,,,
Spin Attack_downgraded,Do [sword]<d6> damage. On 6[;]|[lock]counter the lowest dice|that's not countered yet,2,attack(d); sfxdamage(target|d); if(d == 6) { var availablecounters = [1|2|3|4|5|6]; for(num in availablecounters) { if(getstatus(~counter_~ + num) > 0) { availablecounters.remove(num); } } if(availablecounters.length == 0) { self.textparticle(~No effect!~); } else { inflict(~counter_~ + availablecounters[0]); sfx(~_lock~|~~|0.2); } },Copyright Strike,NORMAL,,PURPLE,,,,none,,,,,,,,,,,,,,,,
Spin Attack_upgraded,Do [sword]<d6> damage. On 6[;]|[lock]counter the highest dice|that's not countered yet,2,attack(d); sfxdamage(target|d); if(d == 6) { var availablecounters = [1|2|3|4|5|6]; for(num in availablecounters) { if(getstatus(~counter_~ + num) > 0) { availablecounters.remove(num); } } if(availablecounters.length == 0) { self.textparticle(~No effect!~); } else { inflict(~counter_~ + availablecounters[availablecounters.length - 1]); sfx(~_lock~|~~|0.2); } },Copyright Strike,NORMAL,,PURPLE,,,,none,,,,,,,,,,,,,,,,
Strange Parcel,Do [sword]<d6> damage. On 1[;] get|an [quote]on 6[quote] item for this turn,2,if(!simulation) { for(eq in self.equipment) { eq.setvar(~alreadyheretemp~|1); } } attack(d); sfxdamage(target|d); if(d == 1 && simulation) bonus(-9999999); if(d == 1 && !simulation) { sfx(~_thinghappens~); var descriptionwhitelist = [~#~.substr(0|1) + ~On 6[;~ + ~]~|~#~.substr(0|1) + ~on 6[;~ + ~]~|~ on 6[;~ + ~]~|~ On 6[;~ + ~]~]; var descriptionblacklist = loadtext(~ncrmod/itemspawnerdescblacklist~); var scriptblacklist = [~self.equipment~|~new elements.Equipment~]; var checkblacklist = function(text|list) { for(phrase in list) { if(text.indexOf(phrase) != -1) { return(false); } } return(true); }; var on6eq = ~~; var exceptions = [~skillcard~|~excludefromrandomlists~|~alternateversion~|~robotonly~|~witchonly~|~inventoronly~|~onceperbattle~]; if(self.usecpuinsteadofdice) exceptions.remove(~robotonly~); if(self.getskillcard() != null && self.getskillcard().skillcard == ~witch~) exceptions.remove(~witchonly~); if(self.getskillcard() != null && self.getskillcard().skillcard == ~inventor~) exceptions.remove(~inventoronly~); var geteqs = getequipmentlist(null|[]|exceptions); geteqs = shuffle(geteqs); var placeholder = new elements.Equipment(~Loud Yelling~); var count = 0; while(on6eq == ~~) { placeholder.create(geteqs[count]); trace(placeholder.fulldescription); var ds = placeholder.fulldescription; var sc = placeholder.script; var scbx = placeholder.scriptbeforeexecute; if(!(checkblacklist(ds|descriptionwhitelist)) && checkblacklist(ds|descriptionblacklist) && checkblacklist(sc|scriptblacklist) && checkblacklist(scbx|scriptblacklist)) { on6eq = placeholder.name; } /*else { geteqs.remove(placeholder.name); }*/ count++; trace(count); if(count >= geteqs.length) { placeholder.create(~e.name~); on6eq = ~e.name~; break; } } giveequipment(on6eq|true); for(eq in self.equipment) { if(eq.getvar(~alreadyheretemp~) != 1) { self.setvar(~doonthis~|eq); } } var estandardize = ~var e = self.getvar(\~doonthis\~); ~;var doscripts = new elements.Skill(~Against all odds_old~); doscripts.script = estandardize + placeholder.scriptbeforecombat; doscripts.execute(self|target); doscripts.script = estandardize + placeholder.scriptbeforestartturn; doscripts.execute(self|target); doscripts.script = estandardize + placeholder.scriptonstartturn; doscripts.execute(self|target); self.resetvar(~doonthis~); placeholder.name = ~deletemetemp~; self.equipment.push(placeholder); removeequipment(~deletemetemp~); } if(!simulation) { for(eq in self.equipment) { eq.resetvar(~alreadyheretemp~); } },Boltzmann Brain,NORMAL,,ORANGE,change_power,change_power,,none,,,,excludefromrandomlists,,if(!simulation) { for(eq in self.equipment) { eq.setvar(~alreadyheretemp~|1); } } if(d == 1 && simulation) bonus(-9999999); if(d == 1 && !simulation) { sfx(~_thinghappens~); var descriptionwhitelist = [~#~.substr(0|1) + ~On 6[;~ + ~]~|~#~.substr(0|1) + ~on 6[;~ + ~]~|~ on 6[;~ + ~]~|~ On 6[;~ + ~]~]; var descriptionblacklist = loadtext(~ncrmod/itemspawnerdescblacklist~); var scriptblacklist = [~self.equipment~|~new elements.Equipment~]; var checkblacklist = function(text|list) { for(phrase in list) { if(text.indexOf(phrase) != -1) { return(false); } } return(true); }; var on6eq = ~~; var exceptions = [~skillcard~|~excludefromrandomlists~|~alternateversion~|~robotonly~|~witchonly~|~inventoronly~|~onceperbattle~]; if(self.usecpuinsteadofdice) exceptions.remove(~robotonly~); if(self.getskillcard() != null && self.getskillcard().skillcard == ~witch~) exceptions.remove(~witchonly~); if(self.getskillcard() != null && self.getskillcard().skillcard == ~inventor~) exceptions.remove(~inventoronly~); var geteqs = getequipmentlist(null|[]|exceptions); geteqs = shuffle(geteqs); var placeholder = new elements.Equipment(~Loud Yelling~); var count = 0; while(on6eq == ~~) { placeholder.create(geteqs[count]); trace(placeholder.fulldescription); var ds = placeholder.fulldescription; var sc = placeholder.script; var scbx = placeholder.scriptbeforeexecute; if(!(checkblacklist(ds|descriptionwhitelist)) && checkblacklist(ds|descriptionblacklist) && checkblacklist(sc|scriptblacklist) && checkblacklist(scbx|scriptblacklist)) { on6eq = placeholder.name; } /*else { geteqs.remove(placeholder.name); }*/ count++; trace(count); if(count >= geteqs.length) { placeholder.create(~e.name~); on6eq = ~e.name~; break; } } giveequipment(on6eq|true); for(eq in self.equipment) { if(eq.getvar(~alreadyheretemp~) != 1) { self.setvar(~doonthis~|eq); } } var estandardize = ~var e = self.getvar(\~doonthis\~); ~;var doscripts = new elements.Skill(~Against all odds_old~); doscripts.script = estandardize + placeholder.scriptbeforecombat; doscripts.execute(self|target); doscripts.script = estandardize + placeholder.scriptbeforestartturn; doscripts.execute(self|target); doscripts.script = estandardize + placeholder.scriptonstartturn; doscripts.execute(self|target); self.resetvar(~doonthis~); placeholder.name = ~deletemetemp~; self.equipment.push(placeholder); removeequipment(~deletemetemp~); } if(!simulation) { for(eq in self.equipment) { eq.resetvar(~alreadyheretemp~); } },,,,,,,if(d == 1) { e.maintainfury = true; e.preventdefault = true; },,donothing();,
Strange Parcel_upgraded,Do [sword]<d6> damage. On 3[;] get|an [quote]on 6[quote] item for this turn,2,if(!simulation) { for(eq in self.equipment) { eq.setvar(~alreadyheretemp~|1); } } attack(d); sfxdamage(target|d); if(d == 3 && simulation) bonus(-9999999); if(d == 3 && !simulation) { sfx(~_thinghappens~); var descriptionwhitelist = [~#~.substr(0|1) + ~On 6[;~ + ~]~|~#~.substr(0|1) + ~on 6[;~ + ~]~|~ on 6[;~ + ~]~|~ On 6[;~ + ~]~]; var descriptionblacklist = loadtext(~ncrmod/itemspawnerdescblacklist~); var scriptblacklist = [~self.equipment~|~new elements.Equipment~]; var checkblacklist = function(text|list) { for(phrase in list) { if(text.indexOf(phrase) != -1) { return(false); } } return(true); }; var on6eq = ~~; var exceptions = [~skillcard~|~excludefromrandomlists~|~alternateversion~|~robotonly~|~witchonly~|~inventoronly~|~onceperbattle~]; if(self.usecpuinsteadofdice) exceptions.remove(~robotonly~); if(self.getskillcard() != null && self.getskillcard().skillcard == ~witch~) exceptions.remove(~witchonly~); if(self.getskillcard() != null && self.getskillcard().skillcard == ~inventor~) exceptions.remove(~inventoronly~); var geteqs = getequipmentlist(null|[]|exceptions); geteqs = shuffle(geteqs); var placeholder = new elements.Equipment(~Loud Yelling~); var count = 0; while(on6eq == ~~) { placeholder.create(geteqs[count]); trace(placeholder.fulldescription); var ds = placeholder.fulldescription; var sc = placeholder.script; var scbx = placeholder.scriptbeforeexecute; if(!(checkblacklist(ds|descriptionwhitelist)) && checkblacklist(ds|descriptionblacklist) && checkblacklist(sc|scriptblacklist) && checkblacklist(scbx|scriptblacklist)) { on6eq = placeholder.name; } /*else { geteqs.remove(placeholder.name); }*/ count++; trace(count); if(count >= geteqs.length) { placeholder.create(~e.name~); on6eq = ~e.name~; break; } } giveequipment(on6eq|true); for(eq in self.equipment) { if(eq.getvar(~alreadyheretemp~) != 1) { self.setvar(~doonthis~|eq); } } var estandardize = ~var e = self.getvar(\~doonthis\~); ~;var doscripts = new elements.Skill(~Against all odds_old~); doscripts.script = estandardize + placeholder.scriptbeforecombat; doscripts.execute(self|target); doscripts.script = estandardize + placeholder.scriptbeforestartturn; doscripts.execute(self|target); doscripts.script = estandardize + placeholder.scriptonstartturn; doscripts.execute(self|target); self.resetvar(~doonthis~); placeholder.name = ~deletemetemp~; self.equipment.push(placeholder); removeequipment(~deletemetemp~); } if(!simulation) { for(eq in self.equipment) { eq.resetvar(~alreadyheretemp~); } },Boltzmann Brain,NORMAL,,ORANGE,,,,none,,,,excludefromrandomlists,,if(!simulation) { for(eq in self.equipment) { eq.setvar(~alreadyheretemp~|1); } } if(d == 3 && simulation) bonus(-9999999); if(d == 3 && !simulation) { sfx(~_thinghappens~); var descriptionwhitelist = [~#~.substr(0|1) + ~On 6[;~ + ~]~|~#~.substr(0|1) + ~on 6[;~ + ~]~|~ on 6[;~ + ~]~|~ On 6[;~ + ~]~]; var descriptionblacklist = loadtext(~ncrmod/itemspawnerdescblacklist~); var scriptblacklist = [~self.equipment~|~new elements.Equipment~]; var checkblacklist = function(text|list) { for(phrase in list) { if(text.indexOf(phrase) != -1) { return(false); } } return(true); }; var on6eq = ~~; var exceptions = [~skillcard~|~excludefromrandomlists~|~alternateversion~|~robotonly~|~witchonly~|~inventoronly~|~onceperbattle~]; if(self.usecpuinsteadofdice) exceptions.remove(~robotonly~); if(self.getskillcard() != null && self.getskillcard().skillcard == ~witch~) exceptions.remove(~witchonly~); if(self.getskillcard() != null && self.getskillcard().skillcard == ~inventor~) exceptions.remove(~inventoronly~); var geteqs = getequipmentlist(null|[]|exceptions); geteqs = shuffle(geteqs); var placeholder = new elements.Equipment(~Loud Yelling~); var count = 0; while(on6eq == ~~) { placeholder.create(geteqs[count]); trace(placeholder.fulldescription); var ds = placeholder.fulldescription; var sc = placeholder.script; var scbx = placeholder.scriptbeforeexecute; if(!(checkblacklist(ds|descriptionwhitelist)) && checkblacklist(ds|descriptionblacklist) && checkblacklist(sc|scriptblacklist) && checkblacklist(scbx|scriptblacklist)) { on6eq = placeholder.name; } /*else { geteqs.remove(placeholder.name); }*/ count++; trace(count); if(count >= geteqs.length) { placeholder.create(~e.name~); on6eq = ~e.name~; break; } } giveequipment(on6eq|true); for(eq in self.equipment) { if(eq.getvar(~alreadyheretemp~) != 1) { self.setvar(~doonthis~|eq); } } var estandardize = ~var e = self.getvar(\~doonthis\~); ~;var doscripts = new elements.Skill(~Against all odds_old~); doscripts.script = estandardize + placeholder.scriptbeforecombat; doscripts.execute(self|target); doscripts.script = estandardize + placeholder.scriptbeforestartturn; doscripts.execute(self|target); doscripts.script = estandardize + placeholder.scriptonstartturn; doscripts.execute(self|target); self.resetvar(~doonthis~); placeholder.name = ~deletemetemp~; self.equipment.push(placeholder); removeequipment(~deletemetemp~); } if(!simulation) { for(eq in self.equipment) { eq.resetvar(~alreadyheretemp~); } },,,,,,,if(d == 3) { e.maintainfury = true; e.preventdefault = true; },,,
Strange Parcel_downgraded,Do [sword]<d6> damage. On 1[;] get|an item that won't take 6,2,if(!simulation) { for(eq in self.equipment) { eq.setvar(~alreadyheretemp~|1); } } attack(d); sfxdamage(target|d);  if(d == 1 && simulation) bonus(-9999999); if(d == 1 && !simulation) { sfx(~_thinghappens~); var slotblacklist = [~MIN2~|~MIN3~|~MIN4~|~MIN5~|~REQUIRE6~|~EVEN~|~NORMAL~|~COUNTDOWN~]; var descriptionblacklist = loadtext(~ncrmod/itemspawnerdescblacklist~); var scriptblacklist = [~self.equipment~|~new elements.Equipment~]; var checkblacklist = function(text|list) {  for(phrase in list) {   if(text.indexOf(phrase) != -1) {    return(false);   }  }  return(true); }; var not6eq = ~~; var exceptions = [~skillcard~|~excludefromrandomlists~|~alternateversion~|~robotonly~|~witchonly~|~inventoronly~|~onceperbattle~]; if(self.usecpuinsteadofdice) exceptions.remove(~robotonly~); if(self.getskillcard() != null && self.getskillcard().skillcard == ~witch~) exceptions.remove(~witchonly~); if(self.getskillcard() != null && self.getskillcard().skillcard == ~inventor~) exceptions.remove(~inventoronly~); var geteqs = getequipmentlist(null|[]|exceptions); geteqs = shuffle(geteqs); var placeholder = new elements.Equipment(~Loud Yelling~); var count = 0; while(not6eq == ~~) {  placeholder.create(geteqs[count]);  trace(placeholder.fulldescription); trace(placeholder.getslots());  var ds = placeholder.fulldescription;  var sc = placeholder.script;  var scbx = placeholder.scriptbeforeexecute;  if(   ((checkblacklist(placeholder.getslots()|slotblacklist) && !(placeholder.countdown > 0) && !(placeholder.hastag(~powercard~))) # (placeholder.needstotal <= 6 && placeholder.needstotal > 0)) &&   checkblacklist(ds|descriptionblacklist) &&   checkblacklist(sc|scriptblacklist) &&   checkblacklist(scbx|scriptblacklist)  ) {   not6eq = placeholder.name;  } /*else { geteqs.remove(placeholder.name); }*/ count++; trace(count); if(count >= geteqs.length) { placeholder.create(~Hyper Beam~); not6eq = ~Hyper Beam~; break; } } giveequipment(not6eq|true); for(eq in self.equipment) { if(eq.getvar(~alreadyheretemp~) != 1) { self.setvar(~doonthis~|eq); } } var estandardize = ~var e = self.getvar(\~doonthis\~); ~;var doscripts = new elements.Skill(~Against all odds_old~); doscripts.script = estandardize + placeholder.scriptbeforecombat; doscripts.execute(self|target); doscripts.script = estandardize + placeholder.scriptbeforestartturn; doscripts.execute(self|target); doscripts.script = estandardize + placeholder.scriptonstartturn; doscripts.execute(self|target); self.resetvar(~doonthis~); placeholder.name = ~deletemetemp~; self.equipment.push(placeholder); removeequipment(~deletemetemp~); } if(!simulation) { for(eq in self.equipment) { eq.resetvar(~alreadyheretemp~); } },Boltzmann Brain,NORMAL,,ORANGE,,,,none,,,,excludefromrandomlists,,if(!simulation) { for(eq in self.equipment) { eq.setvar(~alreadyheretemp~|1); } } if(d == 1 && simulation) bonus(-9999999); if(d == 1 && !simulation) { sfx(~_thinghappens~); var slotblacklist = [~MIN2~|~MIN3~|~MIN4~|~MIN5~|~REQUIRE6~|~EVEN~|~NORMAL~|~COUNTDOWN~]; var descriptionblacklist = [~next use~|~every use~|~each use~|~per use~]; var scriptblacklist = [~self.equipment~|~new elements.Equipment~]; var checkblacklist = function(text|list) {  for(phrase in list) {   if(text.indexOf(phrase) != -1) {    return(false);   }  }  return(true); }; var not6eq = ~~; var exceptions = [~skillcard~|~excludefromrandomlists~|~alternateversion~|~robotonly~|~witchonly~|~inventoronly~|~onceperbattle~]; if(self.usecpuinsteadofdice) exceptions.remove(~robotonly~); if(self.getskillcard() != null && self.getskillcard().skillcard == ~witch~) exceptions.remove(~witchonly~); if(self.getskillcard() != null && self.getskillcard().skillcard == ~inventor~) exceptions.remove(~inventoronly~); var geteqs = getequipmentlist(null|[]|exceptions); geteqs = shuffle(geteqs); var placeholder = new elements.Equipment(~Loud Yelling~); var count = 0; while(not6eq == ~~) {  placeholder.create(geteqs[count]);  trace(placeholder.fulldescription); trace(placeholder.getslots());  var ds = placeholder.fulldescription;  var sc = placeholder.script;  var scbx = placeholder.scriptbeforeexecute;  if(   ((checkblacklist(placeholder.getslots()|slotblacklist) && !(placeholder.countdown > 0) && !(placeholder.hastag(~powercard~)) # (placeholder.needstotal <= 6 && placeholder.needstotal > 0)) &&   checkblacklist(ds|descriptionblacklist) &&   checkblacklist(sc|scriptblacklist) &&   checkblacklist(scbx|scriptblacklist)  ) {   not6eq = placeholder.name;  } /*else { geteqs.remove(placeholder.name); }*/ count++; trace(count); if(count >= geteqs.length) { placeholder.create(~Hyper Beam~); not6eq = ~Hyper Beam~; break; } } giveequipment(not6eq|true); for(eq in self.equipment) { if(eq.getvar(~alreadyheretemp~) != 1) { self.setvar(~doonthis~|eq); } } var estandardize = ~var e = self.getvar(\~doonthis\~); ~;var doscripts = new elements.Skill(~Against all odds_old~); doscripts.script = estandardize + placeholder.scriptbeforecombat; doscripts.execute(self|target); doscripts.script = estandardize + placeholder.scriptbeforestartturn; doscripts.execute(self|target); doscripts.script = estandardize + placeholder.scriptonstartturn; doscripts.execute(self|target); self.resetvar(~doonthis~); placeholder.name = ~deletemetemp~; self.equipment.push(placeholder); removeequipment(~deletemetemp~); } if(!simulation) { for(eq in self.equipment) { eq.resetvar(~alreadyheretemp~); } },,,,,,,if(d == 1) { e.maintainfury = true; e.preventdefault = true; },,,
Iced Latte?,Self inflict [ice]1 freeze|(Always offered as scrap),1,,Flash Freeze,,,GRAY,change_power,change_power,,none,0,NO,NO,excludefromrandomlists|appearsforparts|alternateversion,,,,,,e.animate(~flashandshake~); inflictself(ICE|1); for(mydice in self.dicepool) { if(mydice.available() && mydice.burn != true && mydice.alternateburn != true) { mydice.animate(~alternate_ice~); } } if(self.status.length > 0) { for(stat in self.status) { if(stat.type == inflictwhat) { stat.value -= 1; } } },,,,,,
Iced Latte?_upgraded,Roll an extra dice[;] get [ice]1|(Always offered as scrap),1,,Flash Freeze,,,GRAY,,,,none,0,NO,NO,excludefromrandomlists|appearsforparts|alternateversion,,,,,,e.animate(~flashandshake~); givedice(); e.animate(~flashandshake~); inflictself(ICE|1); for(mydice in self.dicepool) { if(mydice.available() && mydice.burn != true && mydice.alternateburn != true) { mydice.animate(~alternate_ice~); } } if(self.status.length > 0) { for(stat in self.status) { if(stat.type == inflictwhat) { stat.value -= 1; } } },,,,,,
Iced Latte?_downgraded,Self inflict [ice]2 freeze|(Always offered as scrap),1,,Flash Freeze,,,GRAY,,,,none,0,NO,NO,excludefromrandomlists|appearsforparts|alternateversion,,,,,,e.animate(~flashandshake~); inflictself(ICE|2); for(mydice in self.dicepool) { if(mydice.available() && mydice.burn != true && mydice.alternateburn != true) { mydice.animate(~alternate_ice~); mydice.animate(~alternate_ice~|0.2); } } if(self.status.length > 0) { for(stat in self.status) { if(stat.type == inflictwhat) { stat.value -= 2; } } },,,,,,
Cheap Shot,Do [sword]<d6> damage[;] on 3|or lower[;] return the dice,2,attack(d); sfxdamage(target|d); if(actualdice[0].basevalue < 4) givedice(actualdice[0].basevalue); /*too much like quarterstaff*/,Super Hexahedron,NORMAL,,RED,change_power,change_power,,none,0,NO,NO,,,if(actualdice[0].basevalue < 4) givedice(actualdice[0].basevalue);,,,,,,,,,,
Cheap Shot_downgraded,Do [sword]<d6> damage[;] on 3|or lower[;] set a dice to <d6>,2,attack(d); sfxdamage(target|d); if(actualdice[0].basevalue < 4) {var dicelist = []; for (mydice in self.dicepool){ if (mydice.available() && mydice.basevalue != actualdice[0].basevalue){ dicelist.push(mydice); } } if(dicelist.length > 0) { shuffle(dicelist); dicelist[0].animatereroll(actualdice[0].basevalue| self.screenposition()); } },Super Hexahedron,NORMAL,,RED,,,,none,0,NO,NO,,,if(actualdice[0].basevalue < 4) {var dicelist = []; for (mydice in self.dicepool){ if (mydice.available() && mydice.basevalue != actualdice[0].basevalue){ dicelist.push(mydice); } } if(dicelist.length > 0) { shuffle(dicelist); dicelist[0].animatereroll(actualdice[0].basevalue| self.screenposition()); } },,,,,,,,,,
Cheap Shot_upgraded,Do [sword]<d6> damage[;]|on odd[;] return the dice,2,attack(d); sfxdamage(target|d); if(actualdice[0].basevalue % 2 == 1) givedice(actualdice[0].basevalue);,Super Hexahedron,NORMAL,,RED,,,,none,0,NO,NO,,,if(actualdice[0].basevalue % 2 == 1) givedice(actualdice[0].basevalue);,,,,,,,,,,
Glue Gun,[lock]Counter a random dice|that's not countered yet|,1,var availablecounters = [1|2|3|4|5|6]; for(num in availablecounters) { if(getstatus(~counter_~ + num) > 0) { availablecounters.remove(num); } } if(availablecounters.length == 0) { self.textparticle(~No effect!~); } else { inflict(~counter_~ + rand(availablecounters)); sfx(~_lock~); },Confiscate,COUNTDOWN,6,PURPLE,change_power,change_power,,none,3,,,,,,,,,,,,,,,
Glue Gun_upgraded,[lock]Counter a random dice|that's not countered yet|,1,var availablecounters = [1|2|3|4|5|6]; for(num in availablecounters) { if(getstatus(~counter_~ + num) > 0) { availablecounters.remove(num); } } if(availablecounters.length == 0) { self.textparticle(~No effect!~); } else { inflict(~counter_~ + rand(availablecounters)); sfx(~_lock~); },Confiscate,COUNTDOWN,6,PURPLE,,,,none,6,,,,,,,,,,,,,,,
Glue Gun_downgraded,[lock]Counter a random dice|that's not countered yet|,1,var availablecounters = [1|2|3|4|5|6]; for(num in availablecounters) { if(getstatus(~counter_~ + num) > 0) { availablecounters.remove(num); } } if(availablecounters.length == 0) { self.textparticle(~No effect!~); } else { inflict(~counter_~ + rand(availablecounters)); sfx(~_lock~); },Confiscate,COUNTDOWN,6,PURPLE,,,,none,2,,,,,,,,,,,,,,,
Two Handed Spatula,Flip both dice upside down,2,givedice([7 - actualdice[0].basevalue|7 - actualdice[1].basevalue]); ,Omegaflip,NORMAL|NORMAL,,GREEN,change_power,change_power,,none,0,YES,,,,,,,,,,,,,,
Two Handed Spatula_downgraded,Flip both dice upside down,2,givedice([7 - actualdice[0].basevalue|7 - actualdice[1].basevalue]); ,Omegaflip,MAX3|MIN4,,GREEN,,,,none,0,YES,,,,,,,,,,,,,,
Two Handed Spatula_upgraded,Flip both dice upside down|,2,givedice([7 - actualdice[0].basevalue|7 - actualdice[1].basevalue]); ,Omegaflip,NORMAL|NORMAL,,GREEN,,,,none,2,YES,,,,,,,,,,,,,,
Penultima Weapon,Do [sword]<d6>. At 1 point below|jackpot[;] do [sword]<triple> and bust,1,if (self.roll_total == self.roll_target - 1) { attack(d * 3); sfxdamage(target|d * 3); adjustrobotcounter((self.roll_target - self.roll_total) + 1); } else { attack(d); sfxdamage(target|d); },Underwhelm,MAX5,,ORANGE,change_power,change_power,,none,0,,,robotonly|excludefromrandomlists,,,,,,,,,,,,
Penultima Weapon_upgraded,Do [sword]<d6>. 1 point below|jackpot[;] [sword]<triple> and bust,1,if (self.roll_total == self.roll_target - 1) { attack(d * 3); sfxdamage(target|d * 3); adjustrobotcounter((self.roll_target - self.roll_total) + 1); } else { attack(d); sfxdamage(target|d); },Underwhelm,MAX5|FREE1,,ORANGE,,,,none,0,,,robotonly|excludefromrandomlists,,,,,,,,,,,,
Penultima Weapon_downgraded,Do [sword]<d6>. At 1 point below|jackpot[;] do [sword]<double> and bust,1,if (self.roll_total == self.roll_target - 1) { attack(d * 2); sfxdamage(target|d * 2); adjustrobotcounter((self.roll_target - self.roll_total) + 1); } else { attack(d); sfxdamage(target|d); },Underwhelm,MAX5,,ORANGE,,,,none,0,,,robotonly|excludefromrandomlists,,,,,,,,,,,,
Global Thermonuclear War,After used[;] everyone gets|[fire]Burn_all every turn|[gray](once per battle),1,inflict(~ncr_lingeringburn~); inflictself(~ncr_lingeringburn~);,Heat Ray,EVEN,,RED,simplify,doublerequirements,,_fire,0,,YES,,,inflictself(~ncr_lingeringburn~);,,,,,,,,,,
Nuclear Winter,After used[;] everyone gets|[ice]Freeze_all every turn|[gray](once per battle),1,inflict(~ncr_lingeringfreeze~); inflictself(~ncr_lingeringfreeze~);,Arctic Storm,EVEN,,CYAN,simplify,doublerequirements,,_ice,0,,YES,,,inflictself(~ncr_lingeringfreeze~);,,,,,,,,,,
Rapture,After used[;] everyone gets|[vanish]Vanish_all every turn|[gray](once per battle),1,inflict(~ncr_lingeringvanish~); inflictself(~ncr_lingeringvanish~);,Mass Deception,EVEN,,PINK,simplify,doublerequirements,,_vanish,0,,YES,,,inflictself(~ncr_lingeringvanish~);,,,,,,,,,,
Frayed Wire,Do [shock]<d6> dmg. If CPU is <double>|or more[;] reduce it by <d6>,1,attack(d|SHOCK); sfxdamage(target|d); sfx(~_shock~|~~|0.2); if(self.roll_total >= d * 2 && self.roll_jackpot == 0) { adjustrobotcounter(-d); },Discharge,NORMAL,,YELLOW,change_power,change_power,,none,0,,,robotonly,,if(self.roll_total >= d * 2 && self.roll_jackpot == 0) { adjustrobotcounter(-d); },,,,,,,,,,
Frayed Wire_upgraded,Do [shock]<d6> dmg. If CPU is <d6> + 3|or more[;] reduce it by <d6>,1,attack(d|SHOCK); sfxdamage(target|d); sfx(~_shock~|~~|0.2); if(self.roll_total >= (d + 3) && self.roll_jackpot == 0) { adjustrobotcounter(-d); },Discharge,NORMAL,,YELLOW,,,,none,0,,,robotonly,,if(self.roll_total >= d * 2 && self.roll_jackpot == 0) { adjustrobotcounter(-d); },,,,,,,,,,
Frayed Wire_downgraded,Do [shock]<d6> dmg. If CPU is <double>|exactly[;] reduce it by <d6>,1,attack(d|SHOCK); sfxdamage(target|d); sfx(~_shock~|~~|0.2); if(self.roll_total == d * 2 && self.roll_jackpot == 0) { adjustrobotcounter(-d); },Discharge,NORMAL,,YELLOW,,,,none,0,,,robotonly,,if(self.roll_total == d * 2 && self.roll_jackpot == 0) { adjustrobotcounter(-d); },,,,,,,,,,
Foobar,Reduce all countdowns|by unused CPU (<var:cpuleft>),1,var boosttotal = self.roll_target - self.roll_total; while(boosttotal > 6) { boostcountdowns(6); boosttotal -= 6; } if(self.roll_target - self.roll_total == 0) { self.textparticle(~No effect!~); } else { boostcountdowns(boosttotal); } /*trickyy; i want this to act like you inserted a nonstandard potentially-above-6 dice for every countdown except those that are actually expected to return the dice*/,Turbo Boost,EVEN|EVEN,,GREEN,change_power,change_power,,none,0,,,robotonly,,,,,self.setvar(~cpuleft~|self.roll_target - self.roll_total);,self.setvar(~cpuleft~|self.roll_target - self.roll_total);,,self.setvar(~cpuleft~|self.roll_target - self.roll_total);,,,,
Foobar_upgraded,Reduce all countdowns|by unused CPU (<var:cpuleft>),1,var boosttotal = self.roll_target - self.roll_total; while(boosttotal > 6) { boostcountdowns(6); boosttotal -= 6; } if(self.roll_target - self.roll_total == 0) { self.textparticle(~No effect!~); } else { boostcountdowns(boosttotal); } /*trickyy; i want this to act like you inserted a nonstandard potentially-above-6 dice for every countdown except those that are actually expected to return the dice*/,Turbo Boost,MAX3|MAX3,,GREEN,,,,none,0,,,robotonly,,,,,self.setvar(~cpuleft~|self.roll_target - self.roll_total);,self.setvar(~cpuleft~|self.roll_target - self.roll_total);,,self.setvar(~cpuleft~|self.roll_target - self.roll_total);,,,,
Foobar_downgraded,Reduce all countdowns|by unused CPU (<var:cpuleft>),1,var boosttotal = self.roll_target - self.roll_total; while(boosttotal > 6) { boostcountdowns(6); boosttotal -= 6; } if(self.roll_target - self.roll_total == 0) { self.textparticle(~No effect!~); } else { boostcountdowns(boosttotal); } /*trickyy; i want this to act like you inserted a nonstandard potentially-above-6 dice for every countdown except those that are actually expected to return the dice*/,Turbo Boost,EVEN|EVEN,8,GREEN,,,,none,0,,,robotonly,,,,,self.setvar(~cpuleft~|self.roll_target - self.roll_total);,self.setvar(~cpuleft~|self.roll_target - self.roll_total);,,self.setvar(~cpuleft~|self.roll_target - self.roll_total);,,,,
Disk Eject,Do [sword]4 damage[;]|reduce CPU by excess,1,var myname = ~dicehistorytemp~ + self.getvar(~fixedeqlist~).indexOf(e); trace(~----~); trace(e.dicehistory.length); trace(e.dicehistory); trace(self.getvar(myname)); trace(self.getvar(myname).length); trace(~----~); if((e.dicehistory.length < 1) && self.getvar(myname).length >= e.dicehistory.length && self.getvar(myname).length != null) { trace(~thingdoing!~); e.dicehistory = self.getvar(myname).concat(e.dicehistory); } self.setvar(myname|e.dicehistory.copy()); attack(4); sfxdamage(target|4); var sum = 0; var i = 0; while(true) {  if(i > e.dicehistory.length - 1) { trace(~UHHHHHH~); break; }  sum = sum + e.dicehistory[i].basevalue;  trace(sum); trace(~i: ~ + i); i++;  if(sum >= e.countdown) break; } trace(~SPAM~); trace(sum); if (sum - e.countdown > 0) {  adjustrobotcounter(-(sum - e.countdown)); } else donothing(); /*self.textparticle(~No effect!~);*/ if(self.getvar(~furying~) < 1) { trace(~resetting!~); e.dicehistory = []; self.resetvar(myname); } self.setvar(~furying~|self.getvar(~furying~) - 1);,Shuriken,COUNTDOWN,6,GRAY,change_power,change_power,,none,0,,,robotonly|cannotreuse,,var myname = ~dicehistorytemp~ + self.getvar(~fixedeqlist~).indexOf(e); trace(~----~); trace(e.dicehistory.length); trace(e.dicehistory); trace(self.getvar(myname)); trace(self.getvar(myname).length); trace(~----~); if((e.dicehistory.length < 1) && self.getvar(myname).length >= e.dicehistory.length && self.getvar(myname).length != null) { trace(~thingdoing!~); e.dicehistory = self.getvar(myname).concat(e.dicehistory); } self.setvar(myname|e.dicehistory.copy()); var sum = 0; var i = 0; while(true) {  if(i > e.dicehistory.length - 1) { trace(~UHHHHHH~); break; }  sum = sum + e.dicehistory[i].basevalue;  trace(sum); trace(~i: ~ + i); i++;  if(sum >= e.countdown) break; } trace(~SPAM~); trace(sum); if (sum - e.countdown > 0) {  adjustrobotcounter(-(sum - e.countdown)); } else donothing(); /*self.textparticle(~No effect!~);*/ if(self.getvar(~furying~) < 1) { trace(~resetting!~); e.dicehistory = []; self.resetvar(myname); } self.setvar(~furying~|self.getvar(~furying~) - 1);,var myfixedeqlist = self.getvar(~fixedeqlist~); if(myfixedeqlist.length > 0) { var myname = ~dicehistorytemp~ + myfixedeqlist.indexOf(e); self.resetvar(myname); } self.resetvar(~fixedeqlist~); self.setvar(~fixedeqlist~|self.equipment.copy());,var myfixedeqlist = self.getvar(~fixedeqlist~); if(myfixedeqlist.length > 0) { var myname = ~dicehistorytemp~ + myfixedeqlist.indexOf(e); self.resetvar(myname); } self.resetvar(~fixedeqlist~); ,if(e.timesused > 0) { var myname = ~dicehistorytemp~ + self.getvar(~fixedeqlist~).indexOf(e); e.dicehistory = []; self.resetvar(myname); } e.timesused = 0; /*kludge if this card gets cursed or is dodged*/,trace(~here's me:~); trace(self.getvar(~fixedeqlist~).indexOf(e));,,,,,self.setvar(~furying~|getstatusself(FURY)); trace(~fury!: ~ + self.getvar(~furying~));,trace(~here's me:~); trace(self.getvar(~fixedeqlist~).indexOf(e)); var myname = ~dicehistorytemp~ + self.getvar(~fixedeqlist~).indexOf(e); trace(e.dicehistory.length); trace(e.dicehistory); trace(self.getvar(myname)); trace(self.getvar(myname).length); if((e.dicehistory.length == 1) && self.getvar(myname).length >= e.dicehistory.length && self.getvar(myname).length != null) { trace(~thingdoing!~); e.dicehistory = self.getvar(myname).concat(e.dicehistory); } self.setvar(myname|e.dicehistory.copy());
Disk Eject_upgraded,Do [sword]4 damage[;]|reduce CPU by excess + 1,1,var myname = ~dicehistorytemp~ + self.getvar(~fixedeqlist~).indexOf(e); trace(~----~); trace(e.dicehistory.length); trace(e.dicehistory); trace(self.getvar(myname)); trace(self.getvar(myname).length); trace(~----~); if((e.dicehistory.length < 1) && self.getvar(myname).length >= e.dicehistory.length && self.getvar(myname).length != null) { trace(~thingdoing!~); e.dicehistory = self.getvar(myname).concat(e.dicehistory); } self.setvar(myname|e.dicehistory.copy()); attack(4); sfxdamage(target|4); var sum = 0; var i = 0; while(true) {  if(i > e.dicehistory.length - 1) { trace(~UHHHHHH~); break; }  sum = sum + e.dicehistory[i].basevalue;  trace(sum); trace(~i: ~ + i); i++;  if(sum >= e.countdown) break; } trace(~SPAM~); trace(sum); if (sum - e.countdown > -1) {  adjustrobotcounter(-(sum - e.countdown) - 1); } else donothing(); /*self.textparticle(~No effect!~);*/ if(self.getvar(~furying~) < 1) { trace(~resetting!~); e.dicehistory = []; self.resetvar(myname); } self.setvar(~furying~|self.getvar(~furying~) - 1);,Shuriken,COUNTDOWN,6,GRAY,,,,none,0,,,robotonly|cannotreuse,,var myname = ~dicehistorytemp~ + self.getvar(~fixedeqlist~).indexOf(e); trace(~----~); trace(e.dicehistory.length); trace(e.dicehistory); trace(self.getvar(myname)); trace(self.getvar(myname).length); trace(~----~); if((e.dicehistory.length < 1) && self.getvar(myname).length >= e.dicehistory.length && self.getvar(myname).length != null) { trace(~thingdoing!~); e.dicehistory = self.getvar(myname).concat(e.dicehistory); } self.setvar(myname|e.dicehistory.copy()); var sum = 0; var i = 0; while(true) {  if(i > e.dicehistory.length - 1) { trace(~UHHHHHH~); break; }  sum = sum + e.dicehistory[i].basevalue;  trace(sum); trace(~i: ~ + i); i++;  if(sum >= e.countdown) break; } trace(~SPAM~); trace(sum); if (sum - e.countdown > -1) {  adjustrobotcounter(-(sum - e.countdown) - 1); } else donothing(); /*self.textparticle(~No effect!~);*/ if(self.getvar(~furying~) < 1) { trace(~resetting!~); e.dicehistory = []; self.resetvar(myname); } self.setvar(~furying~|self.getvar(~furying~) - 1);,var myfixedeqlist = self.getvar(~fixedeqlist~); if(myfixedeqlist.length > 0) { var myname = ~dicehistorytemp~ + myfixedeqlist.indexOf(e); self.resetvar(myname); } self.resetvar(~fixedeqlist~); self.setvar(~fixedeqlist~|self.equipment.copy());,var myfixedeqlist = self.getvar(~fixedeqlist~); if(myfixedeqlist.length > 0) { var myname = ~dicehistorytemp~ + myfixedeqlist.indexOf(e); self.resetvar(myname); } self.resetvar(~fixedeqlist~); ,if(e.timesused > 0) { var myname = ~dicehistorytemp~ + self.getvar(~fixedeqlist~).indexOf(e); e.dicehistory = []; self.resetvar(myname); } e.timesused = 0; /*kludge if this card gets cursed or is dodged*/,trace(~here's me:~); trace(self.getvar(~fixedeqlist~).indexOf(e));,,,,,self.setvar(~furying~|getstatusself(FURY)); trace(~fury!: ~ + self.getvar(~furying~));,trace(~here's me:~); trace(self.getvar(~fixedeqlist~).indexOf(e)); var myname = ~dicehistorytemp~ + self.getvar(~fixedeqlist~).indexOf(e); trace(e.dicehistory.length); trace(e.dicehistory); trace(self.getvar(myname)); trace(self.getvar(myname).length); if((e.dicehistory.length == 1) && self.getvar(myname).length >= e.dicehistory.length && self.getvar(myname).length != null) { trace(~thingdoing!~); e.dicehistory = self.getvar(myname).concat(e.dicehistory); } self.setvar(myname|e.dicehistory.copy());
Disk Eject_downgraded,Do [sword]2 damage[;]|reduce CPU by excess,1,var myname = ~dicehistorytemp~ + self.getvar(~fixedeqlist~).indexOf(e); trace(~----~); trace(e.dicehistory.length); trace(e.dicehistory); trace(self.getvar(myname)); trace(self.getvar(myname).length); trace(~----~); if((e.dicehistory.length < 1) && self.getvar(myname).length >= e.dicehistory.length && self.getvar(myname).length != null) { trace(~thingdoing!~); e.dicehistory = self.getvar(myname).concat(e.dicehistory); } self.setvar(myname|e.dicehistory.copy()); attack(4); sfxdamage(target|4); var sum = 0; var i = 0; while(true) {  if(i > e.dicehistory.length - 1) { trace(~UHHHHHH~); break; }  sum = sum + e.dicehistory[i].basevalue;  trace(sum); trace(~i: ~ + i); i++;  if(sum >= e.countdown) break; } trace(~SPAM~); trace(sum); if (sum - e.countdown > 0) {  adjustrobotcounter(-(sum - e.countdown)); } else donothing(); /*self.textparticle(~No effect!~);*/ if(self.getvar(~furying~) < 1) { trace(~resetting!~); e.dicehistory = []; self.resetvar(myname); } self.setvar(~furying~|self.getvar(~furying~) - 1);,Shuriken,COUNTDOWN,6,GRAY,,,,none,0,,,robotonly|cannotreuse,,var myname = ~dicehistorytemp~ + self.getvar(~fixedeqlist~).indexOf(e); trace(~----~); trace(e.dicehistory.length); trace(e.dicehistory); trace(self.getvar(myname)); trace(self.getvar(myname).length); trace(~----~); if((e.dicehistory.length < 1) && self.getvar(myname).length >= e.dicehistory.length && self.getvar(myname).length != null) { trace(~thingdoing!~); e.dicehistory = self.getvar(myname).concat(e.dicehistory); } self.setvar(myname|e.dicehistory.copy()); var sum = 0; var i = 0; while(true) {  if(i > e.dicehistory.length - 1) { trace(~UHHHHHH~); break; }  sum = sum + e.dicehistory[i].basevalue;  trace(sum); trace(~i: ~ + i); i++;  if(sum >= e.countdown) break; } trace(~SPAM~); trace(sum); if (sum - e.countdown > 0) {  adjustrobotcounter(-(sum - e.countdown)); } else donothing(); /*self.textparticle(~No effect!~);*/ if(self.getvar(~furying~) < 1) { trace(~resetting!~); e.dicehistory = []; self.resetvar(myname); } self.setvar(~furying~|self.getvar(~furying~) - 1);,var myfixedeqlist = self.getvar(~fixedeqlist~); if(myfixedeqlist.length > 0) { var myname = ~dicehistorytemp~ + myfixedeqlist.indexOf(e); self.resetvar(myname); } self.resetvar(~fixedeqlist~); self.setvar(~fixedeqlist~|self.equipment.copy());,var myfixedeqlist = self.getvar(~fixedeqlist~); if(myfixedeqlist.length > 0) { var myname = ~dicehistorytemp~ + myfixedeqlist.indexOf(e); self.resetvar(myname); } self.resetvar(~fixedeqlist~); ,if(e.timesused > 0) { var myname = ~dicehistorytemp~ + self.getvar(~fixedeqlist~).indexOf(e); e.dicehistory = []; self.resetvar(myname); } e.timesused = 0; /*kludge if this card gets cursed or is dodged*/,trace(~here's me:~); trace(self.getvar(~fixedeqlist~).indexOf(e));,,,,,self.setvar(~furying~|getstatusself(FURY)); trace(~fury!: ~ + self.getvar(~furying~));,trace(~here's me:~); trace(self.getvar(~fixedeqlist~).indexOf(e)); var myname = ~dicehistorytemp~ + self.getvar(~fixedeqlist~).indexOf(e); trace(e.dicehistory.length); trace(e.dicehistory); trace(self.getvar(myname)); trace(self.getvar(myname).length); if((e.dicehistory.length == 1) && self.getvar(myname).length >= e.dicehistory.length && self.getvar(myname).length != null) { trace(~thingdoing!~); e.dicehistory = self.getvar(myname).concat(e.dicehistory); } self.setvar(myname|e.dicehistory.copy());
Decimate,If CPU is exactly 10[;]|do [sword]<double> damage,1,if(self.roll_total == 10) { attack(d * 2); sfxdamage(target|d); } else { self.textparticle(~No effect!~); },Turbo Boost,NORMAL,,RED,change_power,change_power,,none,0,,,robotonly,,,,,,,,,,,,
Decimate_upgraded,If CPU is exactly <double>[;]|do [sword]<double> damage,1,if(self.roll_total == d * 2) { attack(d * 2); sfxdamage(target|d); } else { self.textparticle(~No effect!~); },Turbo Boost,NORMAL,,RED,,,,none,0,,,robotonly,,,,,,,,,,,,
Decimate_downgraded,If CPU is exactly 10[;]|do [sword]<double> damage,1,if(self.roll_total == 10) { attack(d * 2); sfxdamage(target|d); } else { self.textparticle(~No effect!~); },Turbo Boost,REQUIRE5,,RED,,,,none,0,,,robotonly,,,,,,,,,,,,
Grapple,Lock [lock]1 dice|,1,inflict(LOCK); /*bad handcuffs variant*/,Confiscate,EVEN|EVEN,,PURPLE,change_power,complicate,,_lock,-1,,,,,,,,,,,,,,,
Grapple_upgraded,Lock [lock]1 dice|,1,inflict(LOCK);,Confiscate,MIN2|MIN2,,PURPLE,,,,_lock,-1,,,,,,,,,,,,,,,
Handcuffs,Lock all your dice[;] inflict|[lock]1 per two dice locked,1,var lockisalt = false; var dummyfighter = new elements.Fighter(~Wisp~); dummyfighter.addstatus(~lock~|1); trace(dummyfighter.status.length); if(dummyfighter.status.length > 0) { for(stat in dummyfighter.status) { if(stat.type == ~alternate_lock~) { lockisalt = true; } } } if(lockisalt) { var lockcount = 0; for(mydice in self.dicepool) { if(mydice.available()) {  mydice.animate(~alternate_lock~); lockcount++; } } for(eq in self.equipment) { if(eq.ready && eq.assigneddice.length > 0) { for(mydice in eq.assigneddice) { if(mydice != null && !mydice.locked) {  eq.removedice(mydice); mydice.animate(~alternate_lock~); mydice.kick(90|20); lockcount++; } } } } if(lockcount > 0) { inflictself(~alternate_lock~|lockcount); if(lockcount % 2 == 1) lockcount--; if(lockcount > 0) { inflict(LOCK|(lockcount / 2)); } else { self.textparticle(~No effect!~); } } else { self.textparticle(~No effect!~); } } else { var lockcount = 0; var c = 0; var cc = 0; for(mydice in self.dicepool) { if(mydice.available()) { mydice.animate(~lock~|c); lockcount++; c += 0.1; } } for(eq in self.equipment) { if(eq.ready && eq.assigneddice.length > 0) { for(mydice in eq.assigneddice) { if(mydice != null && !mydice.locked) {  eq.removedice(mydice); mydice.animate(~lock~|cc); mydice.kick(90|20); lockcount++; cc += 0.1; } } } } if(lockcount % 2 == 1) lockcount--; if(lockcount > 0) { inflict(LOCK|(lockcount / 2)); } else { self.textparticle(~No effect!~); } },Plexiglass,EVEN,,PURPLE,change_power,change_power,,_lock,0,,,,1,,,,,,,,,,,
Handcuffs_upgraded,Lock your other dice[;] [lock]1|per 2 locked[;] return this dice,1,var lockisalt = false; var dummyfighter = new elements.Fighter(~Wisp~); dummyfighter.addstatus(~lock~|1); trace(dummyfighter.status.length); if(dummyfighter.status.length > 0) { for(stat in dummyfighter.status) { if(stat.type == ~alternate_lock~) { lockisalt = true; } } } if(lockisalt) { var lockcount = 0; for(mydice in self.dicepool) { if(mydice.available()) {  mydice.animate(~alternate_lock~); lockcount++; } } for(eq in self.equipment) { if(eq.ready && eq.assigneddice.length > 0) { for(mydice in eq.assigneddice) { if(mydice != null && !mydice.locked) {  eq.removedice(mydice);  mydice.animate(~alternate_lock~); mydice.kick(90|20); lockcount++; } } } } if(lockcount > 0) { inflictself(~alternate_lock~|lockcount); if(lockcount % 2 == 1) lockcount--; if(lockcount > 0) { inflict(LOCK|(lockcount / 2)); } else { self.textparticle(~No effect!~); } } else { self.textparticle(~No effect!~); } } else { var lockcount = 0; var c = 0; var cc = 0; for(mydice in self.dicepool) { if(mydice.available()) { mydice.animate(~lock~|c); lockcount++; c += 0.1; } } for(eq in self.equipment) { if(eq.ready && eq.assigneddice.length > 0) { for(mydice in eq.assigneddice) { if(mydice != null && !mydice.locked) {  eq.removedice(mydice); mydice.animate(~lock~|cc); mydice.kick(90|20); lockcount++; cc += 0.1; } } } } if(lockcount % 2 == 1) lockcount--; if(lockcount > 0) { inflict(LOCK|(lockcount / 2)); } else { self.textparticle(~No effect!~); } } givedice(d);,Plexiglass,EVEN,,PURPLE,,,,_lock,0,,,,,,,,,,,,,,,
Handcuffs_downgraded,Lock all your dice[;] inflict|[lock]2 per four dice locked,1,var lockisalt = false; var dummyfighter = new elements.Fighter(~Wisp~); dummyfighter.addstatus(~lock~|1); trace(dummyfighter.status.length); if(dummyfighter.status.length > 0) { for(stat in dummyfighter.status) { if(stat.type == ~alternate_lock~) { lockisalt = true; } } } if(lockisalt) { var lockcount = 0; for(mydice in self.dicepool) { if(mydice.available()) {  mydice.animate(~alternate_lock~); lockcount++; } } for(eq in self.equipment) { if(eq.ready && eq.assigneddice.length > 0) { for(mydice in eq.assigneddice) { if(mydice != null && !mydice.locked) {  eq.removedice(mydice);  mydice.animate(~alternate_lock~); mydice.kick(90|20); lockcount++; } } } } if(lockcount > 0) { inflictself(~alternate_lock~|lockcount); if(lockcount % 4 != 0) lockcount-= lockcount % 4; if(lockcount > 0) { inflict(LOCK|(lockcount / 2)); } else { self.textparticle(~No effect!~); } } else { self.textparticle(~No effect!~); } } else { var lockcount = 0; var c = 0; var cc = 0; for(mydice in self.dicepool) { if(mydice.available()) { mydice.animate(~lock~|c); lockcount++; c += 0.1; } } for(eq in self.equipment) { if(eq.ready && eq.assigneddice.length > 0) { for(mydice in eq.assigneddice) { if(mydice != null && !mydice.locked) {  eq.removedice(mydice); mydice.animate(~lock~|cc); mydice.kick(90|20); lockcount++; cc += 0.1; } } } } if(lockcount % 4 != 0) lockcount-= lockcount % 4; if(lockcount > 0) { inflict(LOCK|(lockcount / 2)); } else { self.textparticle(~No effect!~); } } givedice(d);,Plexiglass,EVEN,,PURPLE,,,,_lock,0,,,,,,,,,,,,,,,
Sharpened Rosary,Do [sword]<d6> damage. On 1[;]|gain a random blessing,2,attack(d); if(d == 1) {  var randomstatus = SHIELD; if(getstatusself(FURY) == 0) { randomstatus = rand([SHIELD|FURY|REDUCE|REEQUIPNEXT|DODGE]); }else { randomstatus = rand([SHIELD|REDUCE|REEQUIPNEXT|DODGE]); } var a = 1; if (randomstatus == SHIELD) a = 4; if (randomstatus == REDUCE) a = 2; inflictself(randomstatus | a); if(randomstatus == REDUCE) randomstatus = SHIELD; if(randomstatus == REEQUIPNEXT) randomstatus = ~reduce~; sfx(~_~ + randomstatus.toLowerCase()|~~|0.2); },Trinity,ODD,,PURPLE,simplify,change_power,,_damage,0,,,,,,,,,,,,,,,
Sharpened Rosary_downgraded,Do [sword]<d6> damage. On 1[;]|gain a random blessing,2,attack(d); if(d == 1) {  var randomstatus = SHIELD; if(getstatusself(FURY) == 0) { randomstatus = rand([SHIELD|FURY|REDUCE|REEQUIPNEXT|DODGE]); }else { randomstatus = rand([SHIELD|REDUCE|REEQUIPNEXT|DODGE]); } var a = 1; if (randomstatus == SHIELD) a = 4; if (randomstatus == REDUCE) a = 2; inflictself(randomstatus | a); if(randomstatus == REDUCE) randomstatus = SHIELD; if(randomstatus == REEQUIPNEXT) randomstatus = ~reduce~; sfx(~_~ + randomstatus.toLowerCase()|~~|0.2); },Trinity,REQUIRE1,,PURPLE,,,,_damage,0,,,,,,,,,,,,,,,
Bop Bop,Do [sword]3 damage. On 6[;]|drain [heart]2 health instead,2,if(d == 6) { drain(2); sfx(~_drain~); } else { attack(3); sfxdamage(target|3); } /*originally 'on snap; drain 2 health instead' but you will not believe how difficult it is to *replace* the effect of a card on snap rather than adding to it: https://github.com/TerryCavanagh/diceydungeons.com/issues/1889*/,Rejuvenate,MIN3,,PINK,change_power,change_power,,none,0,,,,,,,,,,,,,,,
Bop Bop_upgraded,Do [sword]3 damage. On 6[;]|drain [heart]3 health instead,2,if(d == 6) { drain(3); sfx(~_drain~); } else { attack(3); sfxdamage(target|3); },Rejuvenate,MIN3,,PINK,,,,none,0,,,,,,,,,,,,,,,
Bop Bop_downgraded,Do [sword]3 damage. On 6[;]|heal [heart]2 health instead,2,if(d == 6) { attackself(-2); sfx(~_heal~); } else { attack(3); sfxdamage(target|3); },Rejuvenate,MIN3,,PINK,,,,none,0,,,,,if(d == 6) { attackself(-2); sfx(~_heal~); },,,,,,,if(d == 6) { e.castdirection = -1; } else { e.castdirection = 1; },,,
Zoop Zoop,Do [sword]<d6> damage|[sword]3 less if above 3,2,attack(d > 3 ? d - 3 : d); sfxdamage(target|d > 3 ? d - 3 : d);,Underwhelm,NORMAL,,PURPLE,change_power,change_power,,none,0,,,,1,,,,,,,,,,,
Zoop Zoop_upgraded,Do [sword]<d6> damage|[sword]2 less if above 2,2,attack(d > 2 ? d - 2 : d); sfxdamage(target|d > 2 ? d - 2 : d);,Underwhelm,NORMAL,,PURPLE,,,,none,0,,,,,,,,,,,,,,,
Zoop Zoop_downgraded,Do [sword]<d6> damage|[sword]3 less if above 3,2,attack(d > 3 ? d - 3 : d); sfxdamage(target|d > 3 ? d - 3 : d);,Underwhelm,MAX4,,PURPLE,,,,none,0,,,,,,,,,,,,,,,
Veneer,Charge limit break by [confuse]2,1,sfx(~_cure~); if(self.limitvalue != null && self.limitmax != null) { self.limitvalue += 2; if(self.limitvalue > self.limitmax) { self.limitvalue = self.limitmax; } },Magic Six,NORMAL,,ORANGE,change_power,change_power,,none,0,YES,,,,,,,,,,,,,,
Veneer_upgraded,Charge limit break by [confuse]3,1,sfx(~_cure~); if(self.limitvalue != null && self.limitmax != null) { self.limitvalue += 3; if(self.limitvalue > self.limitmax) { self.limitvalue = self.limitmax; } },Magic Six,NORMAL,,ORANGE,,,,none,0,YES,,,,,,,,,,,,,,
Veneer_downgraded,Charge limit break by [confuse]1,1,sfx(~_cure~); if(self.limitvalue != null && self.limitmax != null) { self.limitvalue += 1; if(self.limitvalue > self.limitmax) { self.limitvalue = self.limitmax; } } /*ultimately i quite like what i'd ended up with for ncr jester. by settling for bop bop draining on 6 rather than on snap; it essentially takes on the roles of bop *and* sweets both at once while not being redundant to zoop zoop (since zoop zoop does less damage on 4s and 5s); which allows me to replace sweets with an item that doesn't heal whatsoever*/,Magic Six,NORMAL,,ORANGE,,,,none,0,YES,,,,,,,,,,,,,,
Trick,Get a new dice,1,givedice(); /*i felt so clever when i made this because i literally did not remember cauldron exists. this was meant as a sweets replacement until i thought of veneer*/,Rollout,NORMAL,,ORANGE,change_power,change_power,,none,0,YES,,,,,,,,,,,,,,
Trick_upgraded,Get two new dice,1,givedice([rand([1|2|3|4|5|6]|rand([1|2|3|4|5|6]]);,Rollout,NORMAL|NORMAL,,ORANGE,,,,none,0,YES,,,,,,,,,,,,,,
Trick_downgraded,Get a new dice,1,givedice();,Rollout,MIN4,,ORANGE,,,,none,0,YES,,,,,,,,,,,,,,
Toolbox@flip,Split - Nudge - Bump - [yellow]Flip[]|Use 1-6 to cycle,1,if(d > 1 & d < 6) { givedice(7 - d); } else { bonus(-99999999); self.equipmentused--; self.equipmenthistory.pop(); },Super Hexahedron,MAX5,,GREEN,change_power,change_power,,none,,YES,,excludefromrandomlists,,,if(!simulation) { if(self.getvar(~swissactuator~) != 0) self.getvar(~swissactuator~).stop(); var tw = new motion.actuators.SimpleActuator(null|1/60|null); tw._repeat = -1; var s = new elements.Skill(~Against all odds_old~); s.script = ~  var knives = [\~Toolbox@split\~|\~Toolbox@nudge\~|\~Toolbox@bump\~|\~Toolbox@flip\~|\~Toolbox@flip+\~|\~Toolbox@bump+\~|\~Toolbox@nudge+\~|\~Toolbox@split+\~];  for(eq in self.equipment) {   if(eq.namemodifier != \~-\~ && eq.assigneddice.length > 0 && eq.assigneddice[0] != null && (eq.assigneddice[0].basevalue == 6 # eq.assigneddice[0].basevalue == 1) && knives.indexOf(eq.name + eq.namemodifier) != -1) {    if(eq.assigneddice[0].basevalue == 6) {     eq.removedice();     var newknife = new elements.Equipment(knives[knives.indexOf(eq.name) + 1]);     newknife.x = eq.x;     newknife.y = eq.y;     eq.script = \~\~;     self.equipment[self.equipment.indexOf(eq)] = newknife;     newknife.animate(\~flashandshake\~);     self.equipmentused--;     sfx(\~_thinghappens\~);    }    else {     eq.removedice();     var newknife = new elements.Equipment(knives[knives.indexOf(eq.name) - 1]);     newknife.x = eq.x;     newknife.y = eq.y;     eq.script = \~\~;     self.equipment[self.equipment.indexOf(eq)] = newknife;     newknife.animate(\~flashandshake\~);     self.equipmentused--;     sfx(\~_thinghappens\~);    }   }  }  if(target == null # target.graphic == null # target.hp <= 0) {   self.getvar(\~swissactuator\~).stop();   self.resetvar(\~swissactuator\~);  } ~; tw.onRepeat(s.execute|[self|target]); self.setvar(~swissactuator~|tw); tw.move(); },,,,,,,,,
Toolbox@split,[yellow]Split[] - Nudge - Bump - Flip|Use 1-6 to cycle,1,if(d > 1 & d < 6) { givedice(split(d)|~splitdice~); } else { bonus(-99999999); self.equipmentused--; self.equipmenthistory.pop(); },Super Hexahedron,MIN2,,GREEN,change_power,change_power,,none,,YES,,excludefromrandomlists,,,if(!simulation) { if(self.getvar(~swissactuator~) != 0) self.getvar(~swissactuator~).stop(); var tw = new motion.actuators.SimpleActuator(null|1/60|null); tw._repeat = -1; var s = new elements.Skill(~Against all odds_old~); s.script = ~  var knives = [\~Toolbox@split\~|\~Toolbox@nudge\~|\~Toolbox@bump\~|\~Toolbox@flip\~|\~Toolbox@flip+\~|\~Toolbox@bump+\~|\~Toolbox@nudge+\~|\~Toolbox@split+\~];  for(eq in self.equipment) {   if(eq.namemodifier != \~-\~ && eq.assigneddice.length > 0 && eq.assigneddice[0] != null && (eq.assigneddice[0].basevalue == 6 # eq.assigneddice[0].basevalue == 1) && knives.indexOf(eq.name + eq.namemodifier) != -1) {    if(eq.assigneddice[0].basevalue == 6) {     eq.removedice();     var newknife = new elements.Equipment(knives[knives.indexOf(eq.name) + 1]);     newknife.x = eq.x;     newknife.y = eq.y;     eq.script = \~\~;     self.equipment[self.equipment.indexOf(eq)] = newknife;     newknife.animate(\~flashandshake\~);     self.equipmentused--;     sfx(\~_thinghappens\~);    }    else {     eq.removedice();     var newknife = new elements.Equipment(knives[knives.indexOf(eq.name) - 1]);     newknife.x = eq.x;     newknife.y = eq.y;     eq.script = \~\~;     self.equipment[self.equipment.indexOf(eq)] = newknife;     newknife.animate(\~flashandshake\~);     self.equipmentused--;     sfx(\~_thinghappens\~);    }   }  }  if(target == null # target.graphic == null # target.hp <= 0) {   self.getvar(\~swissactuator\~).stop();   self.resetvar(\~swissactuator\~);  } ~; tw.onRepeat(s.execute|[self|target]); self.setvar(~swissactuator~|tw); tw.move(); },,,,,,,,,
Toolbox@bump,Split - Nudge - [yellow]Bump[] - Flip|Use 1-6 to cycle,1,if(d > 1 & d < 6) { givedice(d + 1); } else { bonus(-99999999); self.equipmentused--; self.equipmenthistory.pop(); },Super Hexahedron,NORMAL,,GREEN,change_power,change_power,,none,,YES,,excludefromrandomlists,,,if(!simulation) { if(self.getvar(~swissactuator~) != 0) self.getvar(~swissactuator~).stop(); var tw = new motion.actuators.SimpleActuator(null|1/60|null); tw._repeat = -1; var s = new elements.Skill(~Against all odds_old~); s.script = ~  var knives = [\~Toolbox@split\~|\~Toolbox@nudge\~|\~Toolbox@bump\~|\~Toolbox@flip\~|\~Toolbox@flip+\~|\~Toolbox@bump+\~|\~Toolbox@nudge+\~|\~Toolbox@split+\~];  for(eq in self.equipment) {   if(eq.namemodifier != \~-\~ && eq.assigneddice.length > 0 && eq.assigneddice[0] != null && (eq.assigneddice[0].basevalue == 6 # eq.assigneddice[0].basevalue == 1) && knives.indexOf(eq.name + eq.namemodifier) != -1) {    if(eq.assigneddice[0].basevalue == 6) {     eq.removedice();     var newknife = new elements.Equipment(knives[knives.indexOf(eq.name) + 1]);     newknife.x = eq.x;     newknife.y = eq.y;     eq.script = \~\~;     self.equipment[self.equipment.indexOf(eq)] = newknife;     newknife.animate(\~flashandshake\~);     self.equipmentused--;     sfx(\~_thinghappens\~);    }    else {     eq.removedice();     var newknife = new elements.Equipment(knives[knives.indexOf(eq.name) - 1]);     newknife.x = eq.x;     newknife.y = eq.y;     eq.script = \~\~;     self.equipment[self.equipment.indexOf(eq)] = newknife;     newknife.animate(\~flashandshake\~);     self.equipmentused--;     sfx(\~_thinghappens\~);    }   }  }  if(target == null # target.graphic == null # target.hp <= 0) {   self.getvar(\~swissactuator\~).stop();   self.resetvar(\~swissactuator\~);  } ~; tw.onRepeat(s.execute|[self|target]); self.setvar(~swissactuator~|tw); tw.move(); },,,,,,,,,
Toolbox@nudge,Split - [yellow]Nudge[] - Bump - Flip|Use 1-6 to cycle,1,if(d > 1 & d < 6) { givedice(d - 1); } else { bonus(-99999999); self.equipmentused--; self.equipmenthistory.pop(); },Super Hexahedron,NORMAL,,GREEN,change_power,change_power,,none,,YES,,excludefromrandomlists,,,if(!simulation) { if(self.getvar(~swissactuator~) != 0) self.getvar(~swissactuator~).stop(); var tw = new motion.actuators.SimpleActuator(null|1/60|null); tw._repeat = -1; var s = new elements.Skill(~Against all odds_old~); s.script = ~  var knives = [\~Toolbox@split\~|\~Toolbox@nudge\~|\~Toolbox@bump\~|\~Toolbox@flip\~|\~Toolbox@flip+\~|\~Toolbox@bump+\~|\~Toolbox@nudge+\~|\~Toolbox@split+\~];  for(eq in self.equipment) {   if(eq.namemodifier != \~-\~ && eq.assigneddice.length > 0 && eq.assigneddice[0] != null && (eq.assigneddice[0].basevalue == 6 # eq.assigneddice[0].basevalue == 1) && knives.indexOf(eq.name + eq.namemodifier) != -1) {    if(eq.assigneddice[0].basevalue == 6) {     eq.removedice();     var newknife = new elements.Equipment(knives[knives.indexOf(eq.name) + 1]);     newknife.x = eq.x;     newknife.y = eq.y;     eq.script = \~\~;     self.equipment[self.equipment.indexOf(eq)] = newknife;     newknife.animate(\~flashandshake\~);     self.equipmentused--;     sfx(\~_thinghappens\~);    }    else {     eq.removedice();     var newknife = new elements.Equipment(knives[knives.indexOf(eq.name) - 1]);     newknife.x = eq.x;     newknife.y = eq.y;     eq.script = \~\~;     self.equipment[self.equipment.indexOf(eq)] = newknife;     newknife.animate(\~flashandshake\~);     self.equipmentused--;     sfx(\~_thinghappens\~);    }   }  }  if(target == null # target.graphic == null # target.hp <= 0) {   self.getvar(\~swissactuator\~).stop();   self.resetvar(\~swissactuator\~);  } ~; tw.onRepeat(s.execute|[self|target]); self.setvar(~swissactuator~|tw); tw.move(); },,,,,,,,,
Toolbox@flip_downgraded,Split - Nudge - Bump - [yellow]Flip[],1,if(d > 1 & d < 6) { givedice(7 - d); } else { bonus(-99999999); self.equipmentused--; self.equipmenthistory.pop(); },Super Hexahedron,RANGE25,,GREEN,,,,none,,YES,,excludefromrandomlists,,,if(!simulation) { if(self.getvar(~swissactuator~) != 0) self.getvar(~swissactuator~).stop(); var tw = new motion.actuators.SimpleActuator(null|1/60|null); tw._repeat = -1; var s = new elements.Skill(~Against all odds_old~); s.script = ~  var knives = [\~Toolbox@split\~|\~Toolbox@nudge\~|\~Toolbox@bump\~|\~Toolbox@flip\~|\~Toolbox@flip+\~|\~Toolbox@bump+\~|\~Toolbox@nudge+\~|\~Toolbox@split+\~];  for(eq in self.equipment) {   if(eq.namemodifier != \~-\~ && eq.assigneddice.length > 0 && eq.assigneddice[0] != null && (eq.assigneddice[0].basevalue == 6 # eq.assigneddice[0].basevalue == 1) && knives.indexOf(eq.name + eq.namemodifier) != -1) {    if(eq.assigneddice[0].basevalue == 6) {     eq.removedice();     var newknife = new elements.Equipment(knives[knives.indexOf(eq.name) + 1]);     newknife.x = eq.x;     newknife.y = eq.y;     eq.script = \~\~;     self.equipment[self.equipment.indexOf(eq)] = newknife;     newknife.animate(\~flashandshake\~);     self.equipmentused--;     sfx(\~_thinghappens\~);    }    else {     eq.removedice();     var newknife = new elements.Equipment(knives[knives.indexOf(eq.name) - 1]);     newknife.x = eq.x;     newknife.y = eq.y;     eq.script = \~\~;     self.equipment[self.equipment.indexOf(eq)] = newknife;     newknife.animate(\~flashandshake\~);     self.equipmentused--;     sfx(\~_thinghappens\~);    }   }  }  if(target == null # target.graphic == null # target.hp <= 0) {   self.getvar(\~swissactuator\~).stop();   self.resetvar(\~swissactuator\~);  } ~; tw.onRepeat(s.execute|[self|target]); self.setvar(~swissactuator~|tw); tw.move(); },,,,,,,,,
Toolbox@split_downgraded,[yellow]Split[] - Nudge - Bump - Flip,1,if(d > 1 & d < 6) { givedice(split(d)|~splitdice~); } else { bonus(-99999999); self.equipmentused--; self.equipmenthistory.pop(); },Super Hexahedron,RANGE25,,GREEN,,,,none,,YES,,excludefromrandomlists,,,if(!simulation) { if(self.getvar(~swissactuator~) != 0) self.getvar(~swissactuator~).stop(); var tw = new motion.actuators.SimpleActuator(null|1/60|null); tw._repeat = -1; var s = new elements.Skill(~Against all odds_old~); s.script = ~  var knives = [\~Toolbox@split\~|\~Toolbox@nudge\~|\~Toolbox@bump\~|\~Toolbox@flip\~|\~Toolbox@flip+\~|\~Toolbox@bump+\~|\~Toolbox@nudge+\~|\~Toolbox@split+\~];  for(eq in self.equipment) {   if(eq.namemodifier != \~-\~ && eq.assigneddice.length > 0 && eq.assigneddice[0] != null && (eq.assigneddice[0].basevalue == 6 # eq.assigneddice[0].basevalue == 1) && knives.indexOf(eq.name + eq.namemodifier) != -1) {    if(eq.assigneddice[0].basevalue == 6) {     eq.removedice();     var newknife = new elements.Equipment(knives[knives.indexOf(eq.name) + 1]);     newknife.x = eq.x;     newknife.y = eq.y;     eq.script = \~\~;     self.equipment[self.equipment.indexOf(eq)] = newknife;     newknife.animate(\~flashandshake\~);     self.equipmentused--;     sfx(\~_thinghappens\~);    }    else {     eq.removedice();     var newknife = new elements.Equipment(knives[knives.indexOf(eq.name) - 1]);     newknife.x = eq.x;     newknife.y = eq.y;     eq.script = \~\~;     self.equipment[self.equipment.indexOf(eq)] = newknife;     newknife.animate(\~flashandshake\~);     self.equipmentused--;     sfx(\~_thinghappens\~);    }   }  }  if(target == null # target.graphic == null # target.hp <= 0) {   self.getvar(\~swissactuator\~).stop();   self.resetvar(\~swissactuator\~);  } ~; tw.onRepeat(s.execute|[self|target]); self.setvar(~swissactuator~|tw); tw.move(); },,,,,,,,,
Toolbox@bump_downgraded,Split - Nudge - [yellow]Bump[] - Flip,1,if(d > 1 & d < 6) { givedice(d + 1); } else { bonus(-99999999); self.equipmentused--; self.equipmenthistory.pop(); },Super Hexahedron,RANGE25,,GREEN,,,,none,,YES,,excludefromrandomlists,,,if(!simulation) { if(self.getvar(~swissactuator~) != 0) self.getvar(~swissactuator~).stop(); var tw = new motion.actuators.SimpleActuator(null|1/60|null); tw._repeat = -1; var s = new elements.Skill(~Against all odds_old~); s.script = ~  var knives = [\~Toolbox@split\~|\~Toolbox@nudge\~|\~Toolbox@bump\~|\~Toolbox@flip\~|\~Toolbox@flip+\~|\~Toolbox@bump+\~|\~Toolbox@nudge+\~|\~Toolbox@split+\~];  for(eq in self.equipment) {   if(eq.namemodifier != \~-\~ && eq.assigneddice.length > 0 && eq.assigneddice[0] != null && (eq.assigneddice[0].basevalue == 6 # eq.assigneddice[0].basevalue == 1) && knives.indexOf(eq.name + eq.namemodifier) != -1) {    if(eq.assigneddice[0].basevalue == 6) {     eq.removedice();     var newknife = new elements.Equipment(knives[knives.indexOf(eq.name) + 1]);     newknife.x = eq.x;     newknife.y = eq.y;     eq.script = \~\~;     self.equipment[self.equipment.indexOf(eq)] = newknife;     newknife.animate(\~flashandshake\~);     self.equipmentused--;     sfx(\~_thinghappens\~);    }    else {     eq.removedice();     var newknife = new elements.Equipment(knives[knives.indexOf(eq.name) - 1]);     newknife.x = eq.x;     newknife.y = eq.y;     eq.script = \~\~;     self.equipment[self.equipment.indexOf(eq)] = newknife;     newknife.animate(\~flashandshake\~);     self.equipmentused--;     sfx(\~_thinghappens\~);    }   }  }  if(target == null # target.graphic == null # target.hp <= 0) {   self.getvar(\~swissactuator\~).stop();   self.resetvar(\~swissactuator\~);  } ~; tw.onRepeat(s.execute|[self|target]); self.setvar(~swissactuator~|tw); tw.move(); },,,,,,,,,
Toolbox@nudge_downgraded,Split - [yellow]Nudge[] - Bump - Flip,1,if(d > 1 & d < 6) { givedice(d - 1); } else { bonus(-99999999); self.equipmentused--; self.equipmenthistory.pop(); },Super Hexahedron,RANGE25,,GREEN,,,,none,,YES,,excludefromrandomlists,,,if(!simulation) { if(self.getvar(~swissactuator~) != 0) self.getvar(~swissactuator~).stop(); var tw = new motion.actuators.SimpleActuator(null|1/60|null); tw._repeat = -1; var s = new elements.Skill(~Against all odds_old~); s.script = ~  var knives = [\~Toolbox@split\~|\~Toolbox@nudge\~|\~Toolbox@bump\~|\~Toolbox@flip\~|\~Toolbox@flip+\~|\~Toolbox@bump+\~|\~Toolbox@nudge+\~|\~Toolbox@split+\~];  for(eq in self.equipment) {   if(eq.namemodifier != \~-\~ && eq.assigneddice.length > 0 && eq.assigneddice[0] != null && (eq.assigneddice[0].basevalue == 6 # eq.assigneddice[0].basevalue == 1) && knives.indexOf(eq.name + eq.namemodifier) != -1) {    if(eq.assigneddice[0].basevalue == 6) {     eq.removedice();     var newknife = new elements.Equipment(knives[knives.indexOf(eq.name) + 1]);     newknife.x = eq.x;     newknife.y = eq.y;     eq.script = \~\~;     self.equipment[self.equipment.indexOf(eq)] = newknife;     newknife.animate(\~flashandshake\~);     self.equipmentused--;     sfx(\~_thinghappens\~);    }    else {     eq.removedice();     var newknife = new elements.Equipment(knives[knives.indexOf(eq.name) - 1]);     newknife.x = eq.x;     newknife.y = eq.y;     eq.script = \~\~;     self.equipment[self.equipment.indexOf(eq)] = newknife;     newknife.animate(\~flashandshake\~);     self.equipmentused--;     sfx(\~_thinghappens\~);    }   }  }  if(target == null # target.graphic == null # target.hp <= 0) {   self.getvar(\~swissactuator\~).stop();   self.resetvar(\~swissactuator\~);  } ~; tw.onRepeat(s.execute|[self|target]); self.setvar(~swissactuator~|tw); tw.move(); },,,,,,,,,
Toolbox@flip_upgraded,[yellow]Flip[] - Bump - Nudge - Split|Use 1-6 to cycle,1,if(d > 1 & d < 6) { givedice(7 - d); } else { bonus(-99999999); self.equipmentused--; self.equipmenthistory.pop(); },Super Hexahedron,MIN2,,GREEN,,,,none,,YES,,excludefromrandomlists,,,if(!simulation) { if(self.getvar(~swissactuator~) != 0) self.getvar(~swissactuator~).stop(); var tw = new motion.actuators.SimpleActuator(null|1/60|null); tw._repeat = -1; var s = new elements.Skill(~Against all odds_old~); s.script = ~  var knives = [\~Toolbox@split\~|\~Toolbox@nudge\~|\~Toolbox@bump\~|\~Toolbox@flip\~|\~Toolbox@flip+\~|\~Toolbox@bump+\~|\~Toolbox@nudge+\~|\~Toolbox@split+\~];  for(eq in self.equipment) {   if(eq.namemodifier != \~-\~ && eq.assigneddice.length > 0 && eq.assigneddice[0] != null && (eq.assigneddice[0].basevalue == 6 # eq.assigneddice[0].basevalue == 1) && knives.indexOf(eq.name + eq.namemodifier) != -1) {    if(eq.assigneddice[0].basevalue == 6) {     eq.removedice();     var newknife = new elements.Equipment(knives[knives.indexOf(eq.name) + 1]);     newknife.x = eq.x;     newknife.y = eq.y;     eq.script = \~\~;     self.equipment[self.equipment.indexOf(eq)] = newknife;     newknife.animate(\~flashandshake\~);     self.equipmentused--;     sfx(\~_thinghappens\~);    }    else {     eq.removedice();     var newknife = new elements.Equipment(knives[knives.indexOf(eq.name) - 1]);     newknife.x = eq.x;     newknife.y = eq.y;     eq.script = \~\~;     self.equipment[self.equipment.indexOf(eq)] = newknife;     newknife.animate(\~flashandshake\~);     self.equipmentused--;     sfx(\~_thinghappens\~);    }   }  }  if(target == null # target.graphic == null # target.hp <= 0) {   self.getvar(\~swissactuator\~).stop();   self.resetvar(\~swissactuator\~);  } ~; tw.onRepeat(s.execute|[self|target]); self.setvar(~swissactuator~|tw); tw.move(); },,,,,,,,,
Toolbox@split_upgraded,Flip - Bump - Nudge - [yellow]Split[]|Use 1-6 to cycle,1,if(d > 1 & d < 6) { givedice(split(d)|~splitdice~); } else { bonus(-99999999); self.equipmentused--; self.equipmenthistory.pop(); },Super Hexahedron,MAX5,,GREEN,,,,none,,YES,,excludefromrandomlists,,,if(!simulation) { if(self.getvar(~swissactuator~) != 0) self.getvar(~swissactuator~).stop(); var tw = new motion.actuators.SimpleActuator(null|1/60|null); tw._repeat = -1; var s = new elements.Skill(~Against all odds_old~); s.script = ~  var knives = [\~Toolbox@split\~|\~Toolbox@nudge\~|\~Toolbox@bump\~|\~Toolbox@flip\~|\~Toolbox@flip+\~|\~Toolbox@bump+\~|\~Toolbox@nudge+\~|\~Toolbox@split+\~];  for(eq in self.equipment) {   if(eq.namemodifier != \~-\~ && eq.assigneddice.length > 0 && eq.assigneddice[0] != null && (eq.assigneddice[0].basevalue == 6 # eq.assigneddice[0].basevalue == 1) && knives.indexOf(eq.name + eq.namemodifier) != -1) {    if(eq.assigneddice[0].basevalue == 6) {     eq.removedice();     var newknife = new elements.Equipment(knives[knives.indexOf(eq.name) + 1]);     newknife.x = eq.x;     newknife.y = eq.y;     eq.script = \~\~;     self.equipment[self.equipment.indexOf(eq)] = newknife;     newknife.animate(\~flashandshake\~);     self.equipmentused--;     sfx(\~_thinghappens\~);    }    else {     eq.removedice();     var newknife = new elements.Equipment(knives[knives.indexOf(eq.name) - 1]);     newknife.x = eq.x;     newknife.y = eq.y;     eq.script = \~\~;     self.equipment[self.equipment.indexOf(eq)] = newknife;     newknife.animate(\~flashandshake\~);     self.equipmentused--;     sfx(\~_thinghappens\~);    }   }  }  if(target == null # target.graphic == null # target.hp <= 0) {   self.getvar(\~swissactuator\~).stop();   self.resetvar(\~swissactuator\~);  } ~; tw.onRepeat(s.execute|[self|target]); self.setvar(~swissactuator~|tw); tw.move(); },,,,,,,,,
Toolbox@bump_upgraded,Flip - [yellow]Bump[] - Nudge - Split|Use 1-6 to cycle,1,if(d > 1 & d < 6) { givedice(d + 1); } else { bonus(-99999999); self.equipmentused--; self.equipmenthistory.pop(); },Super Hexahedron,NORMAL,,GREEN,,,,none,,YES,,excludefromrandomlists,,,if(!simulation) { if(self.getvar(~swissactuator~) != 0) self.getvar(~swissactuator~).stop(); var tw = new motion.actuators.SimpleActuator(null|1/60|null); tw._repeat = -1; var s = new elements.Skill(~Against all odds_old~); s.script = ~  var knives = [\~Toolbox@split\~|\~Toolbox@nudge\~|\~Toolbox@bump\~|\~Toolbox@flip\~|\~Toolbox@flip+\~|\~Toolbox@bump+\~|\~Toolbox@nudge+\~|\~Toolbox@split+\~];  for(eq in self.equipment) {   if(eq.namemodifier != \~-\~ && eq.assigneddice.length > 0 && eq.assigneddice[0] != null && (eq.assigneddice[0].basevalue == 6 # eq.assigneddice[0].basevalue == 1) && knives.indexOf(eq.name + eq.namemodifier) != -1) {    if(eq.assigneddice[0].basevalue == 6) {     eq.removedice();     var newknife = new elements.Equipment(knives[knives.indexOf(eq.name) + 1]);     newknife.x = eq.x;     newknife.y = eq.y;     eq.script = \~\~;     self.equipment[self.equipment.indexOf(eq)] = newknife;     newknife.animate(\~flashandshake\~);     self.equipmentused--;     sfx(\~_thinghappens\~);    }    else {     eq.removedice();     var newknife = new elements.Equipment(knives[knives.indexOf(eq.name) - 1]);     newknife.x = eq.x;     newknife.y = eq.y;     eq.script = \~\~;     self.equipment[self.equipment.indexOf(eq)] = newknife;     newknife.animate(\~flashandshake\~);     self.equipmentused--;     sfx(\~_thinghappens\~);    }   }  }  if(target == null # target.graphic == null # target.hp <= 0) {   self.getvar(\~swissactuator\~).stop();   self.resetvar(\~swissactuator\~);  } ~; tw.onRepeat(s.execute|[self|target]); self.setvar(~swissactuator~|tw); tw.move(); },,,,,,,,,
Toolbox@nudge_upgraded,Flip - Bump - [yellow]Nudge[] - Split|Use 1-6 to cycle,1,if(d > 1 & d < 6) { givedice(d - 1); } else { bonus(-99999999); self.equipmentused--; self.equipmenthistory.pop(); },Super Hexahedron,NORMAL,,GREEN,,,,none,,YES,,excludefromrandomlists,,,if(!simulation) { if(self.getvar(~swissactuator~) != 0) self.getvar(~swissactuator~).stop(); var tw = new motion.actuators.SimpleActuator(null|1/60|null); tw._repeat = -1; var s = new elements.Skill(~Against all odds_old~); s.script = ~  var knives = [\~Toolbox@split\~|\~Toolbox@nudge\~|\~Toolbox@bump\~|\~Toolbox@flip\~|\~Toolbox@flip+\~|\~Toolbox@bump+\~|\~Toolbox@nudge+\~|\~Toolbox@split+\~];  for(eq in self.equipment) {   if(eq.namemodifier != \~-\~ && eq.assigneddice.length > 0 && eq.assigneddice[0] != null && (eq.assigneddice[0].basevalue == 6 # eq.assigneddice[0].basevalue == 1) && knives.indexOf(eq.name + eq.namemodifier) != -1) {    if(eq.assigneddice[0].basevalue == 6) {     eq.removedice();     var newknife = new elements.Equipment(knives[knives.indexOf(eq.name) + 1]);     newknife.x = eq.x;     newknife.y = eq.y;     eq.script = \~\~;     self.equipment[self.equipment.indexOf(eq)] = newknife;     newknife.animate(\~flashandshake\~);     self.equipmentused--;     sfx(\~_thinghappens\~);    }    else {     eq.removedice();     var newknife = new elements.Equipment(knives[knives.indexOf(eq.name) - 1]);     newknife.x = eq.x;     newknife.y = eq.y;     eq.script = \~\~;     self.equipment[self.equipment.indexOf(eq)] = newknife;     newknife.animate(\~flashandshake\~);     self.equipmentused--;     sfx(\~_thinghappens\~);    }   }  }  if(target == null # target.graphic == null # target.hp <= 0) {   self.getvar(\~swissactuator\~).stop();   self.resetvar(\~swissactuator\~);  } ~; tw.onRepeat(s.execute|[self|target]); self.setvar(~swissactuator~|tw); tw.move(); },,,,,,,,,
Ultimagnet,Shock [shock]1 equipment[;]|on jackpot[;] shock [shock]ALL,1,if(self.roll_jackpot > 0) { inflict(SHOCK|ALL); } else { inflict(SHOCK); },Discharge,EVEN,,YELLOW,change_power,complicate,,_shock,,,,robotonly,,,,,,,,,,,,
Ultimagnet_upgraded,Do [shock]2 dmg[;] shock [shock]1[;]|on jackpot[;] shock [shock]ALL,1,attack(2|SHOCK); sfxdamage(target|d); sfx(~_shock~|~~|0.2); if(self.roll_jackpot > 0) { inflict(SHOCK|ALL); } else { inflict(SHOCK); },Discharge,EVEN,,YELLOW,,,,none,,,,robotonly,,,,,,,,,,,,
Awful Pun,Inflict [vanish]1 vanish[;]|immune to errors,1,inflict(~ncr_vanish~),Delude,EVEN,,GRAY,change_power,complicate,,_vanish,0,NO,NO,errorimmune,,,,,,,,,,,,
Awful Pun_upgraded,Do [vanish]2 dmg[;] inflict [vanish]1[;]|immune to errors,1,attack(2|VANISH); sfxdamage(target|2); inflict(~ncr_vanish~); sfx(~_vanish~|~~|0.2);,Delude,EVEN,,GRAY,,,,none,0,NO,NO,errorimmune,,,,,,,,,,,,
Breaking Point,Do [sword]<d6> damage[;]|raise limit break by [confuse]<d6>,1,attack(d); sfxdamage(target|d); if(self.limitvalue != null && self.limitmax != null) { sfx(~_cure~); self.limitvalue += d; if(self.limitvalue > self.limitmax) { self.limitvalue = self.limitmax; } },Hustle,MAX3,,YELLOW,increaserange,change_power,,none,,,,,1,if(self.limitvalue != null && self.limitmax != null) { sfx(~_cure~); self.limitvalue += d; if(self.limitvalue > self.limitmax) { self.limitvalue = self.limitmax; } },,,,,,,,,,
Breaking Point_downgraded,Do [sword]<d6> damage[;]|take [sword]<d6> damage,1,attack(d); sfxdamage(target|d); attackself(d); sfx(~_heal~|~~|0.2);,Hustle,MAX3,,YELLOW,,,,none,,,,,,attackself(d); sfx(~_heal~);,,,,,,,,,,
Ego Stroke,Raise limit break by [confuse]2|,1,if(self.limitvalue != null && self.limitmax != null) { sfx(~_cure~); self.limitvalue += 2; if(self.limitvalue > self.limitmax) { self.limitvalue = self.limitmax; } },Hustle,COUNTDOWN,4,YELLOW,change_power,change_power,,,,YES,,,1,,,,,,,,,,,
Ego Stroke_upgraded,Raise limit break by [confuse]2|,1,if(self.limitvalue != null && self.limitmax != null) { sfx(~_cure~); self.limitvalue += 2; if(self.limitvalue > self.limitmax) { self.limitvalue = self.limitmax; } },Hustle,COUNTDOWN,2,YELLOW,,,,,,YES,,,,,,,,,,,,,,
Ego Stroke_weakened,Take [sword]2 damage,1,attackself(2); sfxdamage(self|2);,Hustle,COUNTDOWN,2,YELLOW,,,,,,YES,,,,,,,,,,,,,,
Ego Stroke_downgraded,Take [sword]2 damage,1,attackself(2); sfxdamage(self|2);,Hustle,COUNTDOWN,4,YELLOW,,,,,,YES,,,,,,,,,,,,,,
Uninitialized Behavior,Do [sword]4[;] increase CPU by 1-6|No effect on jackpot or error|,1,if(self.roll_total < self.roll_target) { attack(4); sfxdamage(target|4); adjustrobotcounter(rand([1|2|3|4|5|6])); } else { self.textparticle(~No effect!~); },Install Evony,NORMAL,,PURPLE,change_power,change_power,,,-1,NO,NO,robotonly|nevererrorimmune,,,,,,,,,,,,
Uninitialized Behavior_upgraded,Do [sword]4[;] increase CPU by 1-4|No effect on jackpot or error|,1,if(self.roll_total < self.roll_target) { attack(4); sfxdamage(target|4); adjustrobotcounter(rand([1|2|3|4])); } else { self.textparticle(~No effect!~); },Install Evony,NORMAL,,PURPLE,,,,,-1,NO,NO,robotonly|nevererrorimmune,,,,,,,,,,,,
Uninitialized Behavior_downgraded,Do [sword]4[;] increase CPU by 3-6|No effect on jackpot or error|,1,if(self.roll_total < self.roll_target) { attack(4); sfxdamage(target|4); adjustrobotcounter(rand([3|4|5|6])); } else { self.textparticle(~No effect!~); },Install Evony,NORMAL,,PURPLE,,,,,-1,NO,NO,robotonly|nevererrorimmune,,,,,,,,,,,,
Double Jinx,Halve all jinx countdowns,1,if(self.status.length > 0) { for(mystat in self.status) { if(mystat.type.substr(0|4) == ~jinx~) { var reducejxby = mystat.value / 2; if(reducejxby % 1 != 0) reducejxby -= 0.5; mystat.add(-reducejxby); trace(~done~); } } } if(target.status.length > 0) { for(mystat in target.status) { if(mystat.type.substr(0|4) == ~jinx~) { var reducejxby = mystat.value / 2; if(reducejxby % 1 != 0) reducejxby -= 0.5; mystat.add(-reducejxby); trace(~done~); } } },Down Low,NORMAL|NORMAL,,PINK,change_power,change_power,,_thinghappens,0,YES,NO,,1,,,,,,,,,,,
Double Jinx_upgraded,Halve all jinx countdowns[;]|return one of the dice,1,givedice(rand([actualdice[0].basevalue|actualdice[1].basevalue])); if(self.status.length > 0) { for(mystat in self.status) { if(mystat.type.substr(0|4) == ~jinx~) { var reducejxby = mystat.value / 2; if(reducejxby % 1 != 0) reducejxby -= 0.5; mystat.add(-reducejxby); trace(~done~); } } } if(target.status.length > 0) { for(mystat in target.status) { if(mystat.type.substr(0|4) == ~jinx~) { var reducejxby = mystat.value / 2; if(reducejxby % 1 != 0) reducejxby -= 0.5; mystat.add(-reducejxby); trace(~done~); } } },Down Low,NORMAL|NORMAL,,PINK,,,,_thinghappens,0,YES,NO,,,,,,,,,,,,,
Double Jinx_downgraded,Halve all jinx countdowns,1,if(self.status.length > 0) { for(mystat in self.status) { if(mystat.type.substr(0|4) == ~jinx~) { var reducejxby = mystat.value / 2; if(reducejxby % 1 != 0) reducejxby -= 0.5; mystat.add(-reducejxby); trace(~done~); } } } if(target.status.length > 0) { for(mystat in target.status) { if(mystat.type.substr(0|4) == ~jinx~) { var reducejxby = mystat.value / 2; if(reducejxby % 1 != 0) reducejxby -= 0.5; mystat.add(-reducejxby); trace(~done~); } } },Down Low,MIN4|MIN4,,PINK,,,,_thinghappens,0,YES,NO,,,,,,,,,,,,,
Crysis,Double CPU[;] add 1,1,adjustrobotcounter(self.roll_total + 1);,impulse 101,EVEN,,BRIGHTCYAN,change_power,change_power,,jackpot_increasecounter,0,YES,NO,robotonly,,,,,,,,,,,,
Crysis_upgraded,Double CPU[;] add 1|,1,adjustrobotcounter(self.roll_total + 1);,impulse 101,EVEN,,BRIGHTCYAN,,,,jackpot_increasecounter,-1,YES,NO,robotonly,,,,,,,,,,,,
Crysis_downgraded,Quadruple CPU[;] add 1,1,adjustrobotcounter((3 * self.roll_total) + 1);,impulse 101,EVEN,,BRIGHTCYAN,,,,jackpot_increasecounter,0,YES,NO,robotonly,,,,,,,,,,,,
Extreme Detail Bat,Do [sword]<d6> damage|(Raise CPU by 6 each turn),2,attack(d); sfxdamage(target|d);,Install Evony,NORMAL|FREE3,,GRAY,change_power,change_power,,,0,,,robotonly,,,,,,adjustrobotcounter(6); e.animate(~flashandshake~);,,,,,,
Extreme Detail Bat_upgraded,Do [sword]<d6> damage[;]|then raise CPU by 6,2,attack(d); adjustrobotcounter(6); sfxdamage(target|d);,Install Evony,NORMAL|FREE3,,GRAY,,,,,0,,,robotonly,,adjustrobotcounter(6);,,,,,,,,,,
Extreme Detail Bat_downgraded,Do [sword]<d6> damage|(Raise CPU by 6 each turn),2,attack(d); sfxdamage(target|d);,Install Evony,NORMAL|FREE1,,GRAY,,,,,0,,,robotonly,,,,,,adjustrobotcounter(6); e.animate(~flashandshake~);,,,,,,
Ultimegaphone,Weaken [weaken]1 equipment[;]|on jackpot[;] weaken [weaken]ALL,1,if(self.roll_jackpot > 0) { inflict(WEAKEN|ALL); } else { inflict(WEAKEN); },Guitar Solo,ODD,,ORANGE,change_power,complicate,weaken,_weaken,,,,robotonly,,,,,,,,,,,,
Ultimegaphone_upgraded,Do [weaken]2 dmg[;] weaken [weaken]1[;]|on jackpot[;] weaken [weaken]ALL,1,attack(2|WEAKEN); sfxdamage(target|d); sfx(~_shock~|~~|0.2); if(self.roll_jackpot > 0) { inflict(WEAKEN|ALL); } else { inflict(WEAKEN); },Guitar Solo,ODD,,ORANGE,,,,none,,,,robotonly,,,,,,,,,,,,
Ultimegaphone?,Inflict [weaken]1 weaken[;] on|jackpot[;] inflict [weaken]1 per card,1,if(self.roll_jackpot > 0) { inflict(WEAKEN|ALL); } else { inflict(WEAKEN); },Guitar Solo,ODD,,ORANGE,change_power,complicate,,_weaken,,,,robotonly|alternateversion,,,,,,,,,,,,
Ultimegaphone?_upgraded,Do [weaken]2 dmg[;] inflict [weaken]1[;] on|jackpot[;] inflict [weaken]1 per card,1,attack(2|WEAKEN); sfxdamage(target|d); sfx(~_shock~|~~|0.2); if(self.roll_jackpot > 0) { inflict(WEAKEN|ALL); } else { inflict(WEAKEN); },Guitar Solo,ODD,,ORANGE,,,,none,,,,robotonly|alternateversion,,,,,,,,,,,,
Halt and Catch Fire,Burn [fire]1 dice[;]|immune to errors,1,inflict(FIRE);,Ember,EVEN,,GRAY,change_power,complicate,,_fire,0,NO,NO,errorimmune,,,,,,,,,,,,
Halt and Catch Fire_upgraded,Do [fire]2 dmg[;] burn [fire]1[;]|immune to errors,1,inflict(FIRE); attack(2|FIRE); sfx(~_fire~|~~|0.2); sfxdamage(target|2);,Ember,EVEN,,GRAY,,,,none,0,NO,NO,errorimmune,,,,,,,,,,,,
Not Responding,Inflict [ice]1 freeze[;]|immune to errors,1,inflict(ICE);,Refrigerator,ODD,,GRAY,change_power,complicate,,_ice,0,NO,NO,errorimmune,,,,,,,,,,,,
Not Responding_upgraded,Do [ice]2 dmg[;] inflict [ice]1[;]|immune to errors,1,inflict(ICE); attack(2|ICE); sfx(~_ice~|~~|0.2); sfxdamage(target|2);,Refrigerator,ODD,,GRAY,,,,none,0,NO,NO,errorimmune,,,,,,,,,,,,
Manual Repair,Set CPU to <d6>,1,adjustrobotcounter(d - self.roll_total);,impulse 101,MIN3|MIN3,,GREEN,change_power,change_power,,none,,YES,,robotonly,,,,,,,,,,,,
Manual Repair_downgraded,Set CPU to <d6>,1,adjustrobotcounter(d - self.roll_total);,impulse 101,MIN4|MIN4,,GREEN,,,,none,,YES,,robotonly,,,,,,,,,,,,
Manual Repair_upgraded,Set CPU to <d6>[;] return a dice,1,adjustrobotcounter(d - self.roll_total); givedice(rand([actualdice[0].basevalue|actualdice[1].basevalue]));,impulse 101,MIN3|MIN3,,GREEN,,,,none,,YES,,robotonly,,,,,,,,,,,,
Ransomware,A random enemy card must|be unlocked with a <d6> first,1,inflict(~ncr_ransom~ + d); /*doesn't work; but for some different reason than reckless piracy. i'm too lazy rn and this isn't exactly a ground breaking status*/,Confiscate,NORMAL,,RED,,,,_lock,,,,excludefromrandomlists|unfinished,,,,,,,,,,,,
Throwing Axe,Do [sword]<d6> damage. On 6[;]|do [sword]<d6> again in 2 turns[;] but|make unavailable next turn,2,attack(d); sfxdamage(target|d); if(d == 6) { e.availablenextturn = false; jinx(~Throwing Axe~|~take [sword]%VAR% damage~|~Take [sword]%VAR% damage~|~attack(%VAR%); sfxdamage(null|%VAR%);~|target|self|2|d);  sfx(~_thinghappens~); },Drunken Boxing,NORMAL,,YELLOW,change_power,change_power,,,,,,excludefromrandomlists,,,,,,,if(e.hastag(~makeunavailable~)) { e.removetag(~makeunavailable~); e.availablenextturn = false; },,if(d == 6) { e.availablenextturn = false; e.addtag(~makeunavailable~); },,,
Throwing Axe_upgraded,Do [sword]<d6> damage. On 4-6[;]|do [sword]<d6> again in 2 turns[;] but|make unavailable next turn,2,attack(d); sfxdamage(target|d); if(d >= 4 && d <= 6) { e.availablenextturn = false; jinx(~Throwing Axe+~|~take [sword]%VAR% damage~|~Take [sword]%VAR% damage~|~attack(%VAR%); sfxdamage(null|%VAR%);~|target|self|2|d);  sfx(~_thinghappens~); },Drunken Boxing,NORMAL,,YELLOW,,,,,,,,excludefromrandomlists,,,,,,,,,,,,
Throwing Axe_downgraded,Do [sword]<d6> damage,2,attack(d); sfxdamage(target|d);,Drunken Boxing,NORMAL,,YELLOW,,,,,,,,excludefromrandomlists,,,,,,,,,,,,
Spear,Do [sword]<d6> damage|Get a new dice,1,attack(d); sfxdamage(target|d); givedice(); /*my attempt at coming up with a generic 'spear' item. the original spear after which starspear; magic spear; etc. are named was renamed six shooter*/,Focus,REQUIRE6,,RED,increaserange,change_power,,,,,,,2,,,,,,,,,,,
Spear_downgraded,Do [sword]<d6> damage,1,attack(d); sfxdamage(target|d);,Focus,REQUIRE6,,RED,,,,,,,,,,,,,,,,,,,,
Reckless Piracy,Do [sword]<double> damage[;] but next|turn[;] [lock]Ransom a random card,1,jinx(~Reckless Piracy~|~[lock]Ransom an equipment~|~[lock]Ransom an equipment~|~sfx(\~_lock\~); inflict(\~ncr_ransom\~ + rand([1|2|3|4|5|6]));~|self|self|1|1); sfx(~_thinghappens~); sfx(~_lock~); attack(d * 2); sfxdamage(target|d * 2); /*https://github.com/TerryCavanagh/diceydungeons.com/issues/1857 - i *can* just manually copy and paste the script for ransomed into each different ransom status effect; but that would be unnecessary if this small bug just gets fixed*/,Copyright Strike,MAX5,,GRAY,increaserange,complicate,,,,,,excludefromrandomlists|unfinished,,,,,,,,,,,,
Ground Wire,Do [weaken]<d6> dmg. If CPU is <double>|or more[;] reduce it by <d6>,1,attack(d|WEAKEN); sfxdamage(target|d); sfx(~_weaken~|~~|0.2); if(self.roll_total >= d * 2 && self.roll_jackpot == 0) { adjustrobotcounter(-d); },Guitar Solo,NORMAL,,ORANGE,change_power,change_power,,none,0,,,robotonly,,if(self.roll_total >= d * 2 && self.roll_jackpot == 0) { adjustrobotcounter(-d); },,,,,,,,,,
Ground Wire_upgraded,Do [weaken]<d6> dmg. If CPU >=|<double>[;] reduce it by <d6>,1,attack(d|WEAKEN); sfxdamage(target|d); sfx(~_weaken~|~~|0.2); if(self.roll_total >= d * 2 && self.roll_jackpot == 0) { adjustrobotcounter(-d); },Guitar Solo,NORMAL|FREE2,,ORANGE,,,,none,0,,,robotonly,,if(self.roll_total >= d * 2 && self.roll_jackpot == 0) { adjustrobotcounter(-d); },,,,,,,,,,
Ground Wire_downgraded,Do [weaken]<d6> dmg. If CPU is <double>|exactly[;] reduce it by <d6>,1,attack(d|WEAKEN); sfxdamage(target|d); sfx(~_weaken~|~~|0.2); if(self.roll_total == d * 2 && self.roll_jackpot == 0) { adjustrobotcounter(-d); },Guitar Solo,NORMAL,,ORANGE,,,,none,0,,,robotonly,,if(self.roll_total == d * 2 && self.roll_jackpot == 0) { adjustrobotcounter(-d); },,,,,,,,,,
Radio Dial,Change your gadget to|the gadget of the last|equipment you used,2,if(self.equipmenthistory.length > 1 && self.getskillcard().skillcard == ~inventor~) { var newgadget = self.equipmenthistory[self.equipmenthistory.length - 2].gadget; Gadget.changegadget(self| Gadget.getcurrentgadget(self) |newgadget); Gadget.reactivate(self| Gadget.getcurrentgadget(self)); var dogadgetstuff = new elements.Skill(~Against all odds_old~); dogadgetstuff.script = self.getskillcard().scriptbeforestartturn; dogadgetstuff.execute(self|target); dogadgetstuff.script = self.getskillcard().scriptbeforestartturn; dogadgetstuff.execute(self|target); } else { self.textparticle(~No effect!~); },Super Hexahedron,REQUIRE5,,GRAY,simplify,doublerequirements,,,,YES,,excludefromrandomlists|inventoronly,,,,,,,,,,,,
Equipment That Does Nothing,Equipment That Does Nothing,1,self.equipmentused--; self.equipmenthistory.pop();,,NORMAL,,,,,,,,YES,,excludefromrandomlists|cannotsteal|weakenavoid|shockavoid|altpoisonavoid|curseavoid|internal,,,,,,,,,,,e.maintainfury = true; e.preventdefault = true;,
Wand of Wishing,Replace this with whatever|item you can name,2,bonus(-9999999999999); if(!self.isplayer) self.textparticle(~No effect!~); else if(!simulation) {  var selfscript = ~removeequipment(\~Equipment That Does Nothing\~);~; if(self.scriptendturn.indexOf(selfscript) == -1) self.scriptendturn = selfscript + self.scriptendturn;  self.setvar(~wishingcard~|e);  var diceavailable = false;  if(self.dicepool.length > 0) for(dice in self.dicepool) if(dice.available()) { diceavailable = true; break; }  if(self.equipment.length > 0) for(eq in self.equipment) if(eq.ready && eq.assigneddice.length > 0) for(dice in eq.assigneddice) if(dice != null && dice.available()) { diceavailable = true; break; }  if(!diceavailable) { givedice(1); self.setvar(~lendeddice~|1); }  self.setvar(~slotsbackup~|[]);  self.setvar(~slotseqbackup~|[]);  self.setvar(~shockslotseqbackup~|[]);  self.setvar(~skillsbackup~|[]);  var slotsbackup = self.getvar(~slotsbackup~);  var slotseqbackup = self.getvar(~slotseqbackup~);  var shockslotseqbackup = self.getvar(~shockslotseqbackup~);  var skillsbackup = self.getvar(~skillsbackup~);  for(eq in self.equipment) {   eq.setvar(~standardcard~|1);   eq.removedice();   slotsbackup.push(eq.slots);   shockslotseqbackup.push(eq.shocked_slots);   slotseqbackup.push(eq);   eq.slots = [];   eq.shocked_slots = [];   skillsbackup.push(eq.skillsavailable.copy());   trace(eq.name);   trace(eq.skillsavailable);   trace(eq.skillsavailable.length);   if(eq.skillsavailable.length > 0) { trace(~this has skills~); for(skill in eq.skillsavailable) { trace(~making skill false~); eq.skillsavailable[eq.skillsavailable.indexOf(skill)] = false; } }   trace(eq.skillsavailable);  }    self.setvar(~slotsbackup~|slotsbackup);  self.setvar(~slotseqbackup~|slotseqbackup);  self.setvar(~shockslotseqbackup~|shockslotseqbackup);  self.setvar(~skillsbackup~|skillsbackup);  self.setvar(~selfstatusbackup~|self.status.copy());  self.setvar(~targetstatusbackup~|target.status.copy());   if(self.usecpuinsteadofdice) { self.setvar(~rolljackpot~|self.roll_jackpot); self.roll_jackpot = -1; /*thx to cody for this bit*/ }   var buttonx = 100;  var buttony = 400;   var charlist = [~A~|~B~|~C~|~D~|~E~|~F~|~G~|~H~|~I~|~J~|~K~|~L~|~M~|~N~|~O~|~P~|~Q~|~R~|~S~|~T~|~U~|~V~|~W~|~X~|~Y~|~Z~|~a~|~b~|~c~|~d~|~e~|~f~|~g~|~h~|~i~|~j~|~k~|~l~|~m~|~n~|~o~|~p~|~q~|~r~|~s~|~t~|~u~|~v~|~w~|~x~|~y~|~z~|~'~|~_~|~@~|~1~|~2~|~3~|~4~|~5~|~6~|~7~|~8~|~9~|~0~|~.~|~?~|~!~|~Bkspace~|~Confirm~];    self.setvar(~wandwish~|~[200%]~);   var i = 0;    for(char in charlist) {   i++;   var charholder = new elements.Equipment(~Equipment That Does Nothing~);   self.equipment.push(charholder);   charholder.script = ~self.equipmentused--;~;   charholder.slotpositions[0].y -= 153;   charholder.slotpositions[0].x -= 260;   charholder.displayname = char;   charholder.equipmentcol = 0;   if(char == char.toLowerCase() && char.toLowerCase() != char.toUpperCase()) charholder.displayname = ~[70%]~ + charholder.displayname;   if(charholder.displayname == ~Confirm~ # charholder.displayname == ~Bkspace~) charholder.equipmentcol = 2;   charholder.fulldescription = ~~;   charholder.height = 270;   charholder.width = 270;   charholder.x = buttonx;   charholder.y = buttony;   charholder.equipalpha = 0.0;   buttonx += 270;   if(i == 13) {    buttonx = 160;    buttony += 270;   }   if(i == 26) {    buttonx = 100;    buttony += 300;   }   if(i == 39) {    buttonx = 160;    buttony += 270;   }   if(i == 52) {    buttonx = 100;    buttony += 300;   }   if(i == 65) {    buttonx = 1620;    buttony += 270;   }  }   var tw = new motion.actuators.SimpleActuator(null|1/60|null);  tw._repeat = -1;  var s = new elements.Skill(~Against all odds_old~);   s.script = ~   var phonedone = false;   var wandwish = self.getvar(\~wandwish\~);   for(eq in self.equipment) {    if(self.getvar(\~phonephase2\~) != 1) {     if(eq.equipalpha > 0.0 && eq.getvar(\~standardcard\~) == 1) eq.equipalpha -= 0.2;     if(eq.equipalpha < 1.0 && eq.getvar(\~standardcard\~) != 1) eq.equipalpha += 0.2;     if(eq.assigneddice.length > 0 && eq.assigneddice[0] != null) {      eq.removedice();      var neweq = eq.copy();          neweq.height = 270;      neweq.width = 270;      neweq.equipalpha = eq.equipalpha;      neweq.displayname = eq.displayname;      neweq.equipmentcol = eq.equipmentcol;      neweq.slotpositions = eq.slotpositions;      neweq.script = eq.script;      self.equipment.push(neweq);      eq.name = \~deleteme\~;      eq.slots = [];      eq.equipalpha = 0;      if(eq.displayname != \~Confirm\~) {       sfx(\~jackpot_increasecounter\~);       if(eq.displayname == \~Bkspace\~ && wandwish.length > 6) wandwish = wandwish.substr(0|wandwish.length - 1);       else       if(eq.displayname.substr(0|1) == \~_\~) wandwish += \~_\~;       else       if(eq.displayname.substr(0|1) == \~[\~) wandwish += eq.displayname.substr(5|1);       else       if(eq.displayname != \~Bkspace\~) wandwish += eq.displayname.substr(0|1);      }      else {       sfx(\~_thinghappens\~);       self.setvar(\~phonephase2\~|1);      }     }    }    else {     if(eq.equipalpha <= 1.0 && eq.getvar(\~standardcard\~) == 1) {      eq.equipalpha += 0.2;     }     if(eq.equipalpha > 0.0 && eq.getvar(\~standardcard\~) != 1) {      eq.removedice();      eq.equipalpha -= 0.2;      eq.slots = [];      eq.script = \~self.equipmentused--; self.equipmenthistory.pop();\~;     }     if(eq.equipalpha <= 0.0 && eq.getvar(\~standardcard\~) != 1) {      eq.name = \~deleteme\~;      phonedone = true;     }    }   }      new elements.CombatCommand(\~msg\~|wandwish).execute();   self.setvar(\~wandwish\~|wandwish);      removeequipment(\~deleteme\~);   if(self.doendturnnow) {    trace(\~ending turn\~);    for(eq in self.equipment) {     if(eq.getvar(\~standardcard\~) == 1) {      eq.equipalpha = 1.0;      var importantindex = self.getvar(\~slotseqbackup\~).indexOf(eq);      eq.slots = self.getvar(\~slotsbackup\~)[importantindex];      eq.shocked_slots = self.getvar(\~shockslotseqbackup\~)[importantindex];      eq.skillsavailable = self.getvar(\~skillsbackup\~)[importantindex];      if(self.usecpuinsteadofdice) self.roll_jackpot = self.getvar(\~rolljackpot\~);     }     else {      eq.name = \~deleteme\~;     }    }    removeequipment(\~deleteme\~);    removeequipment(\~Equipment That Does Nothing\~);    self.resetvar(\~slotsbackup\~);    self.resetvar(\~slotseqbackup\~);    self.resetvar(\~shockslotseqbackup\~);    self.resetvar(\~skillsbackup\~);    self.resetvar(\~rolljackpot\~);    new elements.CombatCommand(\~msg\~|\~\~).execute();    wandwish = wandwish.split(\~[200%]\~)[1].split(\~_\~).join(\~ \~);    var exceptions = getcolumn(loaddata(\~ncrmod/wishredirects\~)|\~input\~);    var redirects = getcolumn(loaddata(\~ncrmod/wishredirects\~)|\~redirect\~);    if(exceptions.indexOf(wandwish) != -1) wandwish = redirects[exceptions.indexOf(wandwish)];    if(getequipmentlist().indexOf(wandwish) != -1) {     if(self.getvar(\~ncrrobotepisode4\~) == 1 && self.getvar(\~ncrrobotepisode4wishlist\~).indexOf(wandwish) != -1) { self.textparticle(\~Already wished!\~); }     else {      if(self.getvar(\~ncrrobotepisode4\~) == 1) {       self.setvar(\~ncrrobotepisode4wishlist\~|self.getvar(\~ncrrobotepisode4wishlist\~).concat([wandwish]));       var familylist = loadtext(\~ncrmod/wishfamilies\~);       for(i in 0...familylist.length)  {        var familylistsplit = familylist[i].split(\~|\~);        if(familylistsplit.indexOf(wandwish) != -1) {         self.setvar(\~ncrrobotepisode4wishlist\~|self.getvar(\~ncrrobotepisode4wishlist\~).concat(familylistsplit));        }       }       if(!new elements.Equipment(wandwish).hastag(\~powercard\~)) {        if(wandwish.substr(wandwish.length - 1|1) == \~?\~) {         self.setvar(\~ncrrobotepisode4wishlist\~|self.getvar(\~ncrrobotepisode4wishlist\~).concat([wandwish.substr(0|wandwish.length - 1)]));        }        else {         self.setvar(\~ncrrobotepisode4wishlist\~|self.getvar(\~ncrrobotepisode4wishlist\~).concat([wandwish + \~?\~]));        }       }      }      var newcard = new elements.Equipment(wandwish);      var replacecard = self.equipment[self.equipment.indexOf(self.getvar(\~wishingcard\~))];      trace(\~card made\~);      newcard.x = self.getvar(\~wishingcardx\~);      newcard.y = self.getvar(\~wishingcardy\~);      self.equipment[self.equipment.indexOf(self.getvar(\~wishingcard\~))] = newcard;      trace(\~card replaced\~);      newcard.animate(\~flashandshake\~);      self.setvar(\~doonthis\~|newcard); var estandardize = \~var e = self.getvar(\\\~doonthis\\\~); \~; var doscripts = new elements.Skill(\~Against all odds_old\~); doscripts.script = estandardize + newcard.scriptbeforecombat; doscripts.execute(self|target); doscripts.script = estandardize + newcard.scriptbeforestartturn; doscripts.execute(self|target); doscripts.script = estandardize + newcard.scriptonstartturn; doscripts.execute(self|target); self.resetvar(\~doonthis\~);      newcard.arrangeslots();      self.createsparedice(newcard);      trace(\~card flashed\~);     }    }    else self.textparticle(\~Invalid wish!\~);    self.resetvar(\~wishingcard\~); self.resetvar(\~diditwork\~);    self.getvar(\~wishactuator\~).stop();    self.status = self.getvar(\~selfstatusbackup\~);    target.status = self.getvar(\~targetstatusbackup\~);    self.resetvar(\~selfstatusbackup\~);    self.resetvar(\~targetstatusbackup\~);    self.resetvar(\~phonephase2\~);    self.resetvar(\~wishactuator\~);    self.resetvar(\~wandwish\~);    if(self.getvar(\~lendeddice\~) == 1) { for(dice in self.dicepool) { if(dice.available() && dice.basevalue == 1) { dice.animate(\~disappear\~); break; } } }    self.resetvar(\~lendeddice\~);   }      if(phonedone) {    for(eq in self.equipment) {     if(eq.getvar(\~standardcard\~) == 1) {      eq.equipalpha = 1.0;      var importantindex = self.getvar(\~slotseqbackup\~).indexOf(eq);      eq.slots = self.getvar(\~slotsbackup\~)[importantindex];      eq.shocked_slots = self.getvar(\~shockslotseqbackup\~)[importantindex];      eq.skillsavailable = self.getvar(\~skillsbackup\~)[importantindex];      if(self.usecpuinsteadofdice) self.roll_jackpot = self.getvar(\~rolljackpot\~);     }    }    removeequipment(\~Equipment That Does Nothing\~);    self.resetvar(\~slotsbackup\~);    self.resetvar(\~slotseqbackup\~);    self.resetvar(\~shockslotseqbackup\~);    self.resetvar(\~skillsbackup\~);    self.resetvar(\~rolljackpot\~);    new elements.CombatCommand(\~msg\~|\~\~).execute();    wandwish = wandwish.split(\~[200%]\~)[1].split(\~_\~).join(\~ \~);    var exceptions = getcolumn(loaddata(\~ncrmod/wishredirects\~)|\~input\~);    var redirects = getcolumn(loaddata(\~ncrmod/wishredirects\~)|\~redirect\~);    if(exceptions.indexOf(wandwish) != -1) wandwish = redirects[exceptions.indexOf(wandwish)];    if(getequipmentlist().indexOf(wandwish) != -1) {     if(self.getvar(\~ncrrobotepisode4\~) == 1 && self.getvar(\~ncrrobotepisode4wishlist\~).indexOf(wandwish) != -1) { self.textparticle(\~Already wished!\~); }     else {      if(self.getvar(\~ncrrobotepisode4\~) == 1) {       self.setvar(\~ncrrobotepisode4wishlist\~|self.getvar(\~ncrrobotepisode4wishlist\~).concat([wandwish]));       var familylist = loadtext(\~ncrmod/wishfamilies\~);       for(i in 0...familylist.length)  {        var familylistsplit = familylist[i].split(\~|\~);        if(familylistsplit.indexOf(wandwish) != -1) {         self.setvar(\~ncrrobotepisode4wishlist\~|self.getvar(\~ncrrobotepisode4wishlist\~).concat(familylistsplit));        }       }       if(!new elements.Equipment(wandwish).hastag(\~powercard\~)) {        if(wandwish.substr(wandwish.length - 1|1) == \~?\~) {         self.setvar(\~ncrrobotepisode4wishlist\~|self.getvar(\~ncrrobotepisode4wishlist\~).concat([wandwish.substr(0|wandwish.length - 1)]));        }        else {         self.setvar(\~ncrrobotepisode4wishlist\~|self.getvar(\~ncrrobotepisode4wishlist\~).concat([wandwish + \~?\~]));        }       }      }      var newcard = new elements.Equipment(wandwish);      var replacecard = self.equipment[self.equipment.indexOf(self.getvar(\~wishingcard\~))];      trace(\~card made\~);      newcard.x = self.getvar(\~wishingcardx\~);      newcard.y = self.getvar(\~wishingcardy\~);      self.equipment[self.equipment.indexOf(self.getvar(\~wishingcard\~))] = newcard;      trace(\~card replaced\~);      newcard.animate(\~flashandshake\~);      self.setvar(\~doonthis\~|newcard); var estandardize = \~var e = self.getvar(\\\~doonthis\\\~); \~; var doscripts = new elements.Skill(\~Against all odds_old\~); doscripts.script = estandardize + newcard.scriptbeforecombat; doscripts.execute(self|target); doscripts.script = estandardize + newcard.scriptbeforestartturn; doscripts.execute(self|target); doscripts.script = estandardize + newcard.scriptonstartturn; doscripts.execute(self|target); self.resetvar(\~doonthis\~);      newcard.arrangeslots();      self.createsparedice(newcard);      trace(\~card flashed\~);     }    }    else self.textparticle(\~Invalid wish!\~);    self.resetvar(\~wishingcard\~); self.resetvar(\~diditwork\~);    self.getvar(\~wishactuator\~).stop();    self.status = self.getvar(\~selfstatusbackup\~);    target.status = self.getvar(\~targetstatusbackup\~);    self.resetvar(\~selfstatusbackup\~);    self.resetvar(\~targetstatusbackup\~);    self.resetvar(\~phonephase2\~);    self.resetvar(\~wishactuator\~);    self.resetvar(\~wandwish\~);    if(self.getvar(\~lendeddice\~) == 1) { for(dice in self.dicepool) { if(dice.available() && dice.basevalue == 1) { dice.animate(\~disappear\~); break; } } }    self.resetvar(\~lendeddice\~);   }  ~;  tw.onRepeat(s.execute|[self|target]);  self.setvar(~wishactuator~|tw);  tw.move(); },Best Friend,REQUIRE5|REQUIRE5,,BRIGHTCYAN,change_power,change_power,,,,YES,,excludefromrandomlists|cannotsteal,,,,,,,,,self.setvar(~wishingcardx~|e.x); self.setvar(~wishingcardy~|e.y);,,e.maintainfury = true; e.preventdefault = true;,
Wand of Wishing_upgraded,Replace this with whatever|upgraded item you can name,2,bonus(-9999999999999); if(!self.isplayer) self.textparticle(~No effect!~); else if(!simulation) {  var selfscript = ~removeequipment(\~Equipment That Does Nothing\~);~; if(self.scriptendturn.indexOf(selfscript) == -1) self.scriptendturn = selfscript + self.scriptendturn;  self.setvar(~wishingcard~|e);  var diceavailable = false;  if(self.dicepool.length > 0) for(dice in self.dicepool) if(dice.available()) { diceavailable = true; break; }  if(self.equipment.length > 0) for(eq in self.equipment) if(eq.ready && eq.assigneddice.length > 0) for(dice in eq.assigneddice) if(dice != null && dice.available()) { diceavailable = true; break; }  if(!diceavailable) { givedice(1); self.setvar(~lendeddice~|1); }  self.setvar(~slotsbackup~|[]);  self.setvar(~slotseqbackup~|[]);  self.setvar(~shockslotseqbackup~|[]);  self.setvar(~skillsbackup~|[]);  var slotsbackup = self.getvar(~slotsbackup~);  var slotseqbackup = self.getvar(~slotseqbackup~);  var shockslotseqbackup = self.getvar(~shockslotseqbackup~);  var skillsbackup = self.getvar(~skillsbackup~);  for(eq in self.equipment) {   eq.setvar(~standardcard~|1);   eq.removedice();   slotsbackup.push(eq.slots);   shockslotseqbackup.push(eq.shocked_slots);   slotseqbackup.push(eq);   eq.slots = [];   eq.shocked_slots = [];   skillsbackup.push(eq.skillsavailable.copy());   trace(eq.name);   trace(eq.skillsavailable);   trace(eq.skillsavailable.length);   if(eq.skillsavailable.length > 0) { trace(~this has skills~); for(skill in eq.skillsavailable) { trace(~making skill false~); eq.skillsavailable[eq.skillsavailable.indexOf(skill)] = false; } }   trace(eq.skillsavailable);  }    self.setvar(~slotsbackup~|slotsbackup);  self.setvar(~slotseqbackup~|slotseqbackup);  self.setvar(~shockslotseqbackup~|shockslotseqbackup);  self.setvar(~skillsbackup~|skillsbackup);  self.setvar(~selfstatusbackup~|self.status.copy());  self.setvar(~targetstatusbackup~|target.status.copy());   if(self.usecpuinsteadofdice) { self.setvar(~rolljackpot~|self.roll_jackpot); self.roll_jackpot = -1; /*thx to cody for this bit*/ }   var buttonx = 100;  var buttony = 400;   var charlist = [~A~|~B~|~C~|~D~|~E~|~F~|~G~|~H~|~I~|~J~|~K~|~L~|~M~|~N~|~O~|~P~|~Q~|~R~|~S~|~T~|~U~|~V~|~W~|~X~|~Y~|~Z~|~a~|~b~|~c~|~d~|~e~|~f~|~g~|~h~|~i~|~j~|~k~|~l~|~m~|~n~|~o~|~p~|~q~|~r~|~s~|~t~|~u~|~v~|~w~|~x~|~y~|~z~|~'~|~_~|~@~|~1~|~2~|~3~|~4~|~5~|~6~|~7~|~8~|~9~|~0~|~.~|~?~|~!~|~Bkspace~|~Confirm~];    self.setvar(~wandwish~|~[200%]~);   var i = 0;    for(char in charlist) {   i++;   var charholder = new elements.Equipment(~Equipment That Does Nothing~);   self.equipment.push(charholder);   charholder.script = ~self.equipmentused--;~;   charholder.slotpositions[0].y -= 153;   charholder.slotpositions[0].x -= 260;   charholder.displayname = char;   charholder.equipmentcol = 0;   if(char == char.toLowerCase() && char.toLowerCase() != char.toUpperCase()) charholder.displayname = ~[70%]~ + charholder.displayname;   if(charholder.displayname == ~Confirm~ # charholder.displayname == ~Bkspace~) charholder.equipmentcol = 2;   charholder.fulldescription = ~~;   charholder.height = 270;   charholder.width = 270;   charholder.x = buttonx;   charholder.y = buttony;   charholder.equipalpha = 0.0;   buttonx += 270;   if(i == 13) {    buttonx = 160;    buttony += 270;   }   if(i == 26) {    buttonx = 100;    buttony += 300;   }   if(i == 39) {    buttonx = 160;    buttony += 270;   }   if(i == 52) {    buttonx = 100;    buttony += 300;   }   if(i == 65) {    buttonx = 1620;    buttony += 270;   }  }   var tw = new motion.actuators.SimpleActuator(null|1/60|null);  tw._repeat = -1;  var s = new elements.Skill(~Against all odds_old~);   s.script = ~   var phonedone = false;   var wandwish = self.getvar(\~wandwish\~);   for(eq in self.equipment) {    if(self.getvar(\~phonephase2\~) != 1) {     if(eq.equipalpha > 0.0 && eq.getvar(\~standardcard\~) == 1) eq.equipalpha -= 0.2;     if(eq.equipalpha < 1.0 && eq.getvar(\~standardcard\~) != 1) eq.equipalpha += 0.2;     if(eq.assigneddice.length > 0 && eq.assigneddice[0] != null) {      eq.removedice();      var neweq = eq.copy();          neweq.height = 270;      neweq.width = 270;      neweq.equipalpha = eq.equipalpha;      neweq.displayname = eq.displayname;      neweq.equipmentcol = eq.equipmentcol;      neweq.slotpositions = eq.slotpositions;      neweq.script = eq.script;      self.equipment.push(neweq);      eq.name = \~deleteme\~;      eq.slots = [];      eq.equipalpha = 0;      if(eq.displayname != \~Confirm\~) {       sfx(\~jackpot_increasecounter\~);       if(eq.displayname == \~Bkspace\~ && wandwish.length > 6) wandwish = wandwish.substr(0|wandwish.length - 1);       else       if(eq.displayname.substr(0|1) == \~_\~) wandwish += \~_\~;       else       if(eq.displayname.substr(0|1) == \~[\~) wandwish += eq.displayname.substr(5|1);       else       if(eq.displayname != \~Bkspace\~) wandwish += eq.displayname.substr(0|1);      }      else {       sfx(\~_thinghappens\~);       self.setvar(\~phonephase2\~|1);      }     }    }    else {     if(eq.equipalpha <= 1.0 && eq.getvar(\~standardcard\~) == 1) {      eq.equipalpha += 0.2;     }     if(eq.equipalpha > 0.0 && eq.getvar(\~standardcard\~) != 1) {      eq.removedice();      eq.equipalpha -= 0.2;      eq.slots = [];      eq.script = \~self.equipmentused--; self.equipmenthistory.pop();\~;     }     if(eq.equipalpha <= 0.0 && eq.getvar(\~standardcard\~) != 1) {      eq.name = \~deleteme\~;      phonedone = true;     }    }   }      new elements.CombatCommand(\~msg\~|wandwish + \~+\~).execute();   self.setvar(\~wandwish\~|wandwish);      removeequipment(\~deleteme\~);   if(self.doendturnnow) {    trace(\~ending turn\~);    for(eq in self.equipment) {     if(eq.getvar(\~standardcard\~) == 1) {      eq.equipalpha = 1.0;      var importantindex = self.getvar(\~slotseqbackup\~).indexOf(eq);      eq.slots = self.getvar(\~slotsbackup\~)[importantindex];      eq.shocked_slots = self.getvar(\~shockslotseqbackup\~)[importantindex];      eq.skillsavailable = self.getvar(\~skillsbackup\~)[importantindex];      if(self.usecpuinsteadofdice) self.roll_jackpot = self.getvar(\~rolljackpot\~);     }     else {      eq.name = \~deleteme\~;     }    }    removeequipment(\~deleteme\~);    removeequipment(\~Equipment That Does Nothing\~);    self.resetvar(\~slotsbackup\~);    self.resetvar(\~slotseqbackup\~);    self.resetvar(\~shockslotseqbackup\~);    self.resetvar(\~skillsbackup\~);    self.resetvar(\~rolljackpot\~);    new elements.CombatCommand(\~msg\~|\~\~).execute();    wandwish = wandwish.split(\~[200%]\~)[1].split(\~_\~).join(\~ \~);    var exceptions = getcolumn(loaddata(\~ncrmod/wishredirects\~)|\~input\~);    var redirects = getcolumn(loaddata(\~ncrmod/wishredirects\~)|\~redirect\~);    if(exceptions.indexOf(wandwish) != -1) wandwish = redirects[exceptions.indexOf(wandwish)];    var wrong = false;    var newcard = null;    if(getequipmentlist().indexOf(wandwish) != -1) {     if(self.getvar(\~ncrrobotepisode4\~) == 1 && self.getvar(\~ncrrobotepisode4wishlist\~).indexOf(wandwish) != -1) { self.textparticle(\~Already wished!\~); wrong = true; }     else {      newcard = new elements.Equipment(wandwish);      if(newcard.upgradetype == \~\~) { newcard.name = \~Equipment That Does Nothing\~; self.equipment.push(newcard); removeequipment(\~Equipment That Does Nothing\~); wrong = true; }     }    }    else { wrong = true; }    if(!wrong) {     if(self.getvar(\~ncrrobotepisode4\~) == 1) {      self.setvar(\~ncrrobotepisode4wishlist\~|self.getvar(\~ncrrobotepisode4wishlist\~).concat([wandwish]));      var familylist = loadtext(\~ncrmod/wishfamilies\~);      for(i in 0...familylist.length)  {       familylist[i] = familylist[i].split(\~|\~);       if(familylistsplit.indexOf(wandwish) != -1) {        self.setvar(\~ncrrobotepisode4wishlist\~|self.getvar(\~ncrrobotepisode4wishlist\~).concat(familylistsplit));       }      }      if(!new elements.Equipment(wandwish).hastag(\~powercard\~)) {       if(wandwish.substr(wandwish.length - 1|1) == \~?\~) {        self.setvar(\~ncrrobotepisode4wishlist\~|self.getvar(\~ncrrobotepisode4wishlist\~).concat([wandwish.substr(0|wandwish.length - 1)]));       }       else {        self.setvar(\~ncrrobotepisode4wishlist\~|self.getvar(\~ncrrobotepisode4wishlist\~).concat([wandwish + \~?\~]));       }      }     }     newcard = new elements.Equipment(wandwish + \~+\~);     var replacecard = self.equipment[self.equipment.indexOf(self.getvar(\~wishingcard\~))];     trace(\~card made\~);     newcard.x = self.getvar(\~wishingcardx\~);     newcard.y = self.getvar(\~wishingcardy\~);     self.equipment[self.equipment.indexOf(self.getvar(\~wishingcard\~))] = newcard;     trace(\~card replaced\~);     newcard.animate(\~flashandshake\~);     self.setvar(\~doonthis\~|newcard); var estandardize = \~var e = self.getvar(\\\~doonthis\\\~); \~; var doscripts = new elements.Skill(\~Against all odds_old\~); doscripts.script = estandardize + newcard.scriptbeforecombat; doscripts.execute(self|target); doscripts.script = estandardize + newcard.scriptbeforestartturn; doscripts.execute(self|target); doscripts.script = estandardize + newcard.scriptonstartturn; doscripts.execute(self|target); self.resetvar(\~doonthis\~);     newcard.arrangeslots();     self.createsparedice(newcard);     trace(\~card flashed\~);    }    else self.textparticle(\~Invalid wish!\~);    self.resetvar(\~wishingcard\~); self.resetvar(\~diditwork\~);    self.getvar(\~wishactuator\~).stop();    self.status = self.getvar(\~selfstatusbackup\~);    target.status = self.getvar(\~targetstatusbackup\~);    self.resetvar(\~selfstatusbackup\~);    self.resetvar(\~targetstatusbackup\~);    self.resetvar(\~phonephase2\~);    self.resetvar(\~wishactuator\~);    self.resetvar(\~wandwish\~);    if(self.getvar(\~lendeddice\~) == 1) { for(dice in self.dicepool) { if(dice.available() && dice.basevalue == 1) { dice.animate(\~disappear\~); break; } } }    self.resetvar(\~lendeddice\~);   }      if(phonedone) {    for(eq in self.equipment) {     if(eq.getvar(\~standardcard\~) == 1) {      eq.equipalpha = 1.0;      var importantindex = self.getvar(\~slotseqbackup\~).indexOf(eq);      eq.slots = self.getvar(\~slotsbackup\~)[importantindex];      eq.shocked_slots = self.getvar(\~shockslotseqbackup\~)[importantindex];      eq.skillsavailable = self.getvar(\~skillsbackup\~)[importantindex];      if(self.usecpuinsteadofdice) self.roll_jackpot = self.getvar(\~rolljackpot\~);     }    }    removeequipment(\~Equipment That Does Nothing\~);    self.resetvar(\~slotsbackup\~);    self.resetvar(\~slotseqbackup\~);    self.resetvar(\~shockslotseqbackup\~);    self.resetvar(\~skillsbackup\~);    self.resetvar(\~rolljackpot\~);    new elements.CombatCommand(\~msg\~|\~\~).execute();    wandwish = wandwish.split(\~[200%]\~)[1].split(\~_\~).join(\~ \~);    var exceptions = getcolumn(loaddata(\~ncrmod/wishredirects\~)|\~input\~);    var redirects = getcolumn(loaddata(\~ncrmod/wishredirects\~)|\~redirect\~);    if(exceptions.indexOf(wandwish) != -1) wandwish = redirects[exceptions.indexOf(wandwish)];    var wrong = false;    var newcard = null;    if(getequipmentlist().indexOf(wandwish) != -1) {     if(self.getvar(\~ncrrobotepisode4\~) == 1 && self.getvar(\~ncrrobotepisode4wishlist\~).indexOf(wandwish) != -1) { self.textparticle(\~Already wished!\~); wrong = true; }     else {      newcard = new elements.Equipment(wandwish);      if(newcard.upgradetype == \~\~) { newcard.name = \~Equipment That Does Nothing\~; self.equipment.push(newcard); removeequipment(\~Equipment That Does Nothing\~); wrong = true; }     }    }    else { wrong = true; }    if(!wrong) {     if(self.getvar(\~ncrrobotepisode4\~) == 1) {      self.setvar(\~ncrrobotepisode4wishlist\~|self.getvar(\~ncrrobotepisode4wishlist\~).concat([wandwish]));      var familylist = loadtext(\~ncrmod/wishfamilies\~);      for(i in 0...familylist.length)  {       var familylistsplit = familylist[i].split(\~|\~);       if(familylistsplit.indexOf(wandwish) != -1) {        self.setvar(\~ncrrobotepisode4wishlist\~|self.getvar(\~ncrrobotepisode4wishlist\~).concat(familylistsplit));       }      }      if(!new elements.Equipment(wandwish).hastag(\~powercard\~)) {       if(wandwish.substr(wandwish.length - 1|1) == \~?\~) {        self.setvar(\~ncrrobotepisode4wishlist\~|self.getvar(\~ncrrobotepisode4wishlist\~).concat([wandwish.substr(0|wandwish.length - 1)]));       }       else {        self.setvar(\~ncrrobotepisode4wishlist\~|self.getvar(\~ncrrobotepisode4wishlist\~).concat([wandwish + \~?\~]));       }      }     }     newcard = new elements.Equipment(wandwish + \~+\~);     var replacecard = self.equipment[self.equipment.indexOf(self.getvar(\~wishingcard\~))];     trace(\~card made\~);     newcard.x = self.getvar(\~wishingcardx\~);     newcard.y = self.getvar(\~wishingcardy\~);     self.equipment[self.equipment.indexOf(self.getvar(\~wishingcard\~))] = newcard;     trace(\~card replaced\~);     newcard.animate(\~flashandshake\~);     self.setvar(\~doonthis\~|newcard); var estandardize = \~var e = self.getvar(\\\~doonthis\\\~); \~; var doscripts = new elements.Skill(\~Against all odds_old\~); doscripts.script = estandardize + newcard.scriptbeforecombat; doscripts.execute(self|target); doscripts.script = estandardize + newcard.scriptbeforestartturn; doscripts.execute(self|target); doscripts.script = estandardize + newcard.scriptonstartturn; doscripts.execute(self|target); self.resetvar(\~doonthis\~);     newcard.arrangeslots();     self.createsparedice(newcard);     trace(\~card flashed\~);    }    else self.textparticle(\~Invalid wish!\~);    self.resetvar(\~wishingcard\~); self.resetvar(\~diditwork\~);    self.getvar(\~wishactuator\~).stop();    self.status = self.getvar(\~selfstatusbackup\~);    target.status = self.getvar(\~targetstatusbackup\~);    self.resetvar(\~selfstatusbackup\~);    self.resetvar(\~targetstatusbackup\~);    self.resetvar(\~phonephase2\~);    self.resetvar(\~wishactuator\~);    self.resetvar(\~wandwish\~);    if(self.getvar(\~lendeddice\~) == 1) { for(dice in self.dicepool) { if(dice.available() && dice.basevalue == 1) { dice.animate(\~disappear\~); break; } } }    self.resetvar(\~lendeddice\~);   }  ~;  tw.onRepeat(s.execute|[self|target]);  self.setvar(~wishactuator~|tw);  tw.move(); },Best Friend,REQUIRE5|REQUIRE5,,BRIGHTCYAN,,,,,,YES,,excludefromrandomlists|cannotsteal,,,,,,,,,self.setvar(~wishingcardx~|e.x); self.setvar(~wishingcardy~|e.y);,,e.maintainfury = true; e.preventdefault = true;,
Wand of Wishing_downgraded,Replace this with whatever|item you can spell backward,2,bonus(-9999999999999); if(!self.isplayer) self.textparticle(~No effect!~); else if(!simulation) {  var selfscript = ~removeequipment(\~Equipment That Does Nothing\~);~; if(self.scriptendturn.indexOf(selfscript) == -1) self.scriptendturn = selfscript + self.scriptendturn;  self.setvar(~wishingcard~|e);  var diceavailable = false;  if(self.dicepool.length > 0) for(dice in self.dicepool) if(dice.available()) { diceavailable = true; break; }  if(self.equipment.length > 0) for(eq in self.equipment) if(eq.ready && eq.assigneddice.length > 0) for(dice in eq.assigneddice) if(dice != null && dice.available()) { diceavailable = true; break; }  if(!diceavailable) { givedice(1); self.setvar(~lendeddice~|1); }  self.setvar(~slotsbackup~|[]);  self.setvar(~slotseqbackup~|[]);  self.setvar(~shockslotseqbackup~|[]);  self.setvar(~skillsbackup~|[]);  var slotsbackup = self.getvar(~slotsbackup~);  var slotseqbackup = self.getvar(~slotseqbackup~);  var shockslotseqbackup = self.getvar(~shockslotseqbackup~);  var skillsbackup = self.getvar(~skillsbackup~);  for(eq in self.equipment) {   eq.setvar(~standardcard~|1);   eq.removedice();   slotsbackup.push(eq.slots);   shockslotseqbackup.push(eq.shocked_slots);   slotseqbackup.push(eq);   eq.slots = [];   eq.shocked_slots = [];   skillsbackup.push(eq.skillsavailable.copy());   trace(eq.name);   trace(eq.skillsavailable);   trace(eq.skillsavailable.length);   if(eq.skillsavailable.length > 0) { trace(~this has skills~); for(skill in eq.skillsavailable) { trace(~making skill false~); eq.skillsavailable[eq.skillsavailable.indexOf(skill)] = false; } }   trace(eq.skillsavailable);  }  self.setvar(~slotsbackup~|slotsbackup);  self.setvar(~slotseqbackup~|slotseqbackup);  self.setvar(~shockslotseqbackup~|shockslotseqbackup);  self.setvar(~skillsbackup~|skillsbackup);  self.setvar(~selfstatusbackup~|self.status.copy());  self.setvar(~targetstatusbackup~|target.status.copy());   if(self.usecpuinsteadofdice) { self.setvar(~rolljackpot~|self.roll_jackpot); self.roll_jackpot = -1; /*thx to cody for this bit*/ }   var buttonx = 100;  var buttony = 400;   var charlist = [~A~|~B~|~C~|~D~|~E~|~F~|~G~|~H~|~I~|~J~|~K~|~L~|~M~|~N~|~O~|~P~|~Q~|~R~|~S~|~T~|~U~|~V~|~W~|~X~|~Y~|~Z~|~a~|~b~|~c~|~d~|~e~|~f~|~g~|~h~|~i~|~j~|~k~|~l~|~m~|~n~|~o~|~p~|~q~|~r~|~s~|~t~|~u~|~v~|~w~|~x~|~y~|~z~|~'~|~_~|~@~|~1~|~2~|~3~|~4~|~5~|~6~|~7~|~8~|~9~|~0~|~.~|~?~|~!~|~Bkspace~|~Confirm~];    self.setvar(~wandwish~|~[200%]~);   var i = 0;    for(char in charlist) {   i++;   var charholder = new elements.Equipment(~Equipment That Does Nothing~);   self.equipment.push(charholder);   charholder.script = ~self.equipmentused--;~;   charholder.slotpositions[0].y -= 153;   charholder.slotpositions[0].x -= 260;   charholder.displayname = char;   charholder.equipmentcol = 0;   if(char == char.toLowerCase() && char.toLowerCase() != char.toUpperCase()) charholder.displayname = ~[70%]~ + charholder.displayname;   if(charholder.displayname == ~Confirm~ # charholder.displayname == ~Bkspace~) charholder.equipmentcol = 2;   charholder.fulldescription = ~~;   charholder.height = 270;   charholder.width = 270;   charholder.x = buttonx;   charholder.y = buttony;   charholder.equipalpha = 0.0;   buttonx += 270;   if(i == 13) {    buttonx = 160;    buttony += 270;   }   if(i == 26) {    buttonx = 100;    buttony += 300;   }   if(i == 39) {    buttonx = 160;    buttony += 270;   }   if(i == 52) {    buttonx = 100;    buttony += 300;   }   if(i == 65) {    buttonx = 1620;    buttony += 270;   }  }   var tw = new motion.actuators.SimpleActuator(null|1/60|null);  tw._repeat = -1;  var s = new elements.Skill(~Against all odds_old~);  s.script = ~   var phonedone = false;   var wandwish = self.getvar(\~wandwish\~);   for(eq in self.equipment) {    if(self.getvar(\~phonephase2\~) != 1) {     if(eq.equipalpha > 0.0 && eq.getvar(\~standardcard\~) == 1) eq.equipalpha -= 0.2;     if(eq.equipalpha < 1.0 && eq.getvar(\~standardcard\~) != 1) eq.equipalpha += 0.2;     if(eq.assigneddice.length > 0 && eq.assigneddice[0] != null) {      eq.removedice();      var neweq = eq.copy();          neweq.height = 270;      neweq.width = 270;      neweq.equipalpha = eq.equipalpha;      neweq.displayname = eq.displayname;      neweq.equipmentcol = eq.equipmentcol;      neweq.slotpositions = eq.slotpositions;      neweq.script = eq.script;      self.equipment.push(neweq);      eq.name = \~deleteme\~;      eq.slots = [];      eq.equipalpha = 0;      if(eq.displayname != \~Confirm\~) {       sfx(\~jackpot_increasecounter\~);       if(eq.displayname == \~Bkspace\~ && wandwish.length > 6) wandwish = wandwish.substr(0|wandwish.length - 1);       else       if(eq.displayname.substr(0|1) == \~_\~) wandwish += \~_\~;       else       if(eq.displayname.substr(0|1) == \~[\~) wandwish += eq.displayname.substr(5|1);       else       if(eq.displayname != \~Bkspace\~) wandwish += eq.displayname.substr(0|1);      }      else {       sfx(\~_thinghappens\~);       self.setvar(\~phonephase2\~|1);      }     }    }    else {     if(eq.equipalpha <= 1.0 && eq.getvar(\~standardcard\~) == 1) {      eq.equipalpha += 0.2;     }     if(eq.equipalpha > 0.0 && eq.getvar(\~standardcard\~) != 1) {      eq.removedice();      eq.equipalpha -= 0.2;      eq.slots = [];      eq.script = \~self.equipmentused--; self.equipmenthistory.pop();\~;     }     if(eq.equipalpha <= 0.0 && eq.getvar(\~standardcard\~) != 1) {      eq.name = \~deleteme\~;      phonedone = true;     }    }   }      new elements.CombatCommand(\~msg\~|wandwish).execute();   self.setvar(\~wandwish\~|wandwish);      removeequipment(\~deleteme\~);   if(self.doendturnnow) {    trace(\~ending turn\~);    for(eq in self.equipment) {     if(eq.getvar(\~standardcard\~) == 1) {      eq.equipalpha = 1.0;      eq.slots = self.getvar(\~slotsbackup\~)[self.getvar(\~slotseqbackup\~).indexOf(eq)];      eq.shocked_slots = self.getvar(\~shockslotseqbackup\~)[self.getvar(\~slotseqbackup\~).indexOf(eq)];      eq.skillsavailable = self.getvar(\~skillsbackup\~)[self.getvar(\~slotseqbackup\~).indexOf(eq)];      if(self.usecpuinsteadofdice) self.roll_jackpot = self.getvar(\~rolljackpot\~);     }     else {      eq.name = \~deleteme\~;     }    }    removeequipment(\~deleteme\~);    removeequipment(\~Equipment That Does Nothing\~);    self.resetvar(\~slotsbackup\~);    self.resetvar(\~slotseqbackup\~);    self.resetvar(\~shockslotseqbackup\~);    self.resetvar(\~skillsbackup\~);    self.resetvar(\~rolljackpot\~);    new elements.CombatCommand(\~msg\~|\~\~).execute();    wandwish = wandwish.split(\~[200%]\~)[1].split(\~_\~).join(\~ \~);    var wandwisharr = wandwish.split(\~\~);    wandwish = \~\~;    for(char in wandwisharr) wandwish = char + wandwish;    var exceptions = getcolumn(loaddata(\~ncrmod/wishredirects\~)|\~input\~);    var redirects = getcolumn(loaddata(\~ncrmod/wishredirects\~)|\~redirect\~);    if(exceptions.indexOf(wandwish) != -1) wandwish = redirects[exceptions.indexOf(wandwish)];    if(getequipmentlist().indexOf(wandwish) != -1) {     if(self.getvar(\~ncrrobotepisode4\~) == 1 && self.getvar(\~ncrrobotepisode4wishlist\~).indexOf(wandwish) != -1) { self.textparticle(\~Already wished!\~); }     else {      if(self.getvar(\~ncrrobotepisode4\~) == 1) {       self.setvar(\~ncrrobotepisode4wishlist\~|self.getvar(\~ncrrobotepisode4wishlist\~).concat([wandwish]));       var familylist = loadtext(\~ncrmod/wishfamilies\~);       for(i in 0...familylist.length)  {        if(familylistsplit.indexOf(wandwish) != -1) {         self.setvar(\~ncrrobotepisode4wishlist\~|self.getvar(\~ncrrobotepisode4wishlist\~).concat(familylistsplit));        }       }       if(!new elements.Equipment(wandwish).hastag(\~powercard\~)) {        if(wandwish.substr(wandwish.length - 1|1) == \~?\~) {         self.setvar(\~ncrrobotepisode4wishlist\~|self.getvar(\~ncrrobotepisode4wishlist\~).concat([wandwish.substr(0|wandwish.length - 1)]));        }        else {         self.setvar(\~ncrrobotepisode4wishlist\~|self.getvar(\~ncrrobotepisode4wishlist\~).concat([wandwish + \~?\~]));        }       }      }      var newcard = new elements.Equipment(wandwish);      var replacecard = self.equipment[self.equipment.indexOf(self.getvar(\~wishingcard\~))];      trace(\~card made\~);      newcard.x = self.getvar(\~wishingcardx\~);      newcard.y = self.getvar(\~wishingcardy\~);      self.equipment[self.equipment.indexOf(self.getvar(\~wishingcard\~))] = newcard;      trace(\~card replaced\~);      newcard.animate(\~flashandshake\~);      self.setvar(\~doonthis\~|newcard); var estandardize = \~var e = self.getvar(\\\~doonthis\\\~); \~; var doscripts = new elements.Skill(\~Against all odds_old\~); doscripts.script = estandardize + newcard.scriptbeforecombat; doscripts.execute(self|target); doscripts.script = estandardize + newcard.scriptbeforestartturn; doscripts.execute(self|target); doscripts.script = estandardize + newcard.scriptonstartturn; doscripts.execute(self|target); self.resetvar(\~doonthis\~);      newcard.arrangeslots();      self.createsparedice(newcard);      trace(\~card flashed\~);     }    }    else self.textparticle(\~Invalid wish!\~);    self.resetvar(\~wishingcard\~); self.resetvar(\~diditwork\~);    self.getvar(\~wishactuator\~).stop();    self.status = self.getvar(\~selfstatusbackup\~);    target.status = self.getvar(\~targetstatusbackup\~);    self.resetvar(\~selfstatusbackup\~);    self.resetvar(\~targetstatusbackup\~);    self.resetvar(\~phonephase2\~);    self.resetvar(\~wishactuator\~);    self.resetvar(\~wandwish\~);    if(self.getvar(\~lendeddice\~) == 1) { for(dice in self.dicepool) { if(dice.available() && dice.basevalue == 1) { dice.animate(\~disappear\~); break; } } }    self.resetvar(\~lendeddice\~);   }      if(phonedone) {    for(eq in self.equipment) {     if(eq.getvar(\~standardcard\~) == 1) {      eq.equipalpha = 1.0;      var importantindex = self.getvar(\~slotseqbackup\~).indexOf(eq);      eq.slots = self.getvar(\~slotsbackup\~)[importantindex];      eq.shocked_slots = self.getvar(\~shockslotseqbackup\~)[importantindex];      eq.skillsavailable = self.getvar(\~skillsbackup\~)[importantindex];      if(self.usecpuinsteadofdice) self.roll_jackpot = self.getvar(\~rolljackpot\~);     }    }    removeequipment(\~Equipment That Does Nothing\~);    self.resetvar(\~slotsbackup\~);    self.resetvar(\~slotseqbackup\~);    self.resetvar(\~shockslotseqbackup\~);    self.resetvar(\~skillsbackup\~);    self.resetvar(\~rolljackpot\~);    new elements.CombatCommand(\~msg\~|\~\~).execute();    wandwish = wandwish.split(\~[200%]\~)[1].split(\~_\~).join(\~ \~);    var wandwisharr = wandwish.split(\~\~);    wandwish = \~\~;    for(char in wandwisharr) wandwish = char + wandwish;    var exceptions = getcolumn(loaddata(\~ncrmod/wishredirects\~)|\~input\~);    var redirects = getcolumn(loaddata(\~ncrmod/wishredirects\~)|\~redirect\~);    if(exceptions.indexOf(wandwish) != -1) wandwish = redirects[exceptions.indexOf(wandwish)];    if(getequipmentlist().indexOf(wandwish) != -1) {     if(self.getvar(\~ncrrobotepisode4\~) == 1 && self.getvar(\~ncrrobotepisode4wishlist\~).indexOf(wandwish) != -1) { self.textparticle(\~Already wished!\~); }     else {      if(self.getvar(\~ncrrobotepisode4\~) == 1) {       self.setvar(\~ncrrobotepisode4wishlist\~|self.getvar(\~ncrrobotepisode4wishlist\~).concat([wandwish]));       var familylist = loadtext(\~ncrmod/wishfamilies\~);       for(i in 0...familylist.length)  {        if(familylistsplit.indexOf(wandwish) != -1) {         self.setvar(\~ncrrobotepisode4wishlist\~|self.getvar(\~ncrrobotepisode4wishlist\~).concat(familylistsplit));        }       }       if(!new elements.Equipment(wandwish).hastag(\~powercard\~)) {        if(wandwish.substr(wandwish.length - 1|1) == \~?\~) {         self.setvar(\~ncrrobotepisode4wishlist\~|self.getvar(\~ncrrobotepisode4wishlist\~).concat([wandwish.substr(0|wandwish.length - 1)]));        }        else {         self.setvar(\~ncrrobotepisode4wishlist\~|self.getvar(\~ncrrobotepisode4wishlist\~).concat([wandwish + \~?\~]));        }       }      }      var newcard = new elements.Equipment(wandwish);      var replacecard = self.equipment[self.equipment.indexOf(self.getvar(\~wishingcard\~))];      trace(\~card made\~);      newcard.x = self.getvar(\~wishingcardx\~);      newcard.y = self.getvar(\~wishingcardy\~);      self.equipment[self.equipment.indexOf(self.getvar(\~wishingcard\~))] = newcard;      trace(\~card replaced\~);      newcard.animate(\~flashandshake\~);      self.setvar(\~doonthis\~|newcard); var estandardize = \~var e = self.getvar(\\\~doonthis\\\~); \~; var doscripts = new elements.Skill(\~Against all odds_old\~); doscripts.script = estandardize + newcard.scriptbeforecombat; doscripts.execute(self|target); doscripts.script = estandardize + newcard.scriptbeforestartturn; doscripts.execute(self|target); doscripts.script = estandardize + newcard.scriptonstartturn; doscripts.execute(self|target); self.resetvar(\~doonthis\~);      newcard.arrangeslots();      self.createsparedice(newcard);      trace(\~card flashed\~);     }    }    else self.textparticle(\~Invalid wish!\~);    self.resetvar(\~wishingcard\~); self.resetvar(\~diditwork\~);    self.getvar(\~wishactuator\~).stop();    self.status = self.getvar(\~selfstatusbackup\~);    target.status = self.getvar(\~targetstatusbackup\~);    self.resetvar(\~selfstatusbackup\~);    self.resetvar(\~targetstatusbackup\~);    self.resetvar(\~phonephase2\~);    self.resetvar(\~wishactuator\~);    self.resetvar(\~wandwish\~);    if(self.getvar(\~lendeddice\~) == 1) { for(dice in self.dicepool) { if(dice.available() && dice.basevalue == 1) { dice.animate(\~disappear\~); break; } } }    self.resetvar(\~lendeddice\~);   }  ~;  tw.onRepeat(s.execute|[self|target]);  self.setvar(~wishactuator~|tw);  tw.move(); },Best Friend,REQUIRE5|REQUIRE5,,BRIGHTCYAN,,,,,,YES,,excludefromrandomlists|cannotsteal,,,,,,,,,self.setvar(~wishingcardx~|e.x); self.setvar(~wishingcardy~|e.y);,,e.maintainfury = true; e.preventdefault = true;,
Wonder Gummi,[]+6 max HP|Destroy this on use,2,self.maxhp += 6; sfx(~_survive~); attackself(-6); if(self.layout == ~DECK~) { var deleteindex = -1; for(i in 0...Deck.getcards(~all~).length) if(Deck.getcards(~all~)[i].equipment == e) { deleteindex = i; break; } Deck.getcards(~all~)[deleteindex].delete(); } else { e.name = ~ncrsaysremoveme~; removeequipment(~ncrsaysremoveme~); },Health Pack,COUNTDOWN,40,PINK,change_power,change_power,,jester_delete,,YES,,cannotreuse,,,,,,,,,,,e.maintainfury = true; e.preventdefault = true;,
Wonder Gummi_upgraded,[]+6 max HP|Destroy this on use,2,self.maxhp += 6; sfx(~_survive~); attackself(-6); if(self.layout == ~DECK~) { var deleteindex = -1; for(i in 0...Deck.getcards(~all~).length) if(Deck.getcards(~all~)[i].equipment == e) { deleteindex = i; break; } Deck.getcards(~all~)[deleteindex].delete(); } else { e.name = ~ncrsaysremoveme~; removeequipment(~ncrsaysremoveme~); },Health Pack,COUNTDOWN,32,PINK,,,,jester_delete,,YES,,cannotreuse,,,,,,,,,,,e.maintainfury = true; e.preventdefault = true;,
Wonder Gummi_downgraded,[]+3 max HP|Destroy this on use,2,self.maxhp += 3; sfx(~_survive~); attackself(-3); if(self.layout == ~DECK~) { var deleteindex = -1; for(i in 0...Deck.getcards(~all~).length) if(Deck.getcards(~all~)[i].equipment == e) { deleteindex = i; break; } Deck.getcards(~all~)[deleteindex].delete(); } else { e.name = ~ncrsaysremoveme~; removeequipment(~ncrsaysremoveme~); },Health Pack,COUNTDOWN,40,PINK,,,,jester_delete,,YES,,cannotreuse,,,,,,,,,,,e.maintainfury = true; e.preventdefault = true;,
Wonder Gummi_weakened,[]+3 max HP|Destroy this on use,2,self.maxhp += 3; sfx(~_survive~); attackself(-3); if(self.layout == ~DECK~) { var deleteindex = -1; for(i in 0...Deck.getcards(~all~).length) if(Deck.getcards(~all~)[i].equipment == e) { deleteindex = i; break; } Deck.getcards(~all~)[deleteindex].delete(); } else { e.name = ~ncrsaysremoveme~; removeequipment(~ncrsaysremoveme~); },Health Pack,COUNTDOWN,32,PINK,,,,jester_delete,,YES,,cannotreuse,,,,,,,,,,,e.maintainfury = true; e.preventdefault = true;,
Pummel,Do [sword]4 damage|,1,attack(4); sfxdamage(target|4);,Dice Bash,DOUBLES|DOUBLES,,RED,change_power,change_power,,,-1,,,,,,,,,,,,,,,
Pummel_upgraded,Do [sword]4 damage if|difference is 1 or less|,1,if([-1|0|1].indexOf(actualdice[0].basevalue - actualdice[1].basevalue) != -1) { attack(4); sfxdamage(target|4); } else { self.textparticle(~No effect!~); },Dice Bash,NORMAL|NORMAL,,RED,,,,,-1,,,,,,,,,,,,,,,
Pummel_downgraded,Do [sword]2 damage|,1,attack(2); sfxdamage(target|2);,Dice Bash,DOUBLES|DOUBLES,,RED,,,,,-1,,,,,,,,,,,,,,,
Pummelplusbadidea,[85%]DIFFERENCE OF 1 OR LESS[]|Do [sword]4 damage|[gray](Reuseable),1,if([-1|0|1].indexOf(actualdice[0].basevalue - actualdice[1].basevalue) != -1) { attack(4); sfxdamage(target|4); } else { self.equipmentused--; } trace(e.assigneddice.length == 2); trace(e.assigneddice[0] != null); trace(e.assigneddice[1] != null); trace(e.assigneddice.length == 2 && e.assigneddice[0] != null && e.assigneddice[1] != null);,Dice Bash,NORMAL|NORMAL,,RED,,,,,0,,,excludefromrandomlists|testitem,,,,,if(self.getvar(~pummelactuator~) != 0) self.getvar(~pummelactator~).stop(); var tw = new motion.actuators.SimpleActuator(null|1/60|null); tw._repeat = -1; var s = new elements.Skill(~Against all odds_old~); s.script = ~  if(self.equipment.length > 0) for(eq in self.equipment) {   trace(eq.name);   self.y += rand([1|-1]);   if(eq.name == \~Pummel\~) {    if(eq.assigneddice.length == 2) trace(1 + \~\~ + eq.assigneddice.length); else trace(-1 + \~\~ + eq.assigneddice.length);    if(eq.assigneddice[0] != null) trace(2); else trace(-2);    if(eq.assigneddice[1] != null) trace(3); else trace(-3);    if(eq.assigneddice.length == 2 && eq.assigneddice[0] != null && eq.assigneddice[1] != null) {     trace(\~found one\~);     eq.removedice();     var newcard = new elements.Equipment(eq.name + \~_upgraded\~);     newcard.x = eq.x;     newcard.y = eq.y;     newcard.equipmentcol = eq.equipmentcol;     newcard.displayname = eq.displayname;     trace(\~idk\~);     newcard.tags = eq.tags;     trace(\~uhh\~);     newcard.gamevar = eq.gamevar;     trace(\~phew!\~);     self.equipment[self.equipment.indexOf(eq)] = newcard;    }   }  }  if(target == null # target.graphic == null # target.hp <= 0) {   self.getvar(\~pummelactuator\~).stop();  } ~; tw.onRepeat(s.execute|[self|target]); self.setvar(~pummelactuator~|tw); tw.move();,,,,if([-1|0|1].indexOf(actualdice[0].basevalue - actualdice[1].basevalue) != -1) e.usesleft = 2;,,,
Chant,[silence]Silence enemy,2,inflict(~ncr_silence~); sfx(~_silence~); bonus(1000);,Confiscate,NORMAL|NORMAL,8,PURPLE,change_power,change_power,,,,,,,,,,,,,,,,,,
Chant_upgraded,[silence]Silence enemy,2,inflict(~ncr_silence~); sfx(~_silence~); bonus(1000);,Confiscate,COUNTDOWN,8,PURPLE,,,,,,,,,,,,,,,,,,,,
Chant_downgraded,[shock]Shock enemy,2,inflict(SHOCK); sfx(~_shock~);,Confiscate,NORMAL|NORMAL,8,PURPLE,,,,,,,,,,,,,,,,,,,,
Chant_weakened,[shock]Shock enemy,2,inflict(SHOCK); sfx(~_shock~);,Confiscate,COUNTDOWN,8,PURPLE,,,,,,,,,,,,,,,,,,,,
Envy,Lose [heart]<d6> HP[;] charge|limit by an extra [confuse]<d6>,1,pierceattackself(d); if(self.limitvalue != null && self.limitmax != null) { sfx(~_cure~); self.limitvalue += d; if(self.limitvalue > self.limitmax) { self.limitvalue = self.limitmax; } },Pure Evil,MAX5,,GRAY,change_power,change_function,,_curse,0,YES,YES,,,,,,,,,,,,,
Envy_upgraded,Lose [heart]<d6> HP[;] charge|limit by an extra [confuse]<d6>|,1,pierceattackself(d); if(self.limitvalue != null && self.limitmax != null) { sfx(~_cure~); self.limitvalue += d; if(self.limitvalue > self.limitmax) { self.limitvalue = self.limitmax; } },Pure Evil,MAX5,,GRAY,,,,_curse,2,YES,YES,,,,,,,,,,,,,
Envy_downgraded,Lose [heart]<d6> HP,1,pierceattackself(d);,Pure Evil,MAX5,,GRAY,,,,_curse,0,YES,YES,,,,,,,,,,,,,
Suspense,Do [sword]<d6> dmg. If not used|by turn end[;] inflict [vanish]2,2,attack(d); sfxdamage(target|d); e.addtag(~usedthisturn~);,Mass Deception,NORMAL,,PINK,change_power,change_power,,none,0,,,,,,,,e.removetag(~usedthisturn~);,e.removetag(~usedthisturn~);,if(target.hp > 0 && !e.hastag(~usedthisturn~)) { sfx(~_vanish~); inflict(~ncr_vanish~|2); } e.removetag(~usedthisturn~);,,,,,
Suspense_downgraded,Do [sword]<d6> dmg. If not used|by turn end[;] inflict [vanish]1,2,attack(d); sfxdamage(target|d); e.addtag(~usedthisturn~);,Mass Deception,NORMAL,,PINK,,,,none,0,,,,,,,,e.removetag(~usedthisturn~);,e.removetag(~usedthisturn~);,if(target.hp > 0 && !e.hastag(~usedthisturn~)) { sfx(~_vanish~);  inflict(~ncr_vanish~);  } e.removetag(~usedthisturn~);,,,,,
Suspense_upgraded,Do [sword]<d6> dmg. If used last[;]|inflict [vanish]2 on turn end,2,attack(d); sfxdamage(target|d);,Mass Deception,NORMAL,,PINK,,,,none,0,,,,,,,,e.removetag(~usedthisturn~);,e.removetag(~usedthisturn~);,if(target.hp > 0 && self.lastequipmentused == e) { sfx(~_vanish~);  inflict(~ncr_vanish~|2); } e.removetag(~usedthisturn~);,,,,,
Pink Slip,Do [sword]<d6> dmg. If not used|by turn end[;] inflict [fire]2,2,attack(d); sfxdamage(target|d); e.addtag(~usedthisturn~);,Blowtorch,NORMAL,,PINK,change_power,change_power,,none,0,,,,,,,,e.removetag(~usedthisturn~);,e.removetag(~usedthisturn~);,if(target.hp > 0 && !e.hastag(~usedthisturn~)) { sfx(~_fire~); inflict(FIRE|2); } e.removetag(~usedthisturn~);,,,,,
Pink Slip_downgraded,Do [sword]<d6> dmg. If not used|by turn end[;] inflict [fire]1,2,attack(d); sfxdamage(target|d); e.addtag(~usedthisturn~);,Blowtorch,NORMAL,,PINK,,,,none,0,,,,,,,,e.removetag(~usedthisturn~);,e.removetag(~usedthisturn~);,if(target.hp > 0 && !e.hastag(~usedthisturn~)) { sfx(~_fire~); inflict(FIRE); } e.removetag(~usedthisturn~);,,,,,
Pink Slip_upgraded,Do [sword]<d6> dmg. If used last[;]|inflict [fire]2 on turn end,2,attack(d); sfxdamage(target|d);,Blowtorch,NORMAL,,PINK,,,,none,0,,,,,,,,e.removetag(~usedthisturn~);,e.removetag(~usedthisturn~);,if(target.hp > 0 && self.lastequipmentused == e) { sfx(~_fire~); inflict(FIRE|2); } e.removetag(~usedthisturn~);,,,,,
Cold Shoulder,Do [sword]<d6> dmg. If not used|by turn end[;] inflict [ice]2,2,attack(d); sfxdamage(target|d); e.addtag(~usedthisturn~);,Arctic Storm,NORMAL,,BRIGHTCYAN,change_power,change_power,,none,0,,,,,,,,e.removetag(~usedthisturn~);,e.removetag(~usedthisturn~);,if(target.hp > 0 && !e.hastag(~usedthisturn~)) { sfx(~_ice~); inflict(ICE|2); } e.removetag(~usedthisturn~);,,,,,
Cold Shoulder_downgraded,Do [sword]<d6> dmg. If not used|by turn end[;] inflict [ice]1,2,attack(d); sfxdamage(target|d); e.addtag(~usedthisturn~);,Arctic Storm,NORMAL,,BRIGHTCYAN,,,,none,0,,,,,,,,e.removetag(~usedthisturn~);,e.removetag(~usedthisturn~);,if(target.hp > 0 && !e.hastag(~usedthisturn~)) { sfx(~_ice~); inflict(ICE); } e.removetag(~usedthisturn~);,,,,,
Cold Shoulder_upgraded,Do [sword]<d6> dmg. If used last[;]|inflict [ice]2 on turn end,2,attack(d); sfxdamage(target|d);,Arctic Storm,NORMAL,,BRIGHTCYAN,,,,none,0,,,,,,,,e.removetag(~usedthisturn~);,e.removetag(~usedthisturn~);,if(target.hp > 0 && self.lastequipmentused == e) { sfx(~_ice~); inflict(ICE|2); } e.removetag(~usedthisturn~);,,,,,
One Way Mirror,[]+2 dice this fight[;] but every|<d6> you roll will be locked,1,self.extradice += 2; inflictself(~ncr_lingeringcounter~ + d); sfx(~_lock~|~~|0.1);,Super Hexahedron,NORMAL,,PURPLE,change_power,change_power,,magic_gaindice,,YES,,,,,,,,,,,,,,
One Way Mirror_downgraded,[]+2 dice this fight[;] but every|<d6> you roll will be locked,1,self.extradice += 2; inflictself(~ncr_lingeringcounter~ + d); sfx(~_lock~|~~|0.1);,Super Hexahedron,MIN4,,PURPLE,,,,magic_gaindice,,YES,,,,,,,,,,,,,,
One Way Mirror_upgraded,[]+3 dice this fight[;] but every|<d6> you roll will be locked,1,self.extradice += 3; inflictself(~ncr_lingeringcounter~ + d); sfx(~_lock~|~~|0.1);,Super Hexahedron,NORMAL,,PURPLE,,,,magic_gaindice,,YES,,,,,,,,,,,,,,
Sheol,Do [ice]<triple> damage[;] but|lose [heart]<d6> max HP & health|[gray](once per battle),1,attack(3 * d|ICE); sfxdamage(target|3 * d); self.maxhp -= d; if(self.maxhp < 0) { self.maxhp = 0; } pierceattackself(d); if(self.hp > self.maxhp) { self.hp = self.maxhp; } /*something about how sheol (basically hell) in the binding of isaac is described as ''a cold place'' if you die there; and *that's* something about some arcane bible lore regarding some specific circle of hell in which satan is imprisoned being very cold. i'm not religious; cut me some slack!*/,Pure Evil,NORMAL,,GRAY,change_power,change_function,,_ice,0,NO,YES,,,self.maxhp -= d; if(self.maxhp < 0) { self.maxhp = 0; } pierceattackself(d); if(self.hp > self.maxhp) { self.hp = self.maxhp; },,,,,,,,,,
Sheol_upgraded,Do [ice]<quadruple> damage[;] but|lose [heart]<d6> max HP & health|[gray](once per battle),1,attack(4 * d|ICE); sfxdamage(target|3 * d); self.maxhp -= d; if(self.maxhp < 0) { self.maxhp = 0; } pierceattackself(d); if(self.hp > self.maxhp) { self.hp = self.maxhp; },Pure Evil,NORMAL,,GRAY,,,,_ice,0,NO,YES,,,self.maxhp -= d; if(self.maxhp < 0) { self.maxhp = 0; } pierceattackself(d); if(self.hp > self.maxhp) { self.hp = self.maxhp; },,,,,,,,,,
Sheol_downgraded,Do [ice]<double> damage[;] but|lose [heart]<d6> max HP & health|[gray](once per battle),1,attack(2 * d|ICE); sfxdamage(target|3 * d); self.maxhp -= d; if(self.maxhp < 0) { self.maxhp = 0; } pierceattackself(d); if(self.hp > self.maxhp) { self.hp = self.maxhp; },Pure Evil,NORMAL,,GRAY,,,,_ice,0,NO,YES,,,self.maxhp -= d; if(self.maxhp < 0) { self.maxhp = 0; } pierceattackself(d); if(self.hp > self.maxhp) { self.hp = self.maxhp; },,,,,,,,,,
Soul Sale,Do [vanish]<triple> damage[;] but|lose [heart]<d6> max HP & health|[gray](once per battle),1,attack(3 * d|VANISH); sfxdamage(target|3 * d); self.maxhp -= d; if(self.maxhp < 0) { self.maxhp = 0; } pierceattackself(d); if(self.hp > self.maxhp) { self.hp = self.maxhp; } /*panicked for a few seconds and named this ''Ghost Hell. Aw Fuck''*/,Pure Evil,NORMAL,,GRAY,change_power,change_function,,_vanish,0,NO,YES,,,self.maxhp -= d; if(self.maxhp < 0) { self.maxhp = 0; } pierceattackself(d); if(self.hp > self.maxhp) { self.hp = self.maxhp; },,,,,,,,,,
Soul Sale_upgraded,Do [vanish]<quadruple> damage[;] but|lose [heart]<d6> max HP & health|[gray](once per battle),1,attack(4 * d|VANISH); sfxdamage(target|3 * d); self.maxhp -= d; if(self.maxhp < 0) { self.maxhp = 0; } pierceattackself(d); if(self.hp > self.maxhp) { self.hp = self.maxhp; },Pure Evil,NORMAL,,GRAY,,,,_vanish,0,NO,YES,,,self.maxhp -= d; if(self.maxhp < 0) { self.maxhp = 0; } pierceattackself(d); if(self.hp > self.maxhp) { self.hp = self.maxhp; },,,,,,,,,,
Soul Sale_downgraded,Do [vanish]<double> damage[;] but|lose [heart]<d6> max HP & health|[gray](once per battle),1,attack(2 * d|VANISH); sfxdamage(target|3 * d); self.maxhp -= d; if(self.maxhp < 0) { self.maxhp = 0; } pierceattackself(d); if(self.hp > self.maxhp) { self.hp = self.maxhp; },Pure Evil,NORMAL,,GRAY,,,,_vanish,0,NO,YES,,,self.maxhp -= d; if(self.maxhp < 0) { self.maxhp = 0; } pierceattackself(d); if(self.hp > self.maxhp) { self.hp = self.maxhp; },,,,,,,,,,
Ol' Reliable@ncrmod,Do [sword]<d6> damage|Ignores all status effects|Immune to everything,2,var targetstatus = target.status.copy(); target.status = []; var selfstatus = self.status.copy(); self.status = []; pierceattack(d); sfxdamage(target|d); target.status = targetstatus; self.status = selfstatus; e.availablenextturn = true;,Reset Button,NORMAL,,GRAY,add1,decreaserange,,,,,,errorimmune|cannotsteal|shockavoid|weakenavoid|altpoisonavoid|curseavoid|cannotreuse,,var targetstatus = target.status.copy(); target.status = []; var selfstatus = self.status.copy(); self.status = []; pierceattack(d); sfxdamage(target|d); target.status = targetstatus; inflict(DODGE); self.status = selfstatus; e.availablenextturn = true;,,,,,e.availablenextturn = true;,,,,e.preventdefault = true; e.maintainfury = true;,
Shame,Enemy is [shock]shocked|the next time they attack|,1,inflict(~ncr_paralysis~);,Static Shock,COUNTDOWN,3,YELLOW,change_power,change_power,,_shock,2,,,,,,,,,,,,,,,
Rap God,Enemy is [weaken]weakened|the next time they attack|,1,inflict(~ncr_restraint~);,Theremin,COUNTDOWN,3,ORANGE,change_power,change_power,,_weaken,2,,,,,,,,,,,,,,,
Shame_upgraded,Enemy is [shock]shocked|the next time they attack|,1,inflict(~ncr_paralysis~);,Static Shock,COUNTDOWN,3,YELLOW,,,,_shock,4,,,,,,,,,,,,,,,
Rap God_upgraded,Enemy is [weaken]weakened|the next time they attack|,1,inflict(~ncr_restraint~);,Theremin,COUNTDOWN,3,ORANGE,,,,_weaken,4,,,,,,,,,,,,,,,
Shame_downgraded,Enemy is [shock]shocked|the next time they attack,1,inflict(~ncr_paralysis~);,Static Shock,COUNTDOWN,3,YELLOW,,,,_shock,0,,,,,,,,,,,,,,,
Rap God_downgraded,Enemy is [weaken]weakened|the next time they attack,1,inflict(~ncr_restraint~);,Theremin,COUNTDOWN,3,ORANGE,,,,_weaken,0,,,,,,,,,,,,,,,
Compact Resonator,Do [weaken]<double> damage. Passive:|[weaken]weaken yourself when you|use a card on the enemy,1,attack(d * 2|WEAKEN); sfxdamage(target|d * 2);,Burrower,MAX5,,ORANGE,change_power,complicate,,,,,,excludefromrandomlists,,,,,,inflictself(~ncr_restraint_all~); e.animate(~flashandshake~);,,,,,,
Compact Resonator_upgraded,Do [weaken]<double> dmg. Passive:|[weaken]weaken yourself when you|use a card on the enemy,1,attack(d * 2|WEAKEN); sfxdamage(target|d * 2);,Burrower,MAX5|FREE1,,ORANGE,,,,,,,,excludefromrandomlists,,,,,,inflictself(~ncr_restraint_all~); e.animate(~flashandshake~);,,,,,,
Compact Generator,Do [shock]<double> damage. Passive:|[shock]shock yourself when you|use a card on the enemy,1,attack(d * 2|SHOCK); sfxdamage(target|d * 2);,Jackhammer,MAX5,,YELLOW,change_power,complicate,,,,,,excludefromrandomlists,,,,,,inflictself(~ncr_paralysis_all~); e.animate(~flashandshake~);,,,,,,
Compact Generator_upgraded,Do [shock]<double> dmg. Passive:|[shock]shock yourself when you|use a card on the enemy,1,attack(d * 2|SHOCK); sfxdamage(target|d * 2);,Jackhammer,MAX5|FREE1,,YELLOW,,,,,,,,excludefromrandomlists,,,,,,inflictself(~ncr_paralysis_all~); e.animate(~flashandshake~);,,,,,,
IC Chip,Return the dice,2,givedice(d); self.setvar(~icchips~|self.getvar(~icchips~) + 2); self.setvar(~actualicchips~|self.getvar(~actualicchips~) + 1);,Bubble Gun,MIN4,,GRAY,change_power,change_power,,chip,,YES,,,,,,,,,,,,,,
Chip Socket,Do [sword]2 damage[;] +[sword]2 per|chip used this turn (+[sword]<var:icchips>)|[gray](more items will be chips)[],2,attack(2 + self.getvar(~icchips~)); sfxdamage(target|2 + self.getvar(~icchips~)); sfx(~socket~|~~|0.2);,Discharge,EVEN,,YELLOW,change_power,complicate,,,,,,excludefromrandomlists,,,,,self.setvar(~icchips~|0); self.setvar(~actualicchips~|0);,,self.setvar(~icchips~|0); self.setvar(~actualicchips~|0);,,,,,
Chip Socket_upgraded,Do [sword]4 damage[;] +[sword]2 per|chip used this turn (+[sword]<var:icchips>)|[gray](more items will be chips)[],2,attack(4 + self.getvar(~icchips~)); sfxdamage(target|4 + self.getvar(~icchips~)); sfx(~socket~|~~|0.2);,Discharge,EVEN,,YELLOW,,,,,,,,excludefromrandomlists,,,,,self.setvar(~icchips~|0); self.setvar(~actualicchips~|0);,,self.setvar(~icchips~|0); self.setvar(~actualicchips~|0);,,,,,
IC Chip_downgraded,Count as used|[80%][gray]''Bummer!''[],2,self.setvar(~icchips~|self.getvar(~icchips~) + 2); self.setvar(~actualicchips~|self.getvar(~actualicchips~) + 1);,Bubble Gun,MIN4,,GRAY,,,,chip,,YES,,,,,,,,,,,,,,
IC Chip_upgraded,Return the dice,2,givedice(d); self.setvar(~icchips~|self.getvar(~icchips~) + 2); self.setvar(~actualicchips~|self.getvar(~actualicchips~) + 1);,Bubble Gun,MIN3,,GRAY,,,,chip,,YES,,,,,,,,,,,,,,
Toggle Chip,On even[;] do [sword]<d6> damage|On odd[;] acts as a chip,2,if(d % 2 == 0) { attack(d); sfxdamage(target|d); } else { sfx(~chip~); self.setvar(~icchips~|self.getvar(~icchips~) + 2); self.setvar(~actualicchips~|self.getvar(~actualicchips~) + 1); },Neutron Star,NORMAL,,GREEN,change_power,change_power,,,,,,excludefromrandomlists,,,,,,,,,if(d % 2 == 0) { e.castdirection = 1; } else { e.castdirection = -1; },,,
Toggle Chip_downgraded,Do [sword]<d6> damage,2,attack(d); sfxdamage(target|d);,Neutron Star,EVEN,,GREEN,,,,,,,,excludefromrandomlists,,,,,,,,,,,,
Toggle Chip_upgraded,On even[;] do [sword]<d6> damage|On odd[;] acts as a chip[;]|and returns the dice,2,if(d % 2 == 0) { attack(d); sfxdamage(target|d); } else { sfx(~chip~); givedice(d); self.setvar(~icchips~|self.getvar(~icchips~) + 2); self.setvar(~actualicchips~|self.getvar(~actualicchips~) + 1); },Neutron Star,NORMAL,,GREEN,,,,,,,,excludefromrandomlists,,,,,,,,,if(d % 2 == 0) { e.castdirection = 1; } else { e.castdirection = -1; },,,
Alternative Ax,Do [sword]<quadruple> damage,2,attack(d); sfxdamage(target|d);,Comedy,MAX4,,YELLOW,change_power,change_power,,,,,,,,,,,,,,,,,,
Alternative Ax_downgraded,Do [sword]<double> damage,2,attack(d); sfxdamage(target|d);,Comedy,MAX4,,YELLOW,,,,,,,,,,,,,,,,,,,,
Alternative Ax_upgraded,Do [sword]<quadruple> damage|[gray](2 uses this turn)[],2,attack(d); sfxdamage(target|d);,Comedy,MAX4,,YELLOW,,,,,,,,,,,,,,,,,,,,
Popular Vote,Duplicate your highest dice|,1,var max = d; if(self.dicepool.length > 0) { for (mydice in self.dicepool){ if (mydice.available() && mydice.basevalue > max) { max = mydice.basevalue; } } } if(max == d) { givedice([max|max]); /*if your highest dice is (or could be) the dice you just inserted; should look like you duplicated that dice. makes more sense w/ the downgrade*/ } else { givedice(max); },Conformity,REQUIRE1,,GREEN,increaserange,change_power,,,2,YES,,,,,,,,,,,,,,
Popular Vote_downgraded,Duplicate your lowest dice|,1,var min = d; if(self.dicepool.length > 0) { for (mydice in self.dicepool){ if (mydice.available() && mydice.basevalue < min) { min = mydice.basevalue; } } } if(min == d) { givedice([min|min]); } else { givedice(min); },Conformity,REQUIRE1,,GREEN,,,,,2,YES,,,,,,,,,,,,,,
Blessed Wand of Wishing,Replace this with any item|you can name[;] return dice,2,bonus(-9999999999999); givedice(d); if(!self.isplayer) self.textparticle(~No effect!~); else if(!simulation) {  var selfscript = ~removeequipment(\~Equipment That Does Nothing\~);~; if(self.scriptendturn.indexOf(selfscript) == -1) self.scriptendturn = selfscript + self.scriptendturn;  self.setvar(~wishingcard~|e);  var diceavailable = false;  if(self.dicepool.length > 0) for(dice in self.dicepool) if(dice.available()) { diceavailable = true; break; }  if(self.equipment.length > 0) for(eq in self.equipment) if(eq.ready && eq.assigneddice.length > 0) for(dice in eq.assigneddice) if(dice != null && dice.available()) { diceavailable = true; break; }  if(!diceavailable) { givedice(1); self.setvar(~lendeddice~|1); }  self.setvar(~slotsbackup~|[]);  self.setvar(~slotseqbackup~|[]);  self.setvar(~shockslotseqbackup~|[]);  self.setvar(~skillsbackup~|[]);  var slotsbackup = self.getvar(~slotsbackup~);  var slotseqbackup = self.getvar(~slotseqbackup~);  var shockslotseqbackup = self.getvar(~shockslotseqbackup~);  var skillsbackup = self.getvar(~skillsbackup~);  for(eq in self.equipment) {   eq.setvar(~standardcard~|1);   eq.removedice();   slotsbackup.push(eq.slots);   shockslotseqbackup.push(eq.shocked_slots);   slotseqbackup.push(eq);   eq.slots = [];   eq.shocked_slots = [];   skillsbackup.push(eq.skillsavailable.copy());   trace(eq.name);   trace(eq.skillsavailable);   trace(eq.skillsavailable.length);   if(eq.skillsavailable.length > 0) { trace(~this has skills~); for(skill in eq.skillsavailable) { trace(~making skill false~); eq.skillsavailable[eq.skillsavailable.indexOf(skill)] = false; } }   trace(eq.skillsavailable);  }    self.setvar(~slotsbackup~|slotsbackup);  self.setvar(~slotseqbackup~|slotseqbackup);  self.setvar(~shockslotseqbackup~|shockslotseqbackup);  self.setvar(~skillsbackup~|skillsbackup);  self.setvar(~selfstatusbackup~|self.status.copy());  self.setvar(~targetstatusbackup~|target.status.copy());   if(self.usecpuinsteadofdice) { self.setvar(~rolljackpot~|self.roll_jackpot); self.roll_jackpot = -1; /*thx to cody for this bit*/ }   var buttonx = 100;  var buttony = 400;   var charlist = [~A~|~B~|~C~|~D~|~E~|~F~|~G~|~H~|~I~|~J~|~K~|~L~|~M~|~N~|~O~|~P~|~Q~|~R~|~S~|~T~|~U~|~V~|~W~|~X~|~Y~|~Z~|~a~|~b~|~c~|~d~|~e~|~f~|~g~|~h~|~i~|~j~|~k~|~l~|~m~|~n~|~o~|~p~|~q~|~r~|~s~|~t~|~u~|~v~|~w~|~x~|~y~|~z~|~'~|~_~|~@~|~1~|~2~|~3~|~4~|~5~|~6~|~7~|~8~|~9~|~0~|~.~|~?~|~!~|~Bkspace~|~Confirm~];    self.setvar(~wandwish~|~[200%]~);   var i = 0;    for(char in charlist) {   i++;   var charholder = new elements.Equipment(~Equipment That Does Nothing~);   self.equipment.push(charholder);   charholder.script = ~self.equipmentused--;~;   charholder.slotpositions[0].y -= 153;   charholder.slotpositions[0].x -= 260;   charholder.displayname = char;   charholder.equipmentcol = 0;   if(char == char.toLowerCase() && char.toLowerCase() != char.toUpperCase()) charholder.displayname = ~[70%]~ + charholder.displayname;   if(charholder.displayname == ~Confirm~ # charholder.displayname == ~Bkspace~) charholder.equipmentcol = 2;   charholder.fulldescription = ~~;   charholder.height = 270;   charholder.width = 270;   charholder.x = buttonx;   charholder.y = buttony;   charholder.equipalpha = 0.0;   buttonx += 270;   if(i == 13) {    buttonx = 160;    buttony += 270;   }   if(i == 26) {    buttonx = 100;    buttony += 300;   }   if(i == 39) {    buttonx = 160;    buttony += 270;   }   if(i == 52) {    buttonx = 100;    buttony += 300;   }   if(i == 65) {    buttonx = 1620;    buttony += 270;   }  }   var tw = new motion.actuators.SimpleActuator(null|1/60|null);  tw._repeat = -1;  var s = new elements.Skill(~Against all odds_old~);   s.script = ~   var phonedone = false;   var wandwish = self.getvar(\~wandwish\~);   for(eq in self.equipment) {    if(self.getvar(\~phonephase2\~) != 1) {     if(eq.equipalpha > 0.0 && eq.getvar(\~standardcard\~) == 1) eq.equipalpha -= 0.2;     if(eq.equipalpha < 1.0 && eq.getvar(\~standardcard\~) != 1) eq.equipalpha += 0.2;     if(eq.assigneddice.length > 0 && eq.assigneddice[0] != null) {      eq.removedice();      var neweq = eq.copy();          neweq.height = 270;      neweq.width = 270;      neweq.equipalpha = eq.equipalpha;      neweq.displayname = eq.displayname;      neweq.equipmentcol = eq.equipmentcol;      neweq.slotpositions = eq.slotpositions;      neweq.script = eq.script;      self.equipment.push(neweq);      eq.name = \~deleteme\~;      eq.slots = [];      eq.equipalpha = 0;      if(eq.displayname != \~Confirm\~) {       sfx(\~jackpot_increasecounter\~);       if(eq.displayname == \~Bkspace\~ && wandwish.length > 6) wandwish = wandwish.substr(0|wandwish.length - 1);       else       if(eq.displayname.substr(0|1) == \~_\~) wandwish += \~_\~;       else       if(eq.displayname.substr(0|1) == \~[\~) wandwish += eq.displayname.substr(5|1);       else       if(eq.displayname != \~Bkspace\~) wandwish += eq.displayname.substr(0|1);      }      else {       sfx(\~_thinghappens\~);       self.setvar(\~phonephase2\~|1);      }     }    }    else {     if(eq.equipalpha <= 1.0 && eq.getvar(\~standardcard\~) == 1) {      eq.equipalpha += 0.2;     }     if(eq.equipalpha > 0.0 && eq.getvar(\~standardcard\~) != 1) {      eq.removedice();      eq.equipalpha -= 0.2;      eq.slots = [];      eq.script = \~self.equipmentused--; self.equipmenthistory.pop();\~;     }     if(eq.equipalpha <= 0.0 && eq.getvar(\~standardcard\~) != 1) {      eq.name = \~deleteme\~;      phonedone = true;     }    }   }      new elements.CombatCommand(\~msg\~|wandwish).execute();   self.setvar(\~wandwish\~|wandwish);      removeequipment(\~deleteme\~);   if(self.doendturnnow) {    trace(\~ending turn\~);    for(eq in self.equipment) {     if(eq.getvar(\~standardcard\~) == 1) {      eq.equipalpha = 1.0;      var importantindex = self.getvar(\~slotseqbackup\~).indexOf(eq);      eq.slots = self.getvar(\~slotsbackup\~)[importantindex];      eq.shocked_slots = self.getvar(\~shockslotseqbackup\~)[importantindex];      eq.skillsavailable = self.getvar(\~skillsbackup\~)[importantindex];      if(self.usecpuinsteadofdice) self.roll_jackpot = self.getvar(\~rolljackpot\~);     }     else {      eq.name = \~deleteme\~;     }    }    removeequipment(\~deleteme\~);    removeequipment(\~Equipment That Does Nothing\~);    self.resetvar(\~slotsbackup\~);    self.resetvar(\~slotseqbackup\~);    self.resetvar(\~shockslotseqbackup\~);    self.resetvar(\~skillsbackup\~);    self.resetvar(\~rolljackpot\~);    new elements.CombatCommand(\~msg\~|\~\~).execute();    wandwish = wandwish.split(\~[200%]\~)[1].split(\~_\~).join(\~ \~);    var exceptions = getcolumn(loaddata(\~ncrmod/wishredirects\~)|\~input\~);    var redirects = getcolumn(loaddata(\~ncrmod/wishredirects\~)|\~redirect\~);    if(exceptions.indexOf(wandwish) != -1) wandwish = redirects[exceptions.indexOf(wandwish)];    if(getequipmentlist().indexOf(wandwish) != -1) {     if(self.getvar(\~ncrrobotepisode4\~) == 1 && self.getvar(\~ncrrobotepisode4wishlist\~).indexOf(wandwish) != -1) { self.textparticle(\~Already wished!\~); }     else {      if(self.getvar(\~ncrrobotepisode4\~) == 1) {       self.setvar(\~ncrrobotepisode4wishlist\~|self.getvar(\~ncrrobotepisode4wishlist\~).concat([wandwish]));       var familylist = loadtext(\~ncrmod/wishfamilies\~);       for(i in 0...familylist.length)  {        var familylistsplit = familylist[i].split(\~|\~);        if(familylistsplit.indexOf(wandwish) != -1) {         self.setvar(\~ncrrobotepisode4wishlist\~|self.getvar(\~ncrrobotepisode4wishlist\~).concat(familylistsplit));        }       }       if(!new elements.Equipment(wandwish).hastag(\~powercard\~)) {        if(wandwish.substr(wandwish.length - 1|1) == \~?\~) {         self.setvar(\~ncrrobotepisode4wishlist\~|self.getvar(\~ncrrobotepisode4wishlist\~).concat([wandwish.substr(0|wandwish.length - 1)]));        }        else {         self.setvar(\~ncrrobotepisode4wishlist\~|self.getvar(\~ncrrobotepisode4wishlist\~).concat([wandwish + \~?\~]));        }       }      }      var newcard = new elements.Equipment(wandwish);      var replacecard = self.equipment[self.equipment.indexOf(self.getvar(\~wishingcard\~))];      trace(\~card made\~);      newcard.x = self.getvar(\~wishingcardx\~);      newcard.y = self.getvar(\~wishingcardy\~);      self.equipment[self.equipment.indexOf(self.getvar(\~wishingcard\~))] = newcard;      trace(\~card replaced\~);      newcard.animate(\~flashandshake\~);      self.setvar(\~doonthis\~|newcard); var estandardize = \~var e = self.getvar(\\\~doonthis\\\~); \~; var doscripts = new elements.Skill(\~Against all odds_old\~); doscripts.script = estandardize + newcard.scriptbeforecombat; doscripts.execute(self|target); doscripts.script = estandardize + newcard.scriptbeforestartturn; doscripts.execute(self|target); doscripts.script = estandardize + newcard.scriptonstartturn; doscripts.execute(self|target); self.resetvar(\~doonthis\~);      newcard.arrangeslots();      self.createsparedice(newcard);      trace(\~card flashed\~);     }    }    else self.textparticle(\~Invalid wish!\~);    self.resetvar(\~wishingcard\~); self.resetvar(\~diditwork\~);    self.getvar(\~wishactuator\~).stop();    self.status = self.getvar(\~selfstatusbackup\~);    target.status = self.getvar(\~targetstatusbackup\~);    self.resetvar(\~selfstatusbackup\~);    self.resetvar(\~targetstatusbackup\~);    self.resetvar(\~phonephase2\~);    self.resetvar(\~wishactuator\~);    self.resetvar(\~wandwish\~);    if(self.getvar(\~lendeddice\~) == 1) { for(dice in self.dicepool) { if(dice.available() && dice.basevalue == 1) { dice.animate(\~disappear\~); break; } } }    self.resetvar(\~lendeddice\~);   }      if(phonedone) {    for(eq in self.equipment) {     if(eq.getvar(\~standardcard\~) == 1) {      eq.equipalpha = 1.0;      var importantindex = self.getvar(\~slotseqbackup\~).indexOf(eq);      eq.slots = self.getvar(\~slotsbackup\~)[importantindex];      eq.shocked_slots = self.getvar(\~shockslotseqbackup\~)[importantindex];      eq.skillsavailable = self.getvar(\~skillsbackup\~)[importantindex];      if(self.usecpuinsteadofdice) self.roll_jackpot = self.getvar(\~rolljackpot\~);     }    }    removeequipment(\~Equipment That Does Nothing\~);    self.resetvar(\~slotsbackup\~);    self.resetvar(\~slotseqbackup\~);    self.resetvar(\~shockslotseqbackup\~);    self.resetvar(\~skillsbackup\~);    self.resetvar(\~rolljackpot\~);    new elements.CombatCommand(\~msg\~|\~\~).execute();    wandwish = wandwish.split(\~[200%]\~)[1].split(\~_\~).join(\~ \~);    var exceptions = getcolumn(loaddata(\~ncrmod/wishredirects\~)|\~input\~);    var redirects = getcolumn(loaddata(\~ncrmod/wishredirects\~)|\~redirect\~);    if(exceptions.indexOf(wandwish) != -1) wandwish = redirects[exceptions.indexOf(wandwish)];    if(getequipmentlist().indexOf(wandwish) != -1) {     if(self.getvar(\~ncrrobotepisode4\~) == 1 && self.getvar(\~ncrrobotepisode4wishlist\~).indexOf(wandwish) != -1) { self.textparticle(\~Already wished!\~); }     else {      if(self.getvar(\~ncrrobotepisode4\~) == 1) {       self.setvar(\~ncrrobotepisode4wishlist\~|self.getvar(\~ncrrobotepisode4wishlist\~).concat([wandwish]));       var familylist = loadtext(\~ncrmod/wishfamilies\~);       for(i in 0...familylist.length)  {        var familylistsplit = familylist[i].split(\~|\~);        if(familylistsplit.indexOf(wandwish) != -1) {         self.setvar(\~ncrrobotepisode4wishlist\~|self.getvar(\~ncrrobotepisode4wishlist\~).concat(familylistsplit));        }       }       if(!new elements.Equipment(wandwish).hastag(\~powercard\~)) {        if(wandwish.substr(wandwish.length - 1|1) == \~?\~) {         self.setvar(\~ncrrobotepisode4wishlist\~|self.getvar(\~ncrrobotepisode4wishlist\~).concat([wandwish.substr(0|wandwish.length - 1)]));        }        else {         self.setvar(\~ncrrobotepisode4wishlist\~|self.getvar(\~ncrrobotepisode4wishlist\~).concat([wandwish + \~?\~]));        }       }      }      var newcard = new elements.Equipment(wandwish);      var replacecard = self.equipment[self.equipment.indexOf(self.getvar(\~wishingcard\~))];      trace(\~card made\~);      newcard.x = self.getvar(\~wishingcardx\~);      newcard.y = self.getvar(\~wishingcardy\~);      self.equipment[self.equipment.indexOf(self.getvar(\~wishingcard\~))] = newcard;      trace(\~card replaced\~);      newcard.animate(\~flashandshake\~);      self.setvar(\~doonthis\~|newcard); var estandardize = \~var e = self.getvar(\\\~doonthis\\\~); \~; var doscripts = new elements.Skill(\~Against all odds_old\~); doscripts.script = estandardize + newcard.scriptbeforecombat; doscripts.execute(self|target); doscripts.script = estandardize + newcard.scriptbeforestartturn; doscripts.execute(self|target); doscripts.script = estandardize + newcard.scriptonstartturn; doscripts.execute(self|target); self.resetvar(\~doonthis\~);      newcard.arrangeslots();      self.createsparedice(newcard);      trace(\~card flashed\~);     }    }    else self.textparticle(\~Invalid wish!\~);    self.resetvar(\~wishingcard\~); self.resetvar(\~diditwork\~);    self.getvar(\~wishactuator\~).stop();    self.status = self.getvar(\~selfstatusbackup\~);    target.status = self.getvar(\~targetstatusbackup\~);    self.resetvar(\~selfstatusbackup\~);    self.resetvar(\~targetstatusbackup\~);    self.resetvar(\~phonephase2\~);    self.resetvar(\~wishactuator\~);    self.resetvar(\~wandwish\~);    if(self.getvar(\~lendeddice\~) == 1) { for(dice in self.dicepool) { if(dice.available() && dice.basevalue == 1) { dice.animate(\~disappear\~); break; } } }    self.resetvar(\~lendeddice\~);   }  ~;  tw.onRepeat(s.execute|[self|target]);  self.setvar(~wishactuator~|tw);  tw.move(); },Best Friend,NORMAL,,BRIGHTCYAN,change_power,change_power,,,,YES,,excludefromrandomlists|cannotsteal,,,,,,,,,self.setvar(~wishingcardx~|e.x); self.setvar(~wishingcardy~|e.y);,,e.maintainfury = true; e.preventdefault = true;,
Blessed Wand of Wishing_upgraded,Replace with any upgraded|item you can name[;] and|return the dice,2,bonus(-9999999999999); givedice(d); if(!self.isplayer) self.textparticle(~No effect!~); else if(!simulation) {  var selfscript = ~removeequipment(\~Equipment That Does Nothing\~);~; if(self.scriptendturn.indexOf(selfscript) == -1) self.scriptendturn = selfscript + self.scriptendturn;  self.setvar(~wishingcard~|e);  var diceavailable = false;  if(self.dicepool.length > 0) for(dice in self.dicepool) if(dice.available()) { diceavailable = true; break; }  if(self.equipment.length > 0) for(eq in self.equipment) if(eq.ready && eq.assigneddice.length > 0) for(dice in eq.assigneddice) if(dice != null && dice.available()) { diceavailable = true; break; }  if(!diceavailable) { givedice(1); self.setvar(~lendeddice~|1); }  self.setvar(~slotsbackup~|[]);  self.setvar(~slotseqbackup~|[]);  self.setvar(~shockslotseqbackup~|[]);  self.setvar(~skillsbackup~|[]);  var slotsbackup = self.getvar(~slotsbackup~);  var slotseqbackup = self.getvar(~slotseqbackup~);  var shockslotseqbackup = self.getvar(~shockslotseqbackup~);  var skillsbackup = self.getvar(~skillsbackup~);  for(eq in self.equipment) {   eq.setvar(~standardcard~|1);   eq.removedice();   slotsbackup.push(eq.slots);   shockslotseqbackup.push(eq.shocked_slots);   slotseqbackup.push(eq);   eq.slots = [];   eq.shocked_slots = [];   skillsbackup.push(eq.skillsavailable.copy());   trace(eq.name);   trace(eq.skillsavailable);   trace(eq.skillsavailable.length);   if(eq.skillsavailable.length > 0) { trace(~this has skills~); for(skill in eq.skillsavailable) { trace(~making skill false~); eq.skillsavailable[eq.skillsavailable.indexOf(skill)] = false; } }   trace(eq.skillsavailable);  }    self.setvar(~slotsbackup~|slotsbackup);  self.setvar(~slotseqbackup~|slotseqbackup);  self.setvar(~shockslotseqbackup~|shockslotseqbackup);  self.setvar(~skillsbackup~|skillsbackup);  self.setvar(~selfstatusbackup~|self.status.copy());  self.setvar(~targetstatusbackup~|target.status.copy());   if(self.usecpuinsteadofdice) { self.setvar(~rolljackpot~|self.roll_jackpot); self.roll_jackpot = -1; /*thx to cody for this bit*/ }   var buttonx = 100;  var buttony = 400;   var charlist = [~A~|~B~|~C~|~D~|~E~|~F~|~G~|~H~|~I~|~J~|~K~|~L~|~M~|~N~|~O~|~P~|~Q~|~R~|~S~|~T~|~U~|~V~|~W~|~X~|~Y~|~Z~|~a~|~b~|~c~|~d~|~e~|~f~|~g~|~h~|~i~|~j~|~k~|~l~|~m~|~n~|~o~|~p~|~q~|~r~|~s~|~t~|~u~|~v~|~w~|~x~|~y~|~z~|~'~|~_~|~@~|~1~|~2~|~3~|~4~|~5~|~6~|~7~|~8~|~9~|~0~|~.~|~?~|~!~|~Bkspace~|~Confirm~];    self.setvar(~wandwish~|~[200%]~);   var i = 0;    for(char in charlist) {   i++;   var charholder = new elements.Equipment(~Equipment That Does Nothing~);   self.equipment.push(charholder);   charholder.script = ~self.equipmentused--;~;   charholder.slotpositions[0].y -= 153;   charholder.slotpositions[0].x -= 260;   charholder.displayname = char;   charholder.equipmentcol = 0;   if(char == char.toLowerCase() && char.toLowerCase() != char.toUpperCase()) charholder.displayname = ~[70%]~ + charholder.displayname;   if(charholder.displayname == ~Confirm~ # charholder.displayname == ~Bkspace~) charholder.equipmentcol = 2;   charholder.fulldescription = ~~;   charholder.height = 270;   charholder.width = 270;   charholder.x = buttonx;   charholder.y = buttony;   charholder.equipalpha = 0.0;   buttonx += 270;   if(i == 13) {    buttonx = 160;    buttony += 270;   }   if(i == 26) {    buttonx = 100;    buttony += 300;   }   if(i == 39) {    buttonx = 160;    buttony += 270;   }   if(i == 52) {    buttonx = 100;    buttony += 300;   }   if(i == 65) {    buttonx = 1620;    buttony += 270;   }  }   var tw = new motion.actuators.SimpleActuator(null|1/60|null);  tw._repeat = -1;  var s = new elements.Skill(~Against all odds_old~);   s.script = ~   var phonedone = false;   var wandwish = self.getvar(\~wandwish\~);   for(eq in self.equipment) {    if(self.getvar(\~phonephase2\~) != 1) {     if(eq.equipalpha > 0.0 && eq.getvar(\~standardcard\~) == 1) eq.equipalpha -= 0.2;     if(eq.equipalpha < 1.0 && eq.getvar(\~standardcard\~) != 1) eq.equipalpha += 0.2;     if(eq.assigneddice.length > 0 && eq.assigneddice[0] != null) {      eq.removedice();      var neweq = eq.copy();          neweq.height = 270;      neweq.width = 270;      neweq.equipalpha = eq.equipalpha;      neweq.displayname = eq.displayname;      neweq.equipmentcol = eq.equipmentcol;      neweq.slotpositions = eq.slotpositions;      neweq.script = eq.script;      self.equipment.push(neweq);      eq.name = \~deleteme\~;      eq.slots = [];      eq.equipalpha = 0;      if(eq.displayname != \~Confirm\~) {       sfx(\~jackpot_increasecounter\~);       if(eq.displayname == \~Bkspace\~ && wandwish.length > 6) wandwish = wandwish.substr(0|wandwish.length - 1);       else       if(eq.displayname.substr(0|1) == \~_\~) wandwish += \~_\~;       else       if(eq.displayname.substr(0|1) == \~[\~) wandwish += eq.displayname.substr(5|1);       else       if(eq.displayname != \~Bkspace\~) wandwish += eq.displayname.substr(0|1);      }      else {       sfx(\~_thinghappens\~);       self.setvar(\~phonephase2\~|1);      }     }    }    else {     if(eq.equipalpha <= 1.0 && eq.getvar(\~standardcard\~) == 1) {      eq.equipalpha += 0.2;     }     if(eq.equipalpha > 0.0 && eq.getvar(\~standardcard\~) != 1) {      eq.removedice();      eq.equipalpha -= 0.2;      eq.slots = [];      eq.script = \~self.equipmentused--; self.equipmenthistory.pop();\~;     }     if(eq.equipalpha <= 0.0 && eq.getvar(\~standardcard\~) != 1) {      eq.name = \~deleteme\~;      phonedone = true;     }    }   }      new elements.CombatCommand(\~msg\~|wandwish + \~+\~).execute();   self.setvar(\~wandwish\~|wandwish);      removeequipment(\~deleteme\~);   if(self.doendturnnow) {    trace(\~ending turn\~);    for(eq in self.equipment) {     if(eq.getvar(\~standardcard\~) == 1) {      eq.equipalpha = 1.0;      var importantindex = self.getvar(\~slotseqbackup\~).indexOf(eq);      eq.slots = self.getvar(\~slotsbackup\~)[importantindex];      eq.shocked_slots = self.getvar(\~shockslotseqbackup\~)[importantindex];      eq.skillsavailable = self.getvar(\~skillsbackup\~)[importantindex];      if(self.usecpuinsteadofdice) self.roll_jackpot = self.getvar(\~rolljackpot\~);     }     else {      eq.name = \~deleteme\~;     }    }    removeequipment(\~deleteme\~);    removeequipment(\~Equipment That Does Nothing\~);    self.resetvar(\~slotsbackup\~);    self.resetvar(\~slotseqbackup\~);    self.resetvar(\~shockslotseqbackup\~);    self.resetvar(\~skillsbackup\~);    self.resetvar(\~rolljackpot\~);    new elements.CombatCommand(\~msg\~|\~\~).execute();    wandwish = wandwish.split(\~[200%]\~)[1].split(\~_\~).join(\~ \~);    var exceptions = getcolumn(loaddata(\~ncrmod/wishredirects\~)|\~input\~);    var redirects = getcolumn(loaddata(\~ncrmod/wishredirects\~)|\~redirect\~);    if(exceptions.indexOf(wandwish) != -1) wandwish = redirects[exceptions.indexOf(wandwish)];    var wrong = false;    var newcard = null;    if(getequipmentlist().indexOf(wandwish) != -1) {     if(self.getvar(\~ncrrobotepisode4\~) == 1 && self.getvar(\~ncrrobotepisode4wishlist\~).indexOf(wandwish) != -1) { self.textparticle(\~Already wished!\~); wrong = true; }     else {      newcard = new elements.Equipment(wandwish);      if(newcard.upgradetype == \~\~) { newcard.name = \~Equipment That Does Nothing\~; self.equipment.push(newcard); removeequipment(\~Equipment That Does Nothing\~); wrong = true; }     }    }    else { wrong = true; }    if(!wrong) {     if(self.getvar(\~ncrrobotepisode4\~) == 1) {      self.setvar(\~ncrrobotepisode4wishlist\~|self.getvar(\~ncrrobotepisode4wishlist\~).concat([wandwish]));      var familylist = loadtext(\~ncrmod/wishfamilies\~);      for(i in 0...familylist.length)  {       familylist[i] = familylist[i].split(\~|\~);       if(familylistsplit.indexOf(wandwish) != -1) {        self.setvar(\~ncrrobotepisode4wishlist\~|self.getvar(\~ncrrobotepisode4wishlist\~).concat(familylistsplit));       }      }      if(!new elements.Equipment(wandwish).hastag(\~powercard\~)) {       if(wandwish.substr(wandwish.length - 1|1) == \~?\~) {        self.setvar(\~ncrrobotepisode4wishlist\~|self.getvar(\~ncrrobotepisode4wishlist\~).concat([wandwish.substr(0|wandwish.length - 1)]));       }       else {        self.setvar(\~ncrrobotepisode4wishlist\~|self.getvar(\~ncrrobotepisode4wishlist\~).concat([wandwish + \~?\~]));       }      }     }     newcard = new elements.Equipment(wandwish + \~+\~);     var replacecard = self.equipment[self.equipment.indexOf(self.getvar(\~wishingcard\~))];     trace(\~card made\~);     newcard.x = self.getvar(\~wishingcardx\~);     newcard.y = self.getvar(\~wishingcardy\~);     self.equipment[self.equipment.indexOf(self.getvar(\~wishingcard\~))] = newcard;     trace(\~card replaced\~);     newcard.animate(\~flashandshake\~);     self.setvar(\~doonthis\~|newcard); var estandardize = \~var e = self.getvar(\\\~doonthis\\\~); \~; var doscripts = new elements.Skill(\~Against all odds_old\~); doscripts.script = estandardize + newcard.scriptbeforecombat; doscripts.execute(self|target); doscripts.script = estandardize + newcard.scriptbeforestartturn; doscripts.execute(self|target); doscripts.script = estandardize + newcard.scriptonstartturn; doscripts.execute(self|target); self.resetvar(\~doonthis\~);     newcard.arrangeslots();     self.createsparedice(newcard);     trace(\~card flashed\~);    }    else self.textparticle(\~Invalid wish!\~);    self.resetvar(\~wishingcard\~); self.resetvar(\~diditwork\~);    self.getvar(\~wishactuator\~).stop();    self.status = self.getvar(\~selfstatusbackup\~);    target.status = self.getvar(\~targetstatusbackup\~);    self.resetvar(\~selfstatusbackup\~);    self.resetvar(\~targetstatusbackup\~);    self.resetvar(\~phonephase2\~);    self.resetvar(\~wishactuator\~);    self.resetvar(\~wandwish\~);    if(self.getvar(\~lendeddice\~) == 1) { for(dice in self.dicepool) { if(dice.available() && dice.basevalue == 1) { dice.animate(\~disappear\~); break; } } }    self.resetvar(\~lendeddice\~);   }      if(phonedone) {    for(eq in self.equipment) {     if(eq.getvar(\~standardcard\~) == 1) {      eq.equipalpha = 1.0;      var importantindex = self.getvar(\~slotseqbackup\~).indexOf(eq);      eq.slots = self.getvar(\~slotsbackup\~)[importantindex];      eq.shocked_slots = self.getvar(\~shockslotseqbackup\~)[importantindex];      eq.skillsavailable = self.getvar(\~skillsbackup\~)[importantindex];      if(self.usecpuinsteadofdice) self.roll_jackpot = self.getvar(\~rolljackpot\~);     }    }    removeequipment(\~Equipment That Does Nothing\~);    self.resetvar(\~slotsbackup\~);    self.resetvar(\~slotseqbackup\~);    self.resetvar(\~shockslotseqbackup\~);    self.resetvar(\~skillsbackup\~);    self.resetvar(\~rolljackpot\~);    new elements.CombatCommand(\~msg\~|\~\~).execute();    wandwish = wandwish.split(\~[200%]\~)[1].split(\~_\~).join(\~ \~);    var exceptions = getcolumn(loaddata(\~ncrmod/wishredirects\~)|\~input\~);    var redirects = getcolumn(loaddata(\~ncrmod/wishredirects\~)|\~redirect\~);    if(exceptions.indexOf(wandwish) != -1) wandwish = redirects[exceptions.indexOf(wandwish)];    var wrong = false;    var newcard = null;    if(getequipmentlist().indexOf(wandwish) != -1) {     if(self.getvar(\~ncrrobotepisode4\~) == 1 && self.getvar(\~ncrrobotepisode4wishlist\~).indexOf(wandwish) != -1) { self.textparticle(\~Already wished!\~); wrong = true; }     else {      newcard = new elements.Equipment(wandwish);      if(newcard.upgradetype == \~\~) { newcard.name = \~Equipment That Does Nothing\~; self.equipment.push(newcard); removeequipment(\~Equipment That Does Nothing\~); wrong = true; }     }    }    else { wrong = true; }    if(!wrong) {     if(self.getvar(\~ncrrobotepisode4\~) == 1) {      self.setvar(\~ncrrobotepisode4wishlist\~|self.getvar(\~ncrrobotepisode4wishlist\~).concat([wandwish]));      var familylist = loadtext(\~ncrmod/wishfamilies\~);      for(i in 0...familylist.length)  {       var familylistsplit = familylist[i].split(\~|\~);       if(familylistsplit.indexOf(wandwish) != -1) {        self.setvar(\~ncrrobotepisode4wishlist\~|self.getvar(\~ncrrobotepisode4wishlist\~).concat(familylistsplit));       }      }      if(!new elements.Equipment(wandwish).hastag(\~powercard\~)) {       if(wandwish.substr(wandwish.length - 1|1) == \~?\~) {        self.setvar(\~ncrrobotepisode4wishlist\~|self.getvar(\~ncrrobotepisode4wishlist\~).concat([wandwish.substr(0|wandwish.length - 1)]));       }       else {        self.setvar(\~ncrrobotepisode4wishlist\~|self.getvar(\~ncrrobotepisode4wishlist\~).concat([wandwish + \~?\~]));       }      }     }     newcard = new elements.Equipment(wandwish + \~+\~);     var replacecard = self.equipment[self.equipment.indexOf(self.getvar(\~wishingcard\~))];     trace(\~card made\~);     newcard.x = self.getvar(\~wishingcardx\~);     newcard.y = self.getvar(\~wishingcardy\~);     self.equipment[self.equipment.indexOf(self.getvar(\~wishingcard\~))] = newcard;     trace(\~card replaced\~);     newcard.animate(\~flashandshake\~);     self.setvar(\~doonthis\~|newcard); var estandardize = \~var e = self.getvar(\\\~doonthis\\\~); \~; var doscripts = new elements.Skill(\~Against all odds_old\~); doscripts.script = estandardize + newcard.scriptbeforecombat; doscripts.execute(self|target); doscripts.script = estandardize + newcard.scriptbeforestartturn; doscripts.execute(self|target); doscripts.script = estandardize + newcard.scriptonstartturn; doscripts.execute(self|target); self.resetvar(\~doonthis\~);     newcard.arrangeslots();     self.createsparedice(newcard);     trace(\~card flashed\~);    }    else self.textparticle(\~Invalid wish!\~);    self.resetvar(\~wishingcard\~); self.resetvar(\~diditwork\~);    self.getvar(\~wishactuator\~).stop();    self.status = self.getvar(\~selfstatusbackup\~);    target.status = self.getvar(\~targetstatusbackup\~);    self.resetvar(\~selfstatusbackup\~);    self.resetvar(\~targetstatusbackup\~);    self.resetvar(\~phonephase2\~);    self.resetvar(\~wishactuator\~);    self.resetvar(\~wandwish\~);    if(self.getvar(\~lendeddice\~) == 1) { for(dice in self.dicepool) { if(dice.available() && dice.basevalue == 1) { dice.animate(\~disappear\~); break; } } }    self.resetvar(\~lendeddice\~);   }  ~;  tw.onRepeat(s.execute|[self|target]);  self.setvar(~wishactuator~|tw);  tw.move(); },Best Friend,NORMAL,,BRIGHTCYAN,,,,,,YES,,excludefromrandomlists|cannotsteal,,,,,,,,,self.setvar(~wishingcardx~|e.x); self.setvar(~wishingcardy~|e.y);,,e.maintainfury = true; e.preventdefault = true;,
Blessed Wand of Wishing_downgraded,Replace this with any item|you can spell backward[;]|return the dice,2,bonus(-9999999999999); givedice(d); if(!self.isplayer) self.textparticle(~No effect!~); else if(!simulation) {  var selfscript = ~removeequipment(\~Equipment That Does Nothing\~);~; if(self.scriptendturn.indexOf(selfscript) == -1) self.scriptendturn = selfscript + self.scriptendturn;  self.setvar(~wishingcard~|e);  var diceavailable = false;  if(self.dicepool.length > 0) for(dice in self.dicepool) if(dice.available()) { diceavailable = true; break; }  if(self.equipment.length > 0) for(eq in self.equipment) if(eq.ready && eq.assigneddice.length > 0) for(dice in eq.assigneddice) if(dice != null && dice.available()) { diceavailable = true; break; }  if(!diceavailable) { givedice(1); self.setvar(~lendeddice~|1); }  self.setvar(~slotsbackup~|[]);  self.setvar(~slotseqbackup~|[]);  self.setvar(~shockslotseqbackup~|[]);  self.setvar(~skillsbackup~|[]);  var slotsbackup = self.getvar(~slotsbackup~);  var slotseqbackup = self.getvar(~slotseqbackup~);  var shockslotseqbackup = self.getvar(~shockslotseqbackup~);  var skillsbackup = self.getvar(~skillsbackup~);  for(eq in self.equipment) {   eq.setvar(~standardcard~|1);   eq.removedice();   slotsbackup.push(eq.slots);   shockslotseqbackup.push(eq.shocked_slots);   slotseqbackup.push(eq);   eq.slots = [];   eq.shocked_slots = [];   skillsbackup.push(eq.skillsavailable.copy());   trace(eq.name);   trace(eq.skillsavailable);   trace(eq.skillsavailable.length);   if(eq.skillsavailable.length > 0) { trace(~this has skills~); for(skill in eq.skillsavailable) { trace(~making skill false~); eq.skillsavailable[eq.skillsavailable.indexOf(skill)] = false; } }   trace(eq.skillsavailable);  }  self.setvar(~slotsbackup~|slotsbackup);  self.setvar(~slotseqbackup~|slotseqbackup);  self.setvar(~shockslotseqbackup~|shockslotseqbackup);  self.setvar(~skillsbackup~|skillsbackup);  self.setvar(~selfstatusbackup~|self.status.copy());  self.setvar(~targetstatusbackup~|target.status.copy());   if(self.usecpuinsteadofdice) { self.setvar(~rolljackpot~|self.roll_jackpot); self.roll_jackpot = -1; /*thx to cody for this bit*/ }   var buttonx = 100;  var buttony = 400;   var charlist = [~A~|~B~|~C~|~D~|~E~|~F~|~G~|~H~|~I~|~J~|~K~|~L~|~M~|~N~|~O~|~P~|~Q~|~R~|~S~|~T~|~U~|~V~|~W~|~X~|~Y~|~Z~|~a~|~b~|~c~|~d~|~e~|~f~|~g~|~h~|~i~|~j~|~k~|~l~|~m~|~n~|~o~|~p~|~q~|~r~|~s~|~t~|~u~|~v~|~w~|~x~|~y~|~z~|~'~|~_~|~@~|~1~|~2~|~3~|~4~|~5~|~6~|~7~|~8~|~9~|~0~|~.~|~?~|~!~|~Bkspace~|~Confirm~];    self.setvar(~wandwish~|~[200%]~);   var i = 0;    for(char in charlist) {   i++;   var charholder = new elements.Equipment(~Equipment That Does Nothing~);   self.equipment.push(charholder);   charholder.script = ~self.equipmentused--;~;   charholder.slotpositions[0].y -= 153;   charholder.slotpositions[0].x -= 260;   charholder.displayname = char;   charholder.equipmentcol = 0;   if(char == char.toLowerCase() && char.toLowerCase() != char.toUpperCase()) charholder.displayname = ~[70%]~ + charholder.displayname;   if(charholder.displayname == ~Confirm~ # charholder.displayname == ~Bkspace~) charholder.equipmentcol = 2;   charholder.fulldescription = ~~;   charholder.height = 270;   charholder.width = 270;   charholder.x = buttonx;   charholder.y = buttony;   charholder.equipalpha = 0.0;   buttonx += 270;   if(i == 13) {    buttonx = 160;    buttony += 270;   }   if(i == 26) {    buttonx = 100;    buttony += 300;   }   if(i == 39) {    buttonx = 160;    buttony += 270;   }   if(i == 52) {    buttonx = 100;    buttony += 300;   }   if(i == 65) {    buttonx = 1620;    buttony += 270;   }  }   var tw = new motion.actuators.SimpleActuator(null|1/60|null);  tw._repeat = -1;  var s = new elements.Skill(~Against all odds_old~);  s.script = ~   var phonedone = false;   var wandwish = self.getvar(\~wandwish\~);   for(eq in self.equipment) {    if(self.getvar(\~phonephase2\~) != 1) {     if(eq.equipalpha > 0.0 && eq.getvar(\~standardcard\~) == 1) eq.equipalpha -= 0.2;     if(eq.equipalpha < 1.0 && eq.getvar(\~standardcard\~) != 1) eq.equipalpha += 0.2;     if(eq.assigneddice.length > 0 && eq.assigneddice[0] != null) {      eq.removedice();      var neweq = eq.copy();          neweq.height = 270;      neweq.width = 270;      neweq.equipalpha = eq.equipalpha;      neweq.displayname = eq.displayname;      neweq.equipmentcol = eq.equipmentcol;      neweq.slotpositions = eq.slotpositions;      neweq.script = eq.script;      self.equipment.push(neweq);      eq.name = \~deleteme\~;      eq.slots = [];      eq.equipalpha = 0;      if(eq.displayname != \~Confirm\~) {       sfx(\~jackpot_increasecounter\~);       if(eq.displayname == \~Bkspace\~ && wandwish.length > 6) wandwish = wandwish.substr(0|wandwish.length - 1);       else       if(eq.displayname.substr(0|1) == \~_\~) wandwish += \~_\~;       else       if(eq.displayname.substr(0|1) == \~[\~) wandwish += eq.displayname.substr(5|1);       else       if(eq.displayname != \~Bkspace\~) wandwish += eq.displayname.substr(0|1);      }      else {       sfx(\~_thinghappens\~);       self.setvar(\~phonephase2\~|1);      }     }    }    else {     if(eq.equipalpha <= 1.0 && eq.getvar(\~standardcard\~) == 1) {      eq.equipalpha += 0.2;     }     if(eq.equipalpha > 0.0 && eq.getvar(\~standardcard\~) != 1) {      eq.removedice();      eq.equipalpha -= 0.2;      eq.slots = [];      eq.script = \~self.equipmentused--; self.equipmenthistory.pop();\~;     }     if(eq.equipalpha <= 0.0 && eq.getvar(\~standardcard\~) != 1) {      eq.name = \~deleteme\~;      phonedone = true;     }    }   }      new elements.CombatCommand(\~msg\~|wandwish).execute();   self.setvar(\~wandwish\~|wandwish);      removeequipment(\~deleteme\~);   if(self.doendturnnow) {    trace(\~ending turn\~);    for(eq in self.equipment) {     if(eq.getvar(\~standardcard\~) == 1) {      eq.equipalpha = 1.0;      eq.slots = self.getvar(\~slotsbackup\~)[self.getvar(\~slotseqbackup\~).indexOf(eq)];      eq.shocked_slots = self.getvar(\~shockslotseqbackup\~)[self.getvar(\~slotseqbackup\~).indexOf(eq)];      eq.skillsavailable = self.getvar(\~skillsbackup\~)[self.getvar(\~slotseqbackup\~).indexOf(eq)];      if(self.usecpuinsteadofdice) self.roll_jackpot = self.getvar(\~rolljackpot\~);     }     else {      eq.name = \~deleteme\~;     }    }    removeequipment(\~deleteme\~);    removeequipment(\~Equipment That Does Nothing\~);    self.resetvar(\~slotsbackup\~);    self.resetvar(\~slotseqbackup\~);    self.resetvar(\~shockslotseqbackup\~);    self.resetvar(\~skillsbackup\~);    self.resetvar(\~rolljackpot\~);    new elements.CombatCommand(\~msg\~|\~\~).execute();    wandwish = wandwish.split(\~[200%]\~)[1].split(\~_\~).join(\~ \~);    var wandwisharr = wandwish.split(\~\~);    wandwish = \~\~;    for(char in wandwisharr) wandwish = char + wandwish;    var exceptions = getcolumn(loaddata(\~ncrmod/wishredirects\~)|\~input\~);    var redirects = getcolumn(loaddata(\~ncrmod/wishredirects\~)|\~redirect\~);    if(exceptions.indexOf(wandwish) != -1) wandwish = redirects[exceptions.indexOf(wandwish)];    if(getequipmentlist().indexOf(wandwish) != -1) {     if(self.getvar(\~ncrrobotepisode4\~) == 1 && self.getvar(\~ncrrobotepisode4wishlist\~).indexOf(wandwish) != -1) { self.textparticle(\~Already wished!\~); }     else {      if(self.getvar(\~ncrrobotepisode4\~) == 1) {       self.setvar(\~ncrrobotepisode4wishlist\~|self.getvar(\~ncrrobotepisode4wishlist\~).concat([wandwish]));       var familylist = loadtext(\~ncrmod/wishfamilies\~);       for(i in 0...familylist.length)  {        if(familylistsplit.indexOf(wandwish) != -1) {         self.setvar(\~ncrrobotepisode4wishlist\~|self.getvar(\~ncrrobotepisode4wishlist\~).concat(familylistsplit));        }       }       if(!new elements.Equipment(wandwish).hastag(\~powercard\~)) {        if(wandwish.substr(wandwish.length - 1|1) == \~?\~) {         self.setvar(\~ncrrobotepisode4wishlist\~|self.getvar(\~ncrrobotepisode4wishlist\~).concat([wandwish.substr(0|wandwish.length - 1)]));        }        else {         self.setvar(\~ncrrobotepisode4wishlist\~|self.getvar(\~ncrrobotepisode4wishlist\~).concat([wandwish + \~?\~]));        }       }      }      var newcard = new elements.Equipment(wandwish);      var replacecard = self.equipment[self.equipment.indexOf(self.getvar(\~wishingcard\~))];      trace(\~card made\~);      newcard.x = self.getvar(\~wishingcardx\~);      newcard.y = self.getvar(\~wishingcardy\~);      self.equipment[self.equipment.indexOf(self.getvar(\~wishingcard\~))] = newcard;      trace(\~card replaced\~);      newcard.animate(\~flashandshake\~);      self.setvar(\~doonthis\~|newcard); var estandardize = \~var e = self.getvar(\\\~doonthis\\\~); \~; var doscripts = new elements.Skill(\~Against all odds_old\~); doscripts.script = estandardize + newcard.scriptbeforecombat; doscripts.execute(self|target); doscripts.script = estandardize + newcard.scriptbeforestartturn; doscripts.execute(self|target); doscripts.script = estandardize + newcard.scriptonstartturn; doscripts.execute(self|target); self.resetvar(\~doonthis\~);      newcard.arrangeslots();      self.createsparedice(newcard);      trace(\~card flashed\~);     }    }    else self.textparticle(\~Invalid wish!\~);    self.resetvar(\~wishingcard\~); self.resetvar(\~diditwork\~);    self.getvar(\~wishactuator\~).stop();    self.status = self.getvar(\~selfstatusbackup\~);    target.status = self.getvar(\~targetstatusbackup\~);    self.resetvar(\~selfstatusbackup\~);    self.resetvar(\~targetstatusbackup\~);    self.resetvar(\~phonephase2\~);    self.resetvar(\~wishactuator\~);    self.resetvar(\~wandwish\~);    if(self.getvar(\~lendeddice\~) == 1) { for(dice in self.dicepool) { if(dice.available() && dice.basevalue == 1) { dice.animate(\~disappear\~); break; } } }    self.resetvar(\~lendeddice\~);   }      if(phonedone) {    for(eq in self.equipment) {     if(eq.getvar(\~standardcard\~) == 1) {      eq.equipalpha = 1.0;      var importantindex = self.getvar(\~slotseqbackup\~).indexOf(eq);      eq.slots = self.getvar(\~slotsbackup\~)[importantindex];      eq.shocked_slots = self.getvar(\~shockslotseqbackup\~)[importantindex];      eq.skillsavailable = self.getvar(\~skillsbackup\~)[importantindex];      if(self.usecpuinsteadofdice) self.roll_jackpot = self.getvar(\~rolljackpot\~);     }    }    removeequipment(\~Equipment That Does Nothing\~);    self.resetvar(\~slotsbackup\~);    self.resetvar(\~slotseqbackup\~);    self.resetvar(\~shockslotseqbackup\~);    self.resetvar(\~skillsbackup\~);    self.resetvar(\~rolljackpot\~);    new elements.CombatCommand(\~msg\~|\~\~).execute();    wandwish = wandwish.split(\~[200%]\~)[1].split(\~_\~).join(\~ \~);    var wandwisharr = wandwish.split(\~\~);    wandwish = \~\~;    for(char in wandwisharr) wandwish = char + wandwish;    var exceptions = getcolumn(loaddata(\~ncrmod/wishredirects\~)|\~input\~);    var redirects = getcolumn(loaddata(\~ncrmod/wishredirects\~)|\~redirect\~);    if(exceptions.indexOf(wandwish) != -1) wandwish = redirects[exceptions.indexOf(wandwish)];    if(getequipmentlist().indexOf(wandwish) != -1) {     if(self.getvar(\~ncrrobotepisode4\~) == 1 && self.getvar(\~ncrrobotepisode4wishlist\~).indexOf(wandwish) != -1) { self.textparticle(\~Already wished!\~); }     else {      if(self.getvar(\~ncrrobotepisode4\~) == 1) {       self.setvar(\~ncrrobotepisode4wishlist\~|self.getvar(\~ncrrobotepisode4wishlist\~).concat([wandwish]));       var familylist = loadtext(\~ncrmod/wishfamilies\~);       for(i in 0...familylist.length)  {        if(familylistsplit.indexOf(wandwish) != -1) {         self.setvar(\~ncrrobotepisode4wishlist\~|self.getvar(\~ncrrobotepisode4wishlist\~).concat(familylistsplit));        }       }       if(!new elements.Equipment(wandwish).hastag(\~powercard\~)) {        if(wandwish.substr(wandwish.length - 1|1) == \~?\~) {         self.setvar(\~ncrrobotepisode4wishlist\~|self.getvar(\~ncrrobotepisode4wishlist\~).concat([wandwish.substr(0|wandwish.length - 1)]));        }        else {         self.setvar(\~ncrrobotepisode4wishlist\~|self.getvar(\~ncrrobotepisode4wishlist\~).concat([wandwish + \~?\~]));        }       }      }      var newcard = new elements.Equipment(wandwish);      var replacecard = self.equipment[self.equipment.indexOf(self.getvar(\~wishingcard\~))];      trace(\~card made\~);      newcard.x = self.getvar(\~wishingcardx\~);      newcard.y = self.getvar(\~wishingcardy\~);      self.equipment[self.equipment.indexOf(self.getvar(\~wishingcard\~))] = newcard;      trace(\~card replaced\~);      newcard.animate(\~flashandshake\~);      self.setvar(\~doonthis\~|newcard); var estandardize = \~var e = self.getvar(\\\~doonthis\\\~); \~; var doscripts = new elements.Skill(\~Against all odds_old\~); doscripts.script = estandardize + newcard.scriptbeforecombat; doscripts.execute(self|target); doscripts.script = estandardize + newcard.scriptbeforestartturn; doscripts.execute(self|target); doscripts.script = estandardize + newcard.scriptonstartturn; doscripts.execute(self|target); self.resetvar(\~doonthis\~);      newcard.arrangeslots();      self.createsparedice(newcard);      trace(\~card flashed\~);     }    }    else self.textparticle(\~Invalid wish!\~);    self.resetvar(\~wishingcard\~); self.resetvar(\~diditwork\~);    self.getvar(\~wishactuator\~).stop();    self.status = self.getvar(\~selfstatusbackup\~);    target.status = self.getvar(\~targetstatusbackup\~);    self.resetvar(\~selfstatusbackup\~);    self.resetvar(\~targetstatusbackup\~);    self.resetvar(\~phonephase2\~);    self.resetvar(\~wishactuator\~);    self.resetvar(\~wandwish\~);    if(self.getvar(\~lendeddice\~) == 1) { for(dice in self.dicepool) { if(dice.available() && dice.basevalue == 1) { dice.animate(\~disappear\~); break; } } }    self.resetvar(\~lendeddice\~);   }  ~;  tw.onRepeat(s.execute|[self|target]);  self.setvar(~wishactuator~|tw);  tw.move(); },Best Friend,NORMAL,,BRIGHTCYAN,,,,,,YES,,excludefromrandomlists|cannotsteal,,,,,,,,,self.setvar(~wishingcardx~|e.x); self.setvar(~wishingcardy~|e.y);,,e.maintainfury = true; e.preventdefault = true;,
Remaster,Upgrade a random card|[gray](once per battle)[],2,if(self.layout != ~DECK~) { var eqlist = []; for(eq in self.equipment) { if(!eq.temporary_thisturnonly && !eq.upgraded && !eq.originallyupgraded && eq != e && eq != self.getskillcard() && eq.upgradetype != ~~ && new elements.Equipment(eq.name + ~+~).size <= eq.size) { eqlist.push(eq); } } if(eqlist.length == 0 && !e.upgraded && !e.originallyupgraded) { var oldx = e.x; var oldy = e.y; var oldrcd = e.remainingcountdown; e.create(e.name|true|e.weakened|!self.isplayer); e.x = oldx; e.y = oldy; if(e.remainingcountdown > oldrcd) { e.remainingcountdown = oldrcd; } e.animate(~flashandshake~); sfx(~upgradeequipment~); screenshake(); self.textparticle(e.displayname + ~+!~); } else if(eqlist.length > 0) { var choseneq = rand(eqlist); var oldx = choseneq.x; var oldy = choseneq.y; var oldrcd = choseneq.remainingcountdown; choseneq.create(choseneq.name|true|choseneq.weakened|!self.isplayer); /* bool args for e.create: upgraded; weakened; deckupgrade */ choseneq.x = oldx; choseneq.y = oldy; if(choseneq.remainingcountdown > oldrcd) { choseneq.remainingcountdown = oldrcd; } choseneq.animate(~flashandshake~); sfx(~upgradeequipment~); screenshake(); self.textparticle(choseneq.displayname + ~+!~); } else { self.textparticle(~No effect!~); } } else { var cardlist = []; for(card in Deck.getcards(~all~)) { if(!card.equipment.temporary_thisturnonly && !card.equipment.upgraded  && !card.equipment.originallyupgraded && card.equipment != e && card.equipment.upgradetype != ~~) { cardlist.push(card); } } if(cardlist.length == 0 && !e.upgraded && !e.originallyupgraded) { var oldx = e.x; var oldy = e.y; var oldrcd = e.remainingcountdown; e.create(e.name|true|e.weakened|true); e.resize(2); e.x = oldx; e.y = oldy; if(e.remainingcountdown > oldrcd) { e.remainingcountdown = oldrcd; } e.animate(~flashandshake~); sfx(~upgradeequipment~); screenshake(); self.textparticle(e.displayname + ~+!~); } else if(cardlist.length > 0) { var chosencard = rand(cardlist); var oldx = chosencard.equipment.x; var oldy = chosencard.equipment.y; var oldrcd = chosencard.equipment.remainingcountdown; chosencard.equipment.create(chosencard.equipment.name|true|chosencard.equipment.weakened|true); chosencard.equipment.resize(2); chosencard.equipment.x = oldx; chosencard.equipment.y = oldy; if(chosencard.equipment.remainingcountdown > oldrcd) { chosencard.equipment.remainingcountdown = oldrcd; } chosencard.equipment.animate(~flashandshake~); if(!chosencard.equipment.onscreen()) chosencard.equipment.ready = false; sfx(~upgradeequipment~); screenshake(); self.textparticle(chosencard.equipment.displayname + ~+!~); } else { self.textparticle(~No effect!~); } },lolsorandom,ODD,,ORANGE,simplify,complicate,,,,YES,YES,finale,,,,,,,,,,,,
Powerball,Do [sword]<d6> damage. On 6[;] use|an additional Jackpot ability,2,attack(d); sfxdamage(target|d); if(d == 6) { self.roll_jackpotbonus += 1; },Sustainability,NORMAL,,YELLOW,reducesize,change_power,,,,,,robotonly,,,,,,,,,,,,
Powerball_downgraded,Use an additional|Jackpot ability,2,self.roll_jackpotbonus += 1;,Sustainability,REQUIRE6,,YELLOW,,,,,,,,robotonly,,,,,,,,,,,,
Necropost,Do [vanish]5 damage|Inflict [vanish]1 vanish,1,attack(5| VANISH); inflict(~ncr_vanish~| 1);,Strobe Light,REQUIRE1,,PINK,change_power,change_power,,,0,NO,NO,,,,,,,,,,,,,
Necropost_upgraded,Do [vanish]10 damage|Inflict [vanish]2 vanish,1,attack(10| VANISH); inflict(~ncr_vanish~| 2);,Strobe Light,REQUIRE1|REQUIRE2,,PINK,,,,,0,NO,NO,,,,,,,,,,,,,
Necropost_downgraded,Do [vanish]5 damage,1,attack(5| VANISH);,Strobe Light,REQUIRE1,,PINK,,,,,0,NO,NO,,,,,,,,,,,,,
Cursed Wand of Wishing,Take [sword]3 damage[;]|replace this with whatever|item you can name,2,bonus(-9999999999999); attackself(3); sfxdamage(self|3); if(!self.isplayer) self.textparticle(~No effect!~); else if(!simulation) {  var selfscript = ~removeequipment(\~Equipment That Does Nothing\~);~; if(self.scriptendturn.indexOf(selfscript) == -1) self.scriptendturn = selfscript + self.scriptendturn;  self.setvar(~wishingcard~|e);  var diceavailable = false;  if(self.dicepool.length > 0) for(dice in self.dicepool) if(dice.available()) { diceavailable = true; break; }  if(self.equipment.length > 0) for(eq in self.equipment) if(eq.ready && eq.assigneddice.length > 0) for(dice in eq.assigneddice) if(dice != null && dice.available()) { diceavailable = true; break; }  if(!diceavailable) { givedice(1); self.setvar(~lendeddice~|1); }  self.setvar(~slotsbackup~|[]);  self.setvar(~slotseqbackup~|[]);  self.setvar(~shockslotseqbackup~|[]);  self.setvar(~skillsbackup~|[]);  var slotsbackup = self.getvar(~slotsbackup~);  var slotseqbackup = self.getvar(~slotseqbackup~);  var shockslotseqbackup = self.getvar(~shockslotseqbackup~);  var skillsbackup = self.getvar(~skillsbackup~);  for(eq in self.equipment) {   eq.setvar(~standardcard~|1);   eq.removedice();   slotsbackup.push(eq.slots);   shockslotseqbackup.push(eq.shocked_slots);   slotseqbackup.push(eq);   eq.slots = [];   eq.shocked_slots = [];   skillsbackup.push(eq.skillsavailable.copy());   trace(eq.name);   trace(eq.skillsavailable);   trace(eq.skillsavailable.length);   if(eq.skillsavailable.length > 0) { trace(~this has skills~); for(skill in eq.skillsavailable) { trace(~making skill false~); eq.skillsavailable[eq.skillsavailable.indexOf(skill)] = false; } }   trace(eq.skillsavailable);  }    self.setvar(~slotsbackup~|slotsbackup);  self.setvar(~slotseqbackup~|slotseqbackup);  self.setvar(~shockslotseqbackup~|shockslotseqbackup);  self.setvar(~skillsbackup~|skillsbackup);  self.setvar(~selfstatusbackup~|self.status.copy());  self.setvar(~targetstatusbackup~|target.status.copy());   if(self.usecpuinsteadofdice) { self.setvar(~rolljackpot~|self.roll_jackpot); self.roll_jackpot = -1; /*thx to cody for this bit*/ }   var buttonx = 100;  var buttony = 400;   var charlist = [~A~|~B~|~C~|~D~|~E~|~F~|~G~|~H~|~I~|~J~|~K~|~L~|~M~|~N~|~O~|~P~|~Q~|~R~|~S~|~T~|~U~|~V~|~W~|~X~|~Y~|~Z~|~a~|~b~|~c~|~d~|~e~|~f~|~g~|~h~|~i~|~j~|~k~|~l~|~m~|~n~|~o~|~p~|~q~|~r~|~s~|~t~|~u~|~v~|~w~|~x~|~y~|~z~|~'~|~_~|~@~|~1~|~2~|~3~|~4~|~5~|~6~|~7~|~8~|~9~|~0~|~.~|~?~|~!~|~Bkspace~|~Confirm~];    self.setvar(~wandwish~|~[200%]~);   var i = 0;    for(char in charlist) {   i++;   var charholder = new elements.Equipment(~Equipment That Does Nothing~);   self.equipment.push(charholder);   charholder.script = ~self.equipmentused--;~;   charholder.slotpositions[0].y -= 153;   charholder.slotpositions[0].x -= 260;   charholder.displayname = char;   charholder.equipmentcol = 0;   if(char == char.toLowerCase() && char.toLowerCase() != char.toUpperCase()) charholder.displayname = ~[70%]~ + charholder.displayname;   if(charholder.displayname == ~Confirm~ # charholder.displayname == ~Bkspace~) charholder.equipmentcol = 2;   charholder.fulldescription = ~~;   charholder.height = 270;   charholder.width = 270;   charholder.x = buttonx;   charholder.y = buttony;   charholder.equipalpha = 0.0;   buttonx += 270;   if(i == 13) {    buttonx = 160;    buttony += 270;   }   if(i == 26) {    buttonx = 100;    buttony += 300;   }   if(i == 39) {    buttonx = 160;    buttony += 270;   }   if(i == 52) {    buttonx = 100;    buttony += 300;   }   if(i == 65) {    buttonx = 1620;    buttony += 270;   }  }   var tw = new motion.actuators.SimpleActuator(null|1/60|null);  tw._repeat = -1;  var s = new elements.Skill(~Against all odds_old~);   s.script = ~   var phonedone = false;   var wandwish = self.getvar(\~wandwish\~);   for(eq in self.equipment) {    if(self.getvar(\~phonephase2\~) != 1) {     if(eq.equipalpha > 0.0 && eq.getvar(\~standardcard\~) == 1) eq.equipalpha -= 0.2;     if(eq.equipalpha < 1.0 && eq.getvar(\~standardcard\~) != 1) eq.equipalpha += 0.2;     if(eq.assigneddice.length > 0 && eq.assigneddice[0] != null) {      eq.removedice();      var neweq = eq.copy();          neweq.height = 270;      neweq.width = 270;      neweq.equipalpha = eq.equipalpha;      neweq.displayname = eq.displayname;      neweq.equipmentcol = eq.equipmentcol;      neweq.slotpositions = eq.slotpositions;      neweq.script = eq.script;      self.equipment.push(neweq);      eq.name = \~deleteme\~;      eq.slots = [];      eq.equipalpha = 0;      if(eq.displayname != \~Confirm\~) {       sfx(\~jackpot_increasecounter\~);       if(eq.displayname == \~Bkspace\~ && wandwish.length > 6) wandwish = wandwish.substr(0|wandwish.length - 1);       else       if(eq.displayname.substr(0|1) == \~_\~) wandwish += \~_\~;       else       if(eq.displayname.substr(0|1) == \~[\~) wandwish += eq.displayname.substr(5|1);       else       if(eq.displayname != \~Bkspace\~) wandwish += eq.displayname.substr(0|1);      }      else {       sfx(\~_thinghappens\~);       self.setvar(\~phonephase2\~|1);      }     }    }    else {     if(eq.equipalpha <= 1.0 && eq.getvar(\~standardcard\~) == 1) {      eq.equipalpha += 0.2;     }     if(eq.equipalpha > 0.0 && eq.getvar(\~standardcard\~) != 1) {      eq.removedice();      eq.equipalpha -= 0.2;      eq.slots = [];      eq.script = \~self.equipmentused--; self.equipmenthistory.pop();\~;     }     if(eq.equipalpha <= 0.0 && eq.getvar(\~standardcard\~) != 1) {      eq.name = \~deleteme\~;      phonedone = true;     }    }   }      new elements.CombatCommand(\~msg\~|wandwish).execute();   self.setvar(\~wandwish\~|wandwish);      removeequipment(\~deleteme\~);   if(self.doendturnnow) {    trace(\~ending turn\~);    for(eq in self.equipment) {     if(eq.getvar(\~standardcard\~) == 1) {      eq.equipalpha = 1.0;      var importantindex = self.getvar(\~slotseqbackup\~).indexOf(eq);      eq.slots = self.getvar(\~slotsbackup\~)[importantindex];      eq.shocked_slots = self.getvar(\~shockslotseqbackup\~)[importantindex];      eq.skillsavailable = self.getvar(\~skillsbackup\~)[importantindex];      if(self.usecpuinsteadofdice) self.roll_jackpot = self.getvar(\~rolljackpot\~);     }     else {      eq.name = \~deleteme\~;     }    }    removeequipment(\~deleteme\~);    removeequipment(\~Equipment That Does Nothing\~);    self.resetvar(\~slotsbackup\~);    self.resetvar(\~slotseqbackup\~);    self.resetvar(\~shockslotseqbackup\~);    self.resetvar(\~skillsbackup\~);    self.resetvar(\~rolljackpot\~);    new elements.CombatCommand(\~msg\~|\~\~).execute();    wandwish = wandwish.split(\~[200%]\~)[1].split(\~_\~).join(\~ \~);    var exceptions = getcolumn(loaddata(\~ncrmod/wishredirects\~)|\~input\~);    var redirects = getcolumn(loaddata(\~ncrmod/wishredirects\~)|\~redirect\~);    if(exceptions.indexOf(wandwish) != -1) wandwish = redirects[exceptions.indexOf(wandwish)];    if(getequipmentlist().indexOf(wandwish) != -1) {     if(self.getvar(\~ncrrobotepisode4\~) == 1 && self.getvar(\~ncrrobotepisode4wishlist\~).indexOf(wandwish) != -1) { self.textparticle(\~Already wished!\~); }     else {      if(self.getvar(\~ncrrobotepisode4\~) == 1) {       self.setvar(\~ncrrobotepisode4wishlist\~|self.getvar(\~ncrrobotepisode4wishlist\~).concat([wandwish]));       var familylist = loadtext(\~ncrmod/wishfamilies\~);       for(i in 0...familylist.length)  {        var familylistsplit = familylist[i].split(\~|\~);        if(familylistsplit.indexOf(wandwish) != -1) {         self.setvar(\~ncrrobotepisode4wishlist\~|self.getvar(\~ncrrobotepisode4wishlist\~).concat(familylistsplit));        }       }       if(!new elements.Equipment(wandwish).hastag(\~powercard\~)) {        if(wandwish.substr(wandwish.length - 1|1) == \~?\~) {         self.setvar(\~ncrrobotepisode4wishlist\~|self.getvar(\~ncrrobotepisode4wishlist\~).concat([wandwish.substr(0|wandwish.length - 1)]));        }        else {         self.setvar(\~ncrrobotepisode4wishlist\~|self.getvar(\~ncrrobotepisode4wishlist\~).concat([wandwish + \~?\~]));        }       }      }      var newcard = new elements.Equipment(wandwish);      var replacecard = self.equipment[self.equipment.indexOf(self.getvar(\~wishingcard\~))];      trace(\~card made\~);      newcard.x = self.getvar(\~wishingcardx\~);      newcard.y = self.getvar(\~wishingcardy\~);      self.equipment[self.equipment.indexOf(self.getvar(\~wishingcard\~))] = newcard;      trace(\~card replaced\~);      newcard.animate(\~flashandshake\~);      self.setvar(\~doonthis\~|newcard); var estandardize = \~var e = self.getvar(\\\~doonthis\\\~); \~; var doscripts = new elements.Skill(\~Against all odds_old\~); doscripts.script = estandardize + newcard.scriptbeforecombat; doscripts.execute(self|target); doscripts.script = estandardize + newcard.scriptbeforestartturn; doscripts.execute(self|target); doscripts.script = estandardize + newcard.scriptonstartturn; doscripts.execute(self|target); self.resetvar(\~doonthis\~);      newcard.arrangeslots();      self.createsparedice(newcard);      trace(\~card flashed\~);     }    }    else self.textparticle(\~Invalid wish!\~);    self.resetvar(\~wishingcard\~); self.resetvar(\~diditwork\~);    self.getvar(\~wishactuator\~).stop();    self.status = self.getvar(\~selfstatusbackup\~);    target.status = self.getvar(\~targetstatusbackup\~);    self.resetvar(\~selfstatusbackup\~);    self.resetvar(\~targetstatusbackup\~);    self.resetvar(\~phonephase2\~);    self.resetvar(\~wishactuator\~);    self.resetvar(\~wandwish\~);    if(self.getvar(\~lendeddice\~) == 1) { for(dice in self.dicepool) { if(dice.available() && dice.basevalue == 1) { dice.animate(\~disappear\~); break; } } }    self.resetvar(\~lendeddice\~);   }      if(phonedone) {    for(eq in self.equipment) {     if(eq.getvar(\~standardcard\~) == 1) {      eq.equipalpha = 1.0;      var importantindex = self.getvar(\~slotseqbackup\~).indexOf(eq);      eq.slots = self.getvar(\~slotsbackup\~)[importantindex];      eq.shocked_slots = self.getvar(\~shockslotseqbackup\~)[importantindex];      eq.skillsavailable = self.getvar(\~skillsbackup\~)[importantindex];      if(self.usecpuinsteadofdice) self.roll_jackpot = self.getvar(\~rolljackpot\~);     }    }    removeequipment(\~Equipment That Does Nothing\~);    self.resetvar(\~slotsbackup\~);    self.resetvar(\~slotseqbackup\~);    self.resetvar(\~shockslotseqbackup\~);    self.resetvar(\~skillsbackup\~);    self.resetvar(\~rolljackpot\~);    new elements.CombatCommand(\~msg\~|\~\~).execute();    wandwish = wandwish.split(\~[200%]\~)[1].split(\~_\~).join(\~ \~);    var exceptions = getcolumn(loaddata(\~ncrmod/wishredirects\~)|\~input\~);    var redirects = getcolumn(loaddata(\~ncrmod/wishredirects\~)|\~redirect\~);    if(exceptions.indexOf(wandwish) != -1) wandwish = redirects[exceptions.indexOf(wandwish)];    if(getequipmentlist().indexOf(wandwish) != -1) {     if(self.getvar(\~ncrrobotepisode4\~) == 1 && self.getvar(\~ncrrobotepisode4wishlist\~).indexOf(wandwish) != -1) { self.textparticle(\~Already wished!\~); }     else {      if(self.getvar(\~ncrrobotepisode4\~) == 1) {       self.setvar(\~ncrrobotepisode4wishlist\~|self.getvar(\~ncrrobotepisode4wishlist\~).concat([wandwish]));       var familylist = loadtext(\~ncrmod/wishfamilies\~);       for(i in 0...familylist.length)  {        var familylistsplit = familylist[i].split(\~|\~);        if(familylistsplit.indexOf(wandwish) != -1) {         self.setvar(\~ncrrobotepisode4wishlist\~|self.getvar(\~ncrrobotepisode4wishlist\~).concat(familylistsplit));        }       }       if(!new elements.Equipment(wandwish).hastag(\~powercard\~)) {        if(wandwish.substr(wandwish.length - 1|1) == \~?\~) {         self.setvar(\~ncrrobotepisode4wishlist\~|self.getvar(\~ncrrobotepisode4wishlist\~).concat([wandwish.substr(0|wandwish.length - 1)]));        }        else {         self.setvar(\~ncrrobotepisode4wishlist\~|self.getvar(\~ncrrobotepisode4wishlist\~).concat([wandwish + \~?\~]));        }       }      }      var newcard = new elements.Equipment(wandwish);      var replacecard = self.equipment[self.equipment.indexOf(self.getvar(\~wishingcard\~))];      trace(\~card made\~);      newcard.x = self.getvar(\~wishingcardx\~);      newcard.y = self.getvar(\~wishingcardy\~);      self.equipment[self.equipment.indexOf(self.getvar(\~wishingcard\~))] = newcard;      trace(\~card replaced\~);      newcard.animate(\~flashandshake\~);      self.setvar(\~doonthis\~|newcard); var estandardize = \~var e = self.getvar(\\\~doonthis\\\~); \~; var doscripts = new elements.Skill(\~Against all odds_old\~); doscripts.script = estandardize + newcard.scriptbeforecombat; doscripts.execute(self|target); doscripts.script = estandardize + newcard.scriptbeforestartturn; doscripts.execute(self|target); doscripts.script = estandardize + newcard.scriptonstartturn; doscripts.execute(self|target); self.resetvar(\~doonthis\~);      newcard.arrangeslots();      self.createsparedice(newcard);      trace(\~card flashed\~);     }    }    else self.textparticle(\~Invalid wish!\~);    self.resetvar(\~wishingcard\~); self.resetvar(\~diditwork\~);    self.getvar(\~wishactuator\~).stop();    self.status = self.getvar(\~selfstatusbackup\~);    target.status = self.getvar(\~targetstatusbackup\~);    self.resetvar(\~selfstatusbackup\~);    self.resetvar(\~targetstatusbackup\~);    self.resetvar(\~phonephase2\~);    self.resetvar(\~wishactuator\~);    self.resetvar(\~wandwish\~);    if(self.getvar(\~lendeddice\~) == 1) { for(dice in self.dicepool) { if(dice.available() && dice.basevalue == 1) { dice.animate(\~disappear\~); break; } } }    self.resetvar(\~lendeddice\~);   }  ~;  tw.onRepeat(s.execute|[self|target]);  self.setvar(~wishactuator~|tw);  tw.move(); },Oh Shit!,REQUIRE5|REQUIRE5,,BRIGHTCYAN,change_power,change_power,,,,YES,,excludefromrandomlists|cannotsteal,,,,,,,,,self.setvar(~wishingcardx~|e.x); self.setvar(~wishingcardy~|e.y);,,e.maintainfury = true; e.preventdefault = true;,
Cursed Wand of Wishing_upgraded,Take [sword]3 damage[;]|replace this with whatever|upgraded item you can name,2,bonus(-9999999999999); attackself(3); sfxdamage(self|3); if(!self.isplayer) self.textparticle(~No effect!~); else if(!simulation) {  var selfscript = ~removeequipment(\~Equipment That Does Nothing\~);~; if(self.scriptendturn.indexOf(selfscript) == -1) self.scriptendturn = selfscript + self.scriptendturn;  self.setvar(~wishingcard~|e);  var diceavailable = false;  if(self.dicepool.length > 0) for(dice in self.dicepool) if(dice.available()) { diceavailable = true; break; }  if(self.equipment.length > 0) for(eq in self.equipment) if(eq.ready && eq.assigneddice.length > 0) for(dice in eq.assigneddice) if(dice != null && dice.available()) { diceavailable = true; break; }  if(!diceavailable) { givedice(1); self.setvar(~lendeddice~|1); }  self.setvar(~slotsbackup~|[]);  self.setvar(~slotseqbackup~|[]);  self.setvar(~shockslotseqbackup~|[]);  self.setvar(~skillsbackup~|[]);  var slotsbackup = self.getvar(~slotsbackup~);  var slotseqbackup = self.getvar(~slotseqbackup~);  var shockslotseqbackup = self.getvar(~shockslotseqbackup~);  var skillsbackup = self.getvar(~skillsbackup~);  for(eq in self.equipment) {   eq.setvar(~standardcard~|1);   eq.removedice();   slotsbackup.push(eq.slots);   shockslotseqbackup.push(eq.shocked_slots);   slotseqbackup.push(eq);   eq.slots = [];   eq.shocked_slots = [];   skillsbackup.push(eq.skillsavailable.copy());   trace(eq.name);   trace(eq.skillsavailable);   trace(eq.skillsavailable.length);   if(eq.skillsavailable.length > 0) { trace(~this has skills~); for(skill in eq.skillsavailable) { trace(~making skill false~); eq.skillsavailable[eq.skillsavailable.indexOf(skill)] = false; } }   trace(eq.skillsavailable);  }    self.setvar(~slotsbackup~|slotsbackup);  self.setvar(~slotseqbackup~|slotseqbackup);  self.setvar(~shockslotseqbackup~|shockslotseqbackup);  self.setvar(~skillsbackup~|skillsbackup);  self.setvar(~selfstatusbackup~|self.status.copy());  self.setvar(~targetstatusbackup~|target.status.copy());   if(self.usecpuinsteadofdice) { self.setvar(~rolljackpot~|self.roll_jackpot); self.roll_jackpot = -1; /*thx to cody for this bit*/ }   var buttonx = 100;  var buttony = 400;   var charlist = [~A~|~B~|~C~|~D~|~E~|~F~|~G~|~H~|~I~|~J~|~K~|~L~|~M~|~N~|~O~|~P~|~Q~|~R~|~S~|~T~|~U~|~V~|~W~|~X~|~Y~|~Z~|~a~|~b~|~c~|~d~|~e~|~f~|~g~|~h~|~i~|~j~|~k~|~l~|~m~|~n~|~o~|~p~|~q~|~r~|~s~|~t~|~u~|~v~|~w~|~x~|~y~|~z~|~'~|~_~|~@~|~1~|~2~|~3~|~4~|~5~|~6~|~7~|~8~|~9~|~0~|~.~|~?~|~!~|~Bkspace~|~Confirm~];    self.setvar(~wandwish~|~[200%]~);   var i = 0;    for(char in charlist) {   i++;   var charholder = new elements.Equipment(~Equipment That Does Nothing~);   self.equipment.push(charholder);   charholder.script = ~self.equipmentused--;~;   charholder.slotpositions[0].y -= 153;   charholder.slotpositions[0].x -= 260;   charholder.displayname = char;   charholder.equipmentcol = 0;   if(char == char.toLowerCase() && char.toLowerCase() != char.toUpperCase()) charholder.displayname = ~[70%]~ + charholder.displayname;   if(charholder.displayname == ~Confirm~ # charholder.displayname == ~Bkspace~) charholder.equipmentcol = 2;   charholder.fulldescription = ~~;   charholder.height = 270;   charholder.width = 270;   charholder.x = buttonx;   charholder.y = buttony;   charholder.equipalpha = 0.0;   buttonx += 270;   if(i == 13) {    buttonx = 160;    buttony += 270;   }   if(i == 26) {    buttonx = 100;    buttony += 300;   }   if(i == 39) {    buttonx = 160;    buttony += 270;   }   if(i == 52) {    buttonx = 100;    buttony += 300;   }   if(i == 65) {    buttonx = 1620;    buttony += 270;   }  }   var tw = new motion.actuators.SimpleActuator(null|1/60|null);  tw._repeat = -1;  var s = new elements.Skill(~Against all odds_old~);   s.script = ~   var phonedone = false;   var wandwish = self.getvar(\~wandwish\~);   for(eq in self.equipment) {    if(self.getvar(\~phonephase2\~) != 1) {     if(eq.equipalpha > 0.0 && eq.getvar(\~standardcard\~) == 1) eq.equipalpha -= 0.2;     if(eq.equipalpha < 1.0 && eq.getvar(\~standardcard\~) != 1) eq.equipalpha += 0.2;     if(eq.assigneddice.length > 0 && eq.assigneddice[0] != null) {      eq.removedice();      var neweq = eq.copy();          neweq.height = 270;      neweq.width = 270;      neweq.equipalpha = eq.equipalpha;      neweq.displayname = eq.displayname;      neweq.equipmentcol = eq.equipmentcol;      neweq.slotpositions = eq.slotpositions;      neweq.script = eq.script;      self.equipment.push(neweq);      eq.name = \~deleteme\~;      eq.slots = [];      eq.equipalpha = 0;      if(eq.displayname != \~Confirm\~) {       sfx(\~jackpot_increasecounter\~);       if(eq.displayname == \~Bkspace\~ && wandwish.length > 6) wandwish = wandwish.substr(0|wandwish.length - 1);       else       if(eq.displayname.substr(0|1) == \~_\~) wandwish += \~_\~;       else       if(eq.displayname.substr(0|1) == \~[\~) wandwish += eq.displayname.substr(5|1);       else       if(eq.displayname != \~Bkspace\~) wandwish += eq.displayname.substr(0|1);      }      else {       sfx(\~_thinghappens\~);       self.setvar(\~phonephase2\~|1);      }     }    }    else {     if(eq.equipalpha <= 1.0 && eq.getvar(\~standardcard\~) == 1) {      eq.equipalpha += 0.2;     }     if(eq.equipalpha > 0.0 && eq.getvar(\~standardcard\~) != 1) {      eq.removedice();      eq.equipalpha -= 0.2;      eq.slots = [];      eq.script = \~self.equipmentused--; self.equipmenthistory.pop();\~;     }     if(eq.equipalpha <= 0.0 && eq.getvar(\~standardcard\~) != 1) {      eq.name = \~deleteme\~;      phonedone = true;     }    }   }      new elements.CombatCommand(\~msg\~|wandwish + \~+\~).execute();   self.setvar(\~wandwish\~|wandwish);      removeequipment(\~deleteme\~);   if(self.doendturnnow) {    trace(\~ending turn\~);    for(eq in self.equipment) {     if(eq.getvar(\~standardcard\~) == 1) {      eq.equipalpha = 1.0;      var importantindex = self.getvar(\~slotseqbackup\~).indexOf(eq);      eq.slots = self.getvar(\~slotsbackup\~)[importantindex];      eq.shocked_slots = self.getvar(\~shockslotseqbackup\~)[importantindex];      eq.skillsavailable = self.getvar(\~skillsbackup\~)[importantindex];      if(self.usecpuinsteadofdice) self.roll_jackpot = self.getvar(\~rolljackpot\~);     }     else {      eq.name = \~deleteme\~;     }    }    removeequipment(\~deleteme\~);    removeequipment(\~Equipment That Does Nothing\~);    self.resetvar(\~slotsbackup\~);    self.resetvar(\~slotseqbackup\~);    self.resetvar(\~shockslotseqbackup\~);    self.resetvar(\~skillsbackup\~);    self.resetvar(\~rolljackpot\~);    new elements.CombatCommand(\~msg\~|\~\~).execute();    wandwish = wandwish.split(\~[200%]\~)[1].split(\~_\~).join(\~ \~);    var exceptions = getcolumn(loaddata(\~ncrmod/wishredirects\~)|\~input\~);    var redirects = getcolumn(loaddata(\~ncrmod/wishredirects\~)|\~redirect\~);    if(exceptions.indexOf(wandwish) != -1) wandwish = redirects[exceptions.indexOf(wandwish)];    var wrong = false;    var newcard = null;    if(getequipmentlist().indexOf(wandwish) != -1) {     if(self.getvar(\~ncrrobotepisode4\~) == 1 && self.getvar(\~ncrrobotepisode4wishlist\~).indexOf(wandwish) != -1) { self.textparticle(\~Already wished!\~); wrong = true; }     else {      newcard = new elements.Equipment(wandwish);      if(newcard.upgradetype == \~\~) { newcard.name = \~Equipment That Does Nothing\~; self.equipment.push(newcard); removeequipment(\~Equipment That Does Nothing\~); wrong = true; }     }    }    else { wrong = true; }    if(!wrong) {     if(self.getvar(\~ncrrobotepisode4\~) == 1) {      self.setvar(\~ncrrobotepisode4wishlist\~|self.getvar(\~ncrrobotepisode4wishlist\~).concat([wandwish]));      var familylist = loadtext(\~ncrmod/wishfamilies\~);      for(i in 0...familylist.length)  {       familylist[i] = familylist[i].split(\~|\~);       if(familylistsplit.indexOf(wandwish) != -1) {        self.setvar(\~ncrrobotepisode4wishlist\~|self.getvar(\~ncrrobotepisode4wishlist\~).concat(familylistsplit));       }      }      if(!new elements.Equipment(wandwish).hastag(\~powercard\~)) {       if(wandwish.substr(wandwish.length - 1|1) == \~?\~) {        self.setvar(\~ncrrobotepisode4wishlist\~|self.getvar(\~ncrrobotepisode4wishlist\~).concat([wandwish.substr(0|wandwish.length - 1)]));       }       else {        self.setvar(\~ncrrobotepisode4wishlist\~|self.getvar(\~ncrrobotepisode4wishlist\~).concat([wandwish + \~?\~]));       }      }     }     newcard = new elements.Equipment(wandwish + \~+\~);     var replacecard = self.equipment[self.equipment.indexOf(self.getvar(\~wishingcard\~))];     trace(\~card made\~);     newcard.x = self.getvar(\~wishingcardx\~);     newcard.y = self.getvar(\~wishingcardy\~);     self.equipment[self.equipment.indexOf(self.getvar(\~wishingcard\~))] = newcard;     trace(\~card replaced\~);     newcard.animate(\~flashandshake\~);     self.setvar(\~doonthis\~|newcard); var estandardize = \~var e = self.getvar(\\\~doonthis\\\~); \~; var doscripts = new elements.Skill(\~Against all odds_old\~); doscripts.script = estandardize + newcard.scriptbeforecombat; doscripts.execute(self|target); doscripts.script = estandardize + newcard.scriptbeforestartturn; doscripts.execute(self|target); doscripts.script = estandardize + newcard.scriptonstartturn; doscripts.execute(self|target); self.resetvar(\~doonthis\~);     newcard.arrangeslots();     self.createsparedice(newcard);     trace(\~card flashed\~);    }    else self.textparticle(\~Invalid wish!\~);    self.resetvar(\~wishingcard\~); self.resetvar(\~diditwork\~);    self.getvar(\~wishactuator\~).stop();    self.status = self.getvar(\~selfstatusbackup\~);    target.status = self.getvar(\~targetstatusbackup\~);    self.resetvar(\~selfstatusbackup\~);    self.resetvar(\~targetstatusbackup\~);    self.resetvar(\~phonephase2\~);    self.resetvar(\~wishactuator\~);    self.resetvar(\~wandwish\~);    if(self.getvar(\~lendeddice\~) == 1) { for(dice in self.dicepool) { if(dice.available() && dice.basevalue == 1) { dice.animate(\~disappear\~); break; } } }    self.resetvar(\~lendeddice\~);   }      if(phonedone) {    for(eq in self.equipment) {     if(eq.getvar(\~standardcard\~) == 1) {      eq.equipalpha = 1.0;      var importantindex = self.getvar(\~slotseqbackup\~).indexOf(eq);      eq.slots = self.getvar(\~slotsbackup\~)[importantindex];      eq.shocked_slots = self.getvar(\~shockslotseqbackup\~)[importantindex];      eq.skillsavailable = self.getvar(\~skillsbackup\~)[importantindex];      if(self.usecpuinsteadofdice) self.roll_jackpot = self.getvar(\~rolljackpot\~);     }    }    removeequipment(\~Equipment That Does Nothing\~);    self.resetvar(\~slotsbackup\~);    self.resetvar(\~slotseqbackup\~);    self.resetvar(\~shockslotseqbackup\~);    self.resetvar(\~skillsbackup\~);    self.resetvar(\~rolljackpot\~);    new elements.CombatCommand(\~msg\~|\~\~).execute();    wandwish = wandwish.split(\~[200%]\~)[1].split(\~_\~).join(\~ \~);    var exceptions = getcolumn(loaddata(\~ncrmod/wishredirects\~)|\~input\~);    var redirects = getcolumn(loaddata(\~ncrmod/wishredirects\~)|\~redirect\~);    if(exceptions.indexOf(wandwish) != -1) wandwish = redirects[exceptions.indexOf(wandwish)];    var wrong = false;    var newcard = null;    if(getequipmentlist().indexOf(wandwish) != -1) {     if(self.getvar(\~ncrrobotepisode4\~) == 1 && self.getvar(\~ncrrobotepisode4wishlist\~).indexOf(wandwish) != -1) { self.textparticle(\~Already wished!\~); wrong = true; }     else {      newcard = new elements.Equipment(wandwish);      if(newcard.upgradetype == \~\~) { newcard.name = \~Equipment That Does Nothing\~; self.equipment.push(newcard); removeequipment(\~Equipment That Does Nothing\~); wrong = true; }     }    }    else { wrong = true; }    if(!wrong) {     if(self.getvar(\~ncrrobotepisode4\~) == 1) {      self.setvar(\~ncrrobotepisode4wishlist\~|self.getvar(\~ncrrobotepisode4wishlist\~).concat([wandwish]));      var familylist = loadtext(\~ncrmod/wishfamilies\~);      for(i in 0...familylist.length)  {       var familylistsplit = familylist[i].split(\~|\~);       if(familylistsplit.indexOf(wandwish) != -1) {        self.setvar(\~ncrrobotepisode4wishlist\~|self.getvar(\~ncrrobotepisode4wishlist\~).concat(familylistsplit));       }      }      if(!new elements.Equipment(wandwish).hastag(\~powercard\~)) {       if(wandwish.substr(wandwish.length - 1|1) == \~?\~) {        self.setvar(\~ncrrobotepisode4wishlist\~|self.getvar(\~ncrrobotepisode4wishlist\~).concat([wandwish.substr(0|wandwish.length - 1)]));       }       else {        self.setvar(\~ncrrobotepisode4wishlist\~|self.getvar(\~ncrrobotepisode4wishlist\~).concat([wandwish + \~?\~]));       }      }     }     newcard = new elements.Equipment(wandwish + \~+\~);     var replacecard = self.equipment[self.equipment.indexOf(self.getvar(\~wishingcard\~))];     trace(\~card made\~);     newcard.x = self.getvar(\~wishingcardx\~);     newcard.y = self.getvar(\~wishingcardy\~);     self.equipment[self.equipment.indexOf(self.getvar(\~wishingcard\~))] = newcard;     trace(\~card replaced\~);     newcard.animate(\~flashandshake\~);     self.setvar(\~doonthis\~|newcard); var estandardize = \~var e = self.getvar(\\\~doonthis\\\~); \~; var doscripts = new elements.Skill(\~Against all odds_old\~); doscripts.script = estandardize + newcard.scriptbeforecombat; doscripts.execute(self|target); doscripts.script = estandardize + newcard.scriptbeforestartturn; doscripts.execute(self|target); doscripts.script = estandardize + newcard.scriptonstartturn; doscripts.execute(self|target); self.resetvar(\~doonthis\~);     newcard.arrangeslots();     self.createsparedice(newcard);     trace(\~card flashed\~);    }    else self.textparticle(\~Invalid wish!\~);    self.resetvar(\~wishingcard\~); self.resetvar(\~diditwork\~);    self.getvar(\~wishactuator\~).stop();    self.status = self.getvar(\~selfstatusbackup\~);    target.status = self.getvar(\~targetstatusbackup\~);    self.resetvar(\~selfstatusbackup\~);    self.resetvar(\~targetstatusbackup\~);    self.resetvar(\~phonephase2\~);    self.resetvar(\~wishactuator\~);    self.resetvar(\~wandwish\~);    if(self.getvar(\~lendeddice\~) == 1) { for(dice in self.dicepool) { if(dice.available() && dice.basevalue == 1) { dice.animate(\~disappear\~); break; } } }    self.resetvar(\~lendeddice\~);   }  ~;  tw.onRepeat(s.execute|[self|target]);  self.setvar(~wishactuator~|tw);  tw.move(); },Oh Shit!,REQUIRE5|REQUIRE5,,BRIGHTCYAN,,,,,,YES,,excludefromrandomlists|cannotsteal,,,,,,,,,self.setvar(~wishingcardx~|e.x); self.setvar(~wishingcardy~|e.y);,,e.maintainfury = true; e.preventdefault = true;,
Cursed Wand of Wishing_downgraded,Take [sword]3 damage[;]|replace this with whatever|item you can spell backward,2,bonus(-9999999999999); attackself(3); sfxdamage(self|3); if(!self.isplayer) self.textparticle(~No effect!~); else if(!simulation) {  var selfscript = ~removeequipment(\~Equipment That Does Nothing\~);~; if(self.scriptendturn.indexOf(selfscript) == -1) self.scriptendturn = selfscript + self.scriptendturn;  self.setvar(~wishingcard~|e);  var diceavailable = false;  if(self.dicepool.length > 0) for(dice in self.dicepool) if(dice.available()) { diceavailable = true; break; }  if(self.equipment.length > 0) for(eq in self.equipment) if(eq.ready && eq.assigneddice.length > 0) for(dice in eq.assigneddice) if(dice != null && dice.available()) { diceavailable = true; break; }  if(!diceavailable) { givedice(1); self.setvar(~lendeddice~|1); }  self.setvar(~slotsbackup~|[]);  self.setvar(~slotseqbackup~|[]);  self.setvar(~shockslotseqbackup~|[]);  self.setvar(~skillsbackup~|[]);  var slotsbackup = self.getvar(~slotsbackup~);  var slotseqbackup = self.getvar(~slotseqbackup~);  var shockslotseqbackup = self.getvar(~shockslotseqbackup~);  var skillsbackup = self.getvar(~skillsbackup~);  for(eq in self.equipment) {   eq.setvar(~standardcard~|1);   eq.removedice();   slotsbackup.push(eq.slots);   shockslotseqbackup.push(eq.shocked_slots);   slotseqbackup.push(eq);   eq.slots = [];   eq.shocked_slots = [];   skillsbackup.push(eq.skillsavailable.copy());   trace(eq.name);   trace(eq.skillsavailable);   trace(eq.skillsavailable.length);   if(eq.skillsavailable.length > 0) { trace(~this has skills~); for(skill in eq.skillsavailable) { trace(~making skill false~); eq.skillsavailable[eq.skillsavailable.indexOf(skill)] = false; } }   trace(eq.skillsavailable);  }  self.setvar(~slotsbackup~|slotsbackup);  self.setvar(~slotseqbackup~|slotseqbackup);  self.setvar(~shockslotseqbackup~|shockslotseqbackup);  self.setvar(~skillsbackup~|skillsbackup);  self.setvar(~selfstatusbackup~|self.status.copy());  self.setvar(~targetstatusbackup~|target.status.copy());   if(self.usecpuinsteadofdice) { self.setvar(~rolljackpot~|self.roll_jackpot); self.roll_jackpot = -1; /*thx to cody for this bit*/ }   var buttonx = 100;  var buttony = 400;   var charlist = [~A~|~B~|~C~|~D~|~E~|~F~|~G~|~H~|~I~|~J~|~K~|~L~|~M~|~N~|~O~|~P~|~Q~|~R~|~S~|~T~|~U~|~V~|~W~|~X~|~Y~|~Z~|~a~|~b~|~c~|~d~|~e~|~f~|~g~|~h~|~i~|~j~|~k~|~l~|~m~|~n~|~o~|~p~|~q~|~r~|~s~|~t~|~u~|~v~|~w~|~x~|~y~|~z~|~'~|~_~|~@~|~1~|~2~|~3~|~4~|~5~|~6~|~7~|~8~|~9~|~0~|~.~|~?~|~!~|~Bkspace~|~Confirm~];    self.setvar(~wandwish~|~[200%]~);   var i = 0;    for(char in charlist) {   i++;   var charholder = new elements.Equipment(~Equipment That Does Nothing~);   self.equipment.push(charholder);   charholder.script = ~self.equipmentused--;~;   charholder.slotpositions[0].y -= 153;   charholder.slotpositions[0].x -= 260;   charholder.displayname = char;   charholder.equipmentcol = 0;   if(char == char.toLowerCase() && char.toLowerCase() != char.toUpperCase()) charholder.displayname = ~[70%]~ + charholder.displayname;   if(charholder.displayname == ~Confirm~ # charholder.displayname == ~Bkspace~) charholder.equipmentcol = 2;   charholder.fulldescription = ~~;   charholder.height = 270;   charholder.width = 270;   charholder.x = buttonx;   charholder.y = buttony;   charholder.equipalpha = 0.0;   buttonx += 270;   if(i == 13) {    buttonx = 160;    buttony += 270;   }   if(i == 26) {    buttonx = 100;    buttony += 300;   }   if(i == 39) {    buttonx = 160;    buttony += 270;   }   if(i == 52) {    buttonx = 100;    buttony += 300;   }   if(i == 65) {    buttonx = 1620;    buttony += 270;   }  }   var tw = new motion.actuators.SimpleActuator(null|1/60|null);  tw._repeat = -1;  var s = new elements.Skill(~Against all odds_old~);  s.script = ~   var phonedone = false;   var wandwish = self.getvar(\~wandwish\~);   for(eq in self.equipment) {    if(self.getvar(\~phonephase2\~) != 1) {     if(eq.equipalpha > 0.0 && eq.getvar(\~standardcard\~) == 1) eq.equipalpha -= 0.2;     if(eq.equipalpha < 1.0 && eq.getvar(\~standardcard\~) != 1) eq.equipalpha += 0.2;     if(eq.assigneddice.length > 0 && eq.assigneddice[0] != null) {      eq.removedice();      var neweq = eq.copy();          neweq.height = 270;      neweq.width = 270;      neweq.equipalpha = eq.equipalpha;      neweq.displayname = eq.displayname;      neweq.equipmentcol = eq.equipmentcol;      neweq.slotpositions = eq.slotpositions;      neweq.script = eq.script;      self.equipment.push(neweq);      eq.name = \~deleteme\~;      eq.slots = [];      eq.equipalpha = 0;      if(eq.displayname != \~Confirm\~) {       sfx(\~jackpot_increasecounter\~);       if(eq.displayname == \~Bkspace\~ && wandwish.length > 6) wandwish = wandwish.substr(0|wandwish.length - 1);       else       if(eq.displayname.substr(0|1) == \~_\~) wandwish += \~_\~;       else       if(eq.displayname.substr(0|1) == \~[\~) wandwish += eq.displayname.substr(5|1);       else       if(eq.displayname != \~Bkspace\~) wandwish += eq.displayname.substr(0|1);      }      else {       sfx(\~_thinghappens\~);       self.setvar(\~phonephase2\~|1);      }     }    }    else {     if(eq.equipalpha <= 1.0 && eq.getvar(\~standardcard\~) == 1) {      eq.equipalpha += 0.2;     }     if(eq.equipalpha > 0.0 && eq.getvar(\~standardcard\~) != 1) {      eq.removedice();      eq.equipalpha -= 0.2;      eq.slots = [];      eq.script = \~self.equipmentused--; self.equipmenthistory.pop();\~;     }     if(eq.equipalpha <= 0.0 && eq.getvar(\~standardcard\~) != 1) {      eq.name = \~deleteme\~;      phonedone = true;     }    }   }      new elements.CombatCommand(\~msg\~|wandwish).execute();   self.setvar(\~wandwish\~|wandwish);      removeequipment(\~deleteme\~);   if(self.doendturnnow) {    trace(\~ending turn\~);    for(eq in self.equipment) {     if(eq.getvar(\~standardcard\~) == 1) {      eq.equipalpha = 1.0;      eq.slots = self.getvar(\~slotsbackup\~)[self.getvar(\~slotseqbackup\~).indexOf(eq)];      eq.shocked_slots = self.getvar(\~shockslotseqbackup\~)[self.getvar(\~slotseqbackup\~).indexOf(eq)];      eq.skillsavailable = self.getvar(\~skillsbackup\~)[self.getvar(\~slotseqbackup\~).indexOf(eq)];      if(self.usecpuinsteadofdice) self.roll_jackpot = self.getvar(\~rolljackpot\~);     }     else {      eq.name = \~deleteme\~;     }    }    removeequipment(\~deleteme\~);    removeequipment(\~Equipment That Does Nothing\~);    self.resetvar(\~slotsbackup\~);    self.resetvar(\~slotseqbackup\~);    self.resetvar(\~shockslotseqbackup\~);    self.resetvar(\~skillsbackup\~);    self.resetvar(\~rolljackpot\~);    new elements.CombatCommand(\~msg\~|\~\~).execute();    wandwish = wandwish.split(\~[200%]\~)[1].split(\~_\~).join(\~ \~);    var wandwisharr = wandwish.split(\~\~);    wandwish = \~\~;    for(char in wandwisharr) wandwish = char + wandwish;    var exceptions = getcolumn(loaddata(\~ncrmod/wishredirects\~)|\~input\~);    var redirects = getcolumn(loaddata(\~ncrmod/wishredirects\~)|\~redirect\~);    if(exceptions.indexOf(wandwish) != -1) wandwish = redirects[exceptions.indexOf(wandwish)];    if(getequipmentlist().indexOf(wandwish) != -1) {     if(self.getvar(\~ncrrobotepisode4\~) == 1 && self.getvar(\~ncrrobotepisode4wishlist\~).indexOf(wandwish) != -1) { self.textparticle(\~Already wished!\~); }     else {      if(self.getvar(\~ncrrobotepisode4\~) == 1) {       self.setvar(\~ncrrobotepisode4wishlist\~|self.getvar(\~ncrrobotepisode4wishlist\~).concat([wandwish]));       var familylist = loadtext(\~ncrmod/wishfamilies\~);       for(i in 0...familylist.length)  {        if(familylistsplit.indexOf(wandwish) != -1) {         self.setvar(\~ncrrobotepisode4wishlist\~|self.getvar(\~ncrrobotepisode4wishlist\~).concat(familylistsplit));        }       }       if(!new elements.Equipment(wandwish).hastag(\~powercard\~)) {        if(wandwish.substr(wandwish.length - 1|1) == \~?\~) {         self.setvar(\~ncrrobotepisode4wishlist\~|self.getvar(\~ncrrobotepisode4wishlist\~).concat([wandwish.substr(0|wandwish.length - 1)]));        }        else {         self.setvar(\~ncrrobotepisode4wishlist\~|self.getvar(\~ncrrobotepisode4wishlist\~).concat([wandwish + \~?\~]));        }       }      }      var newcard = new elements.Equipment(wandwish);      var replacecard = self.equipment[self.equipment.indexOf(self.getvar(\~wishingcard\~))];      trace(\~card made\~);      newcard.x = self.getvar(\~wishingcardx\~);      newcard.y = self.getvar(\~wishingcardy\~);      self.equipment[self.equipment.indexOf(self.getvar(\~wishingcard\~))] = newcard;      trace(\~card replaced\~);      newcard.animate(\~flashandshake\~);      self.setvar(\~doonthis\~|newcard); var estandardize = \~var e = self.getvar(\\\~doonthis\\\~); \~; var doscripts = new elements.Skill(\~Against all odds_old\~); doscripts.script = estandardize + newcard.scriptbeforecombat; doscripts.execute(self|target); doscripts.script = estandardize + newcard.scriptbeforestartturn; doscripts.execute(self|target); doscripts.script = estandardize + newcard.scriptonstartturn; doscripts.execute(self|target); self.resetvar(\~doonthis\~);      newcard.arrangeslots();      self.createsparedice(newcard);      trace(\~card flashed\~);     }    }    else self.textparticle(\~Invalid wish!\~);    self.resetvar(\~wishingcard\~); self.resetvar(\~diditwork\~);    self.getvar(\~wishactuator\~).stop();    self.status = self.getvar(\~selfstatusbackup\~);    target.status = self.getvar(\~targetstatusbackup\~);    self.resetvar(\~selfstatusbackup\~);    self.resetvar(\~targetstatusbackup\~);    self.resetvar(\~phonephase2\~);    self.resetvar(\~wishactuator\~);    self.resetvar(\~wandwish\~);    if(self.getvar(\~lendeddice\~) == 1) { for(dice in self.dicepool) { if(dice.available() && dice.basevalue == 1) { dice.animate(\~disappear\~); break; } } }    self.resetvar(\~lendeddice\~);   }      if(phonedone) {    for(eq in self.equipment) {     if(eq.getvar(\~standardcard\~) == 1) {      eq.equipalpha = 1.0;      var importantindex = self.getvar(\~slotseqbackup\~).indexOf(eq);      eq.slots = self.getvar(\~slotsbackup\~)[importantindex];      eq.shocked_slots = self.getvar(\~shockslotseqbackup\~)[importantindex];      eq.skillsavailable = self.getvar(\~skillsbackup\~)[importantindex];      if(self.usecpuinsteadofdice) self.roll_jackpot = self.getvar(\~rolljackpot\~);     }    }    removeequipment(\~Equipment That Does Nothing\~);    self.resetvar(\~slotsbackup\~);    self.resetvar(\~slotseqbackup\~);    self.resetvar(\~shockslotseqbackup\~);    self.resetvar(\~skillsbackup\~);    self.resetvar(\~rolljackpot\~);    new elements.CombatCommand(\~msg\~|\~\~).execute();    wandwish = wandwish.split(\~[200%]\~)[1].split(\~_\~).join(\~ \~);    var wandwisharr = wandwish.split(\~\~);    wandwish = \~\~;    for(char in wandwisharr) wandwish = char + wandwish;    var exceptions = getcolumn(loaddata(\~ncrmod/wishredirects\~)|\~input\~);    var redirects = getcolumn(loaddata(\~ncrmod/wishredirects\~)|\~redirect\~);    if(exceptions.indexOf(wandwish) != -1) wandwish = redirects[exceptions.indexOf(wandwish)];    if(getequipmentlist().indexOf(wandwish) != -1) {     if(self.getvar(\~ncrrobotepisode4\~) == 1 && self.getvar(\~ncrrobotepisode4wishlist\~).indexOf(wandwish) != -1) { self.textparticle(\~Already wished!\~); }     else {      if(self.getvar(\~ncrrobotepisode4\~) == 1) {       self.setvar(\~ncrrobotepisode4wishlist\~|self.getvar(\~ncrrobotepisode4wishlist\~).concat([wandwish]));       var familylist = loadtext(\~ncrmod/wishfamilies\~);       for(i in 0...familylist.length)  {        if(familylistsplit.indexOf(wandwish) != -1) {         self.setvar(\~ncrrobotepisode4wishlist\~|self.getvar(\~ncrrobotepisode4wishlist\~).concat(familylistsplit));        }       }       if(!new elements.Equipment(wandwish).hastag(\~powercard\~)) {        if(wandwish.substr(wandwish.length - 1|1) == \~?\~) {         self.setvar(\~ncrrobotepisode4wishlist\~|self.getvar(\~ncrrobotepisode4wishlist\~).concat([wandwish.substr(0|wandwish.length - 1)]));        }        else {         self.setvar(\~ncrrobotepisode4wishlist\~|self.getvar(\~ncrrobotepisode4wishlist\~).concat([wandwish + \~?\~]));        }       }      }      var newcard = new elements.Equipment(wandwish);      var replacecard = self.equipment[self.equipment.indexOf(self.getvar(\~wishingcard\~))];      trace(\~card made\~);      newcard.x = self.getvar(\~wishingcardx\~);      newcard.y = self.getvar(\~wishingcardy\~);      self.equipment[self.equipment.indexOf(self.getvar(\~wishingcard\~))] = newcard;      trace(\~card replaced\~);      newcard.animate(\~flashandshake\~);      self.setvar(\~doonthis\~|newcard); var estandardize = \~var e = self.getvar(\\\~doonthis\\\~); \~; var doscripts = new elements.Skill(\~Against all odds_old\~); doscripts.script = estandardize + newcard.scriptbeforecombat; doscripts.execute(self|target); doscripts.script = estandardize + newcard.scriptbeforestartturn; doscripts.execute(self|target); doscripts.script = estandardize + newcard.scriptonstartturn; doscripts.execute(self|target); self.resetvar(\~doonthis\~);      newcard.arrangeslots();      self.createsparedice(newcard);      trace(\~card flashed\~);     }    }    else self.textparticle(\~Invalid wish!\~);    self.resetvar(\~wishingcard\~); self.resetvar(\~diditwork\~);    self.getvar(\~wishactuator\~).stop();    self.status = self.getvar(\~selfstatusbackup\~);    target.status = self.getvar(\~targetstatusbackup\~);    self.resetvar(\~selfstatusbackup\~);    self.resetvar(\~targetstatusbackup\~);    self.resetvar(\~phonephase2\~);    self.resetvar(\~wishactuator\~);    self.resetvar(\~wandwish\~);    if(self.getvar(\~lendeddice\~) == 1) { for(dice in self.dicepool) { if(dice.available() && dice.basevalue == 1) { dice.animate(\~disappear\~); break; } } }    self.resetvar(\~lendeddice\~);   }  ~;  tw.onRepeat(s.execute|[self|target]);  self.setvar(~wishactuator~|tw);  tw.move(); },Oh Shit!,REQUIRE5|REQUIRE5,,BRIGHTCYAN,,,,,,YES,,excludefromrandomlists|cannotsteal,,,,,,,,,self.setvar(~wishingcardx~|e.x); self.setvar(~wishingcardy~|e.y);,,e.maintainfury = true; e.preventdefault = true;,
Dime,Roll 2 sixes,2,givedice([6|6]); /* 'dime a dozen' */,Rollout,EVEN|EVEN,,GREEN,change_power,change_power,,,,YES,,,,,,,,,,,,,,
Dime_downgraded,Roll 2 sixes,2,givedice([6|6]);,Rollout,REQUIRE6|EVEN,,GREEN,,,,,,YES,,,,,,,,,,,,,,
Dime_upgraded,Roll 2 sixes|,2,givedice([6|6]);,Rollout,EVEN|EVEN,,GREEN,,,,,2,YES,,,,,,,,,,,,,,
Backward Satanic Messages,Do [sword]<d6> damage. If enemy|has [silence][;] roll 2 dice equaling 8,2,attack(d); sfxdamage(target|d); sfx(~_fire~|~~|0.1); if(target.hasstatus(~ncr_silence~) # target.hasstatus(SILENCE)) { var dice = rand([2|3|4|5|6]); givedice([dice|8 - dice]); },Confiscate,NORMAL,,PURPLE,change_power,change_power,,,,,,,,,,,,,,,,,,
Backward Satanic Messages_downgraded,Do [sword]<d6> damage|[80%][gray]''?tahw woN .taerG''[],2,attack(d); sfxdamage(target|d); sfx(~_fire~|~~|0.1);,Confiscate,NORMAL,,PURPLE,,,,,,,,,,,,,,,,,,,,
Backward Satanic Messages_upgraded,Do [sword]<d6> dmg. If enemy|has [silence][;] roll 2 dice equaling 8|[80%][gray]''seikooc doog sekam nataS''[],2,attack(d); sfxdamage(target|d); sfx(~_fire~|~~|0.1); if(target.hasstatus(~ncr_silence~) # target.hasstatus(SILENCE)) { var dice = rand([2|3|4|5|6]); givedice([dice|8 - dice]); },Confiscate,NORMAL|FREE1,,PURPLE,,,,,,,,,,,,,,,,,,,,
Fatal Attraction,Drain [heart]4 health,2,drain(4); sfx(~_drain~);,Curved Mirror,MAX4,,ORANGE,simplify,change_power,,,,,,finale,,,,,,,,,,,,
Fatal Attraction_downgraded,Drain [heart]4 health,2,drain(4); sfx(~_drain~);,Curved Mirror,REQUIRE4,,ORANGE,,,,,,,,finale,,,,,,,,,,,,
Passivecation Program,Lock [lock]2 dice,2,inflict(LOCK|2); sfx(~_lock~); /*ncrmod jester finale cards include: brainwashing the enemy to become a model member of dystopian society*/,Copyright Strike,COUNTDOWN,10,ORANGE,change_power,change_power,,,,,,finale,,,,,,,,,,,,
Passivecation Program_downgraded,Blind [blind]2 dice,2,inflict(BLIND|2); sfx(~_blind~);,Copyright Strike,COUNTDOWN,10,ORANGE,,,,,,,,finale,,,,,,,,,,,,
Passivecation Program_upgraded,Lock [lock]3 dice,2,inflict(LOCK|3); sfx(~_lock~);,Copyright Strike,COUNTDOWN,10,ORANGE,,,,,,,,finale,,,,,,,,,,,,
Survival,Gain [gold]1 gold|[gray](once per battle),2,self.gold++;,Harvest,NORMAL,,ORANGE,change_power,change_power,,pickupgold,,YES,YES,finale|showgold,,,,,,,,,,,,
Survival_upgraded,Gain [gold]1 gold[;]|deal [sword]<d6> damage|[gray](once per battle),2,self.gold++; attack(d); sfxdamage(target|d);,Harvest,NORMAL,,ORANGE,,,,pickupgold,,YES,YES,finale|showgold,,,,,,,,,,,,
Survival_downgraded,Gain [gold]1 gold|[gray](once per battle),2,self.gold++;,Harvest,REQUIRE6,,ORANGE,,,,pickupgold,,YES,YES,finale|showgold,,,,,,,,,,,,
Anger,Burn [fire]<d6> dice,2,inflict(FIRE|d); sfx(~_fire~);,Heat Ray,EVEN|EVEN,,ORANGE,simplify,complicate,,,,,,finale,,,,,,,,,,,,
Hypnotise,Inflict [vanish]<d6> vanish,2,inflict(~ncr_vanish~|d); sfx(~_vanish~);,Mass Deception,EVEN|EVEN,,ORANGE,simplify,complicate,,,,,,finale,,,,,,,,,,,,
Untitled,Inflict [ice]<d6> freeze,2,inflict(ICE|d); sfx(~_ice~); /*there actually is a song in as the veneer of democracy starts to fade that's just known as 'untitled'. and i was running out of ideas. yes; anger/anger is holy isn't from that album; & neither is hypnotized; no i don't care*/,Arctic Storm,EVEN|EVEN,,ORANGE,simplify,complicate,,,,,,finale,,,,,,,,,,,,
Finale Salad,Increase max health by 1|[gray](once per battle),2,self.maxhp++; attackself(-1);,Regenerate,DOUBLES|DOUBLES,,ORANGE,change_power,change_power,,_heal,,YES,YES,finale,,,,,,,,,,,,
Finale Salad_upgraded,Increase max health by 1|[gray](once per battle),2,self.maxhp++; attackself(-1);,Regenerate,EVEN,,ORANGE,,,,_heal,,YES,YES,finale,,,,,,,,,,,,
Finale Salad_downgraded,Increase max health by 1|[gray](once per battle),2,self.maxhp++; attackself(-1);,Regenerate,REQUIRE6|REQUIRE6,,ORANGE,,,,_heal,,YES,YES,finale,,,,,,,,,,,,
Reissue,Gain a copy of the|last card you used|[gray](once per battle),2,if(self.equipmenthistory.length > 1 && self.equipmenthistory[self.equipmenthistory.length - 2] != null) { var lasteq = self.equipmenthistory[self.equipmenthistory.length - 2]; if(lasteq == e) { /*edgecase with tap - when tap activates both this (or remaster) and itself at once; tap is considered to have activated later*/ lasteq = self.equipmenthistory[self.equipmenthistory.length - 1]; } var eqtoadd = lasteq.name; if(lasteq.upgraded # lasteq.originallyupgraded) eqtoadd += ~+~; sfx(~openchest~); screenshake(); if(self.layout == ~DECK~) { addjestercard(eqtoadd); } else { giveequipment(eqtoadd|true|false); } } else { if(self.layout == ~DECK~) addjestercard(e.name + e.namemodifier); else giveequipment(e.name + e.namemodifier|true|false); } /*if it weren't so boring i'd hook up the ''run all the before combat/before start turn'' thing. this is a jester finale card anyway; what do i care*/,lolsorandom,EVEN,,ORANGE,simplify,complicate,,,,YES,YES,finale,,,,,,,,,,,,
Tap,Snap the card to the right|of this[;] if it's available,2,,Less Fluff,EVEN,,ORANGE,simplify,complicate,,none,,YES,,,,,,,,,,,var snapcard = null; var altequipment = [for(eq in self.equipment) if(eq.onscreen()) eq]; trace(altequipment); var _snapcard = null; _snapcard = altequipment[altequipment.indexOf(e) + 1]; trace(_snapcard); if(_snapcard != null) snapcard = _snapcard; if(snapcard != null && snapcard.onscreen() && snapcard.isready() && snapcard.slots.length > 0) { sfx(~jester_snap~); snapcard.animate(~snap~); var i = 0; for(slot in snapcard.slots) { trace(snapcard.slots); trace(slot); var snapvalue = 6; if(slot == ~ODD~) snapvalue = 5; if((slot + ~~).substr(0|3) == ~MAX~) snapvalue = (slot + ~~).substr(3|1) - 0; if((slot + ~~).substr(0|5) == ~RANGE~) snapvalue = (slot + ~~).substr(6|1) - 0; if(snapcard.remainingcountdown > 6) snapcard.remainingcountdown = 6; var snapdice = new elements.Dice(); snapdice.basevalue = snapvalue; self.dicepool.push(snapdice); snapcard.assigndice(snapdice|i); if(snapcard.remainingcountdown == 0 && (snapcard.needstotal == 0 # snapcard.needstotal == snapcard.getpower()) && (!snapcard.needsdoubles # [for(dice in snapcard.assigneddice) dice.basevalue == 6].indexOf(false) == -1)) { snapcard.doequipmentaction(self|target|1|snapcard.assigneddice|0|false|true); } } } else { self.textparticle(~No effect!~); } /*high concept donated by cody*/,,e.preventdefault = true; e.maintainfury = true;,
We Watch and We Wait,In [jinx]<d6> turns[;]|deal [sword]20 damage,2,jinx(~We Watch and We Wait~|~take [sword]20 damage~|~Take [sword]20 damage~|~attack(20); sfxdamage(null|20); sfx(\~_fire\~|\~\~|0.1); ~|target|self|d|0);  sfx(~_thinghappens~);,Drunken Boxing,MIN4,,ORANGE,increaserange,complicate,,,,,,finale,,,,,,,,,,,,
Saving Throw,Get a new dice. On 1[;]|get a dice over 3,1,if(d == 1) { givedice(rand([4|5|6])); } else givedice();,Double Whammy,MAX3,,GREEN,change_power,change_power,,,,YES,,,,,,,,,,,,,,
Saving Throw_upgraded,Get a dice over 3,1,givedice(rand([4|5|6]));,Double Whammy,MAX3,,GREEN,,,,,,YES,,,,,,,,,,,,,,
Saving Throw_downgraded,Get a new dice. On 1[;]|get a dice 3 or less,1,if(d == 1) { givedice(rand([1|2|3])); } else givedice();,Double Whammy,MAX3,,GREEN,,,,,,YES,,,,,,,,,,,,,,
Prod,Get a new dice. If limit is|fully charged[;] do [sword]5,1,givedice(); if(self.limitvalue != null && self.limitvalue == self.limitmax) { attack(5); sfxdamage(target|5); },Dice Bash,MAX3,,YELLOW,increaserange,decreaserange,,,,YES,,,,givedice();,,,,,,,if(self.limitvalue != null && self.limitvalue == self.limitmax) { e.castdirection = 1; } else { e.castdirection = -1; },,,
Bad Damage,Do [sword]<d6> damage. If you're|at full HP[;] return the dice,1,attack(d); sfxdamage(target|d); if(self.hp == self.maxhp) givedice(d);,Pea Gun,NORMAL,,RED,change_power,change_power,,,,,,,,if(self.hp == self.maxhp) givedice(d);,,,,,,,,,,
Bad Damage_downgraded,Do [sword]<d6> damage,1,attack(d); sfxdamage(target|d);,Pea Gun,NORMAL,,RED,,,,,,,,,,,,,,,,,,,,
Bad Damage_upgraded,Do [sword]<d6> damage. If 3 points|or less from full HP[;] return dice,1,attack(d); sfxdamage(target|d); if(self.hp >= self.maxhp - 3) givedice(d);,Pea Gun,NORMAL,,RED,,,,,,,,,,if(self.hp == self.maxhp) givedice(d);,,,,,,,,,,
Supervolcano,Do [fire]<d6> damage. On 6[;]|[fire]burn ALL[;] discard this,2,attack(d|FIRE); sfxdamage(target|d); if(d == 6) { inflict(FIRE|ALL); sfx(~_fire~|~~|0.1); e.onceperbattle = true; e.usedthisbattle = true; } /*thx kirb; cody; and cody again for the name suggestions; respectively*/,Heat Ray,NORMAL,,RED,reducesize,change_power,,,,,,,,if(d == 6) { e.onceperbattle = true; e.usedthisbattle = true; },,,,,,,,,,
Supercoolant,Do [ice]<d6> damage. On 6[;]|[ice]freeze ALL[;] discard this,2,attack(d|ICE); sfxdamage(target|d); if(d == 6) { inflict(ICE|ALL); sfx(~_ice~|~~|0.1); e.onceperbattle = true; e.usedthisbattle = true; },Arctic Storm,NORMAL,,BRIGHTCYAN,reducesize,change_power,,,,,,,,if(d == 6) { e.onceperbattle = true; e.usedthisbattle = true; },,,,,,,,,,
Superstition,Do [vanish]<d6> damage. On 6[;]|[vanish]vanish ALL[;] discard this,2,attack(d|VANISH); sfxdamage(target|d); if(d == 6) { inflict(VANISH); sfx(~_vanish~|~~|0.1); e.onceperbattle = true; e.usedthisbattle = true; },Mass Deception,NORMAL,,PINK,reducesize,change_power,,,,,,,,if(d == 6) { e.onceperbattle = true; e.usedthisbattle = true; },,,,,,,,,,
Supervolcano_downgraded,Do [fire]<d6> damage. On 6[;]|[fire]burn 2[;] discard this,2,attack(d|FIRE); sfxdamage(target|d); if(d == 6) { inflict(FIRE|2); sfx(~_fire~|~~|0.1); e.onceperbattle = true; e.usedthisbattle = true; },Heat Ray,NORMAL,,RED,,,,,,,,,,if(d == 6) { e.onceperbattle = true; e.usedthisbattle = true; },,,,,,,,,,
Supercoolant_downgraded,Do [ice]<d6> damage. On 6[;]|[ice]freeze 2[;] discard this,2,attack(d|ICE); sfxdamage(target|d); if(d == 6) { inflict(ICE|2); sfx(~_ice~|~~|0.1); e.onceperbattle = true; e.usedthisbattle = true; },Arctic Storm,NORMAL,,BRIGHTCYAN,,,,,,,,,,if(d == 6) { e.onceperbattle = true; e.usedthisbattle = true; },,,,,,,,,,
Superstition_downgraded,Do [vanish]<d6> damage. On 6[;]|[vanish]vanish 2[;] discard this,2,attack(d|VANISH); sfxdamage(target|d); if(d == 6) { inflict(~ncr_vanish~|2); sfx(~_vanish~|~~|0.1); e.onceperbattle = true; e.usedthisbattle = true; },Mass Deception,NORMAL,,PINK,,,,,,,,,,if(d == 6) { e.onceperbattle = true; e.usedthisbattle = true; },,,,,,,,,,
Supervolcano_deckupgrade,Do [fire]<d6> damage. On 6[;]|[fire]burn ALL[;] discard this,2,attack(d|FIRE); sfxdamage(target|d); if(d == 7) { inflict(FIRE|ALL); sfx(~_fire~|~~|0.1); e.onceperbattle = true; e.usedthisbattle = true; },Heat Ray,NORMAL|FREE1,,RED,,,,,,,,,,if(d == 6) { e.onceperbattle = true; e.usedthisbattle = true; },,,,,,,,,,
Supercoolant_deckupgrade,Do [ice]<d6> damage. On 6[;]|[ice]freeze ALL[;] discard this,2,attack(d|ICE); sfxdamage(target|d); if(d == 7) { inflict(ICE|ALL); sfx(~_ice~|~~|0.1); e.onceperbattle = true; e.usedthisbattle = true; },Arctic Storm,NORMAL|FREE1,,BRIGHTCYAN,,,,,,,,,,if(d == 6) { e.onceperbattle = true; e.usedthisbattle = true; },,,,,,,,,,
Superstition_deckupgrade,Do [vanish]<d6> damage. On 6[;]|[vanish]vanish ALL[;] discard this,2,attack(d|VANISH); sfxdamage(target|d); if(d == 7) { inflict(VANISH); sfx(~_vanish~|~~|0.1); e.onceperbattle = true; e.usedthisbattle = true; },Mass Deception,NORMAL|FREE1,,PINK,,,,,,,,,,if(d == 6) { e.onceperbattle = true; e.usedthisbattle = true; },,,,,,,,,,
Supervolcano_weakened,Do [fire]<d6> damage. On 6[;]|[fire]burn 2[;] discard this,1,attack(d|FIRE); sfxdamage(target|d); if(d == 6) { inflict(FIRE|2); sfx(~_fire~|~~|0.1); e.onceperbattle = true; e.usedthisbattle = true; },Heat Ray,NORMAL,,RED,,,,,,,,,,if(d == 6) { e.onceperbattle = true; e.usedthisbattle = true; },,,,,,,,,,
Supercoolant_weakened,Do [ice]<d6> damage. On 6[;]|[ice]freeze 2[;] discard this,1,attack(d|ICE); sfxdamage(target|d); if(d == 6) { inflict(ICE|2); sfx(~_ice~|~~|0.1); e.onceperbattle = true; e.usedthisbattle = true; },Arctic Storm,NORMAL,,BRIGHTCYAN,,,,,,,,,,if(d == 6) { e.onceperbattle = true; e.usedthisbattle = true; },,,,,,,,,,
Superstition_weakened,Do [vanish]<d6> damage. On 6[;]|[vanish]vanish 2[;] discard this,1,attack(d|VANISH); sfxdamage(target|d); if(d == 6) { inflict(~ncr_vanish~|2); sfx(~_vanish~|~~|0.1); e.onceperbattle = true; e.usedthisbattle = true; },Mass Deception,NORMAL,,PINK,,,,,,,,,,if(d == 6) { e.onceperbattle = true; e.usedthisbattle = true; },,,,,,,,,,
Foggy Glass,Get a dice[;] do [vanish]3 dmg|per [vanish]vanish on enemy,2,givedice(); if(getstatus(VANISH) > 0) { attack((target.dice + target.extradice + target.bonusdice) * 3); sfxdamage(target|(target.dice + target.extradice + target.bonusdice) * 3); } else { if(getstatus(~ncr_vanish~) == 0) { self.textparticle(~No effect!~); } else { attack(getstatus(~ncr_vanish~) * 3 | VANISH); sfxdamage(target|getstatus(~ncr_vanish~) * 3); } },Hadoken,ODD,,PINK,change_power,change_power,,_vanish,,,,,,givedice();,,,,,,,,,,
Foggy Glass_upgraded,Get a dice[;] do [vanish]4 dmg|per [vanish]vanish on enemy,2,givedice(); if(getstatus(VANISH) > 0) { attack((target.dice + target.extradice + target.bonusdice) * 4); sfxdamage(target|(target.dice + target.extradice + target.bonusdice) * 4); } else { if(getstatus(~ncr_vanish~) == 0) { self.textparticle(~No effect!~); } else { attack(getstatus(~ncr_vanish~) * 4 | VANISH); sfxdamage(target|getstatus(~ncr_vanish~) * 4); } },Hadoken,ODD,,PINK,,,,_vanish,,,,,,givedice();,,,,,,,,,,
Foggy Glass_downgraded,Do [vanish]3 dmg per|[vanish]vanish on enemy,2,if(getstatus(VANISH) > 0) { attack((target.dice + target.extradice + target.bonusdice) * 3); sfxdamage(target|(target.dice + target.extradice + target.bonusdice) * 3); } else { if(getstatus(~ncr_vanish~) == 0) { self.textparticle(~No effect!~); } else { attack(getstatus(~ncr_vanish~) * 3 | VANISH); sfxdamage(target|getstatus(~ncr_vanish~) * 3); } },Hadoken,ODD,,PINK,,,,_vanish,,,,,,,,,,,,,,,,
Scientology Pamphlet,Double enemy [vanish]vanish,1,if(getstatus(VANISH) > 0) { inflict(~ncr_vanish~|target.dice + target.extradice + target.bonusdice); /*can bait alt. reduce*/ } else { if(getstatus(~ncr_vanish~) > 0) { inflict(~ncr_vanish~|getstatus(~ncr_vanish~)); } else { self.textparticle(~No effect!~); } },Overload,DOUBLES|DOUBLES,,PINK,change_power,change_power,,_vanish,,,,,,,,,,,,,,,,
Scientology Pamphlet_upgraded,Double enemy [vanish]vanish,1,if(getstatus(VANISH) > 0) { inflict(~ncr_vanish~|target.dice + target.extradice + target.bonusdice); /*can bait alt. reduce*/ } else { if(getstatus(~ncr_vanish~) > 0) { inflict(~ncr_vanish~|getstatus(~ncr_vanish~)); } else { self.textparticle(~No effect!~); } },Overload,EVEN,,PINK,,,,_vanish,,,,,,,,,,,,,,,,
Scientology Pamphlet_downgraded,Increase enemy [vanish]vanish|by 50 percent,1,if(getstatus(VANISH) > 0) { inflict(~ncr_vanish~|(target.dice + target.extradice + target.bonusdice) * 0.5); /*can bait alt. reduce*/ } else { if(getstatus(~ncr_vanish~) > 0) { inflict(~ncr_vanish~|getstatus(~ncr_vanish~) *  0.5); } else { self.textparticle(~No effect!~); } },Overload,DOUBLES|DOUBLES,,PINK,,,,_vanish,,,,,,,,,,,,,,,,
Molten Glass,Get a new dice[;] do [fire]3 dmg|per [fire]burn on enemy,2,givedice(); if(getstatus(FIRE) > 0) { attack(getstatus(FIRE) * 3|FIRE); sfxdamage(target|getstatus(FIRE) * 3); } else { self.textparticle(~No effect!~); },Blowtorch,ODD,,RED,change_power,change_power,,_fire,,,,,,givedice();,,,,,,,,,,
Molten Glass_upgraded,Get a new dice[;] do [fire]4 dmg|per [fire]burn on enemy,2,givedice(); if(getstatus(FIRE) > 0) { attack(getstatus(FIRE) * 4|FIRE); sfxdamage(target|getstatus(FIRE) * 4); } else { self.textparticle(~No effect!~); },Blowtorch,ODD,,RED,,,,_fire,,,,,,givedice();,,,,,,,,,,
Molten Glass_downgraded,Do [fire]3 dmg per|[fire]burn on enemy,2,if(getstatus(FIRE) > 0) { attack(getstatus(FIRE) * 3|FIRE); sfxdamage(target|getstatus(FIRE) * 3); } else { self.textparticle(~No effect!~); },Blowtorch,ODD,,RED,,,,_fire,,,,,,,,,,,,,,,,
This is Fine,Double enemy [fire]burn,1,if(getstatus(FIRE) > 0) { inflict(FIRE|getstatus(FIRE)); } else { self.textparticle(~No effect!~); },Overload,DOUBLES|DOUBLES,,RED,change_power,change_power,,_fire,,,,,,,,,,,,,,,,
This is Fine_upgraded,Double enemy [fire]burn,1,if(getstatus(FIRE) > 0) { inflict(FIRE|getstatus(FIRE)); } else { self.textparticle(~No effect!~); },Overload,EVEN,,RED,,,,_fire,,,,,,,,,,,,,,,,
This is Fine_downgraded,Increase enemy [fire]burn|by 50 percent,1,if(getstatus(FIRE) > 0) { inflict(FIRE|getstatus(FIRE) * 0.5); } else { self.textparticle(~No effect!~); },Overload,DOUBLES|DOUBLES,,RED,,,,_fire,,,,,,,,,,,,,,,,
Frosted Glass,Get a new dice[;] do [ice]3 dmg|per [ice]freeze on enemy,2,givedice(); if(getstatus(ICE) > 0) { attack(getstatus(ICE) * 3|ICE); sfxdamage(target|getstatus(ICE) * 3); } else { self.textparticle(~No effect!~); },Flash Freeze,ODD,,BRIGHTCYAN,change_power,change_power,,_ice,,,,,,givedice();,,,,,,,,,,
Frosted Glass_upgraded,Get a new dice[;] do [ice]4 dmg|per [ice]freeze on enemy,2,givedice(); if(getstatus(ICE) > 0) { attack(getstatus(ICE) * 4|ICE); sfxdamage(target|getstatus(ICE) * 4); } else { self.textparticle(~No effect!~); },Flash Freeze,ODD,,BRIGHTCYAN,,,,_ice,,,,,,givedice();,,,,,,,,,,
Frosted Glass_downgraded,Do [ice]3 dmg per|[ice]freeze on enemy,2,if(getstatus(ICE) > 0) { attack(getstatus(ICE) * 3|ICE); sfxdamage(target|getstatus(ICE) * 3); } else { self.textparticle(~No effect!~); },Flash Freeze,ODD,,BRIGHTCYAN,,,,_ice,,,,,,,,,,,,,,,,
Fortune Abhors the Cold,Double enemy [ice]freeze,1,if(getstatus(ICE) > 0) { inflict(ICE|getstatus(ICE)); } else { self.textparticle(~No effect!~); },Overload,DOUBLES|DOUBLES,,BRIGHTCYAN,change_power,change_power,,_ice,,,,,,,,,,,,,,,,
Fortune Abhors the Cold_upgraded,Double enemy [ice]freeze,1,if(getstatus(ICE) > 0) { inflict(ICE|getstatus(ICE)); } else { self.textparticle(~No effect!~); },Overload,EVEN,,BRIGHTCYAN,,,,_ice,,,,,,,,,,,,,,,,
Fortune Abhors the Cold_downgraded,Increase enemy [ice]freeze|by 50 percent,1,if(getstatus(ICE) > 0) { inflict(ICE|getstatus(ICE) * 0.5); } else { self.textparticle(~No effect!~); },Overload,DOUBLES|DOUBLES,,BRIGHTCYAN,,,,_ice,,,,,,,,,,,,,,,,
Wicker Man[],Burning Man|Burn 2 dice for both,2,var oldburn = 0; var oldaltburn = 0; if(self.status.length > 0) { for(stat in self.status) { if(stat.type == ~fire~) { oldburn = stat.value; } if(stat.type == ~alternate_fire~) { oldaltburn = stat.value; } } } inflictself(FIRE|2); sfx(~_fire~); inflict(FIRE|2); var inflictwhat = ~~; for(stat in self.status) { if(stat.type == ~fire~ && stat.value != oldburn) { inflictwhat = stat.type; } if(stat.type == ~alternate_fire~ && stat.value != oldaltburn) { inflictwhat = stat.type; } } if(inflictwhat != ~~) { var dicelist = []; for(mydice in self.dicepool) { if(mydice.available() && mydice.burn != true && mydice.alternateburn != true) { dicelist.push(mydice); } } if(dicelist.length > 0) { shuffle(dicelist); dicelist[0].animate(inflictwhat); } if(dicelist.length > 1) { dicelist[1].animate(inflictwhat|0.2); } if(self.status.length > 0) { for(stat in self.status) { if(stat.type == inflictwhat) { stat.value -= 2; } } } },Hellfire,,,RED,,change_power,,,,,,powercard,,,,,,,,,,,,
Wicker Man[]_downgraded,Fire Hazard|Burn 1 dice for both,2,var oldburn = 0; var oldaltburn = 0; if(self.status.length > 0) { for(stat in self.status) { if(stat.type == ~fire~) { oldburn = stat.value; } if(stat.type == ~alternate_fire~) { oldaltburn = stat.value; } } } inflictself(FIRE); sfx(~_fire~); inflict(FIRE); var inflictwhat = ~~; for(stat in self.status) { if(stat.type == ~fire~ && stat.value != oldburn) { inflictwhat = stat.type; } if(stat.type == ~alternate_fire~ && stat.value != oldaltburn) { inflictwhat = stat.type; } } if(inflictwhat != ~~) { var dicelist = []; for(mydice in self.dicepool) { if(mydice.available() && mydice.burn != true && mydice.alternateburn != true) { dicelist.push(mydice); } } if(dicelist.length > 0) { shuffle(dicelist); dicelist[0].animate(inflictwhat); } if(self.status.length > 0) { for(stat in self.status) { if(stat.type == inflictwhat) { stat.value--; } } } } /*-we walked in?*/,Hellfire,,,RED,,,,,,,,powercard,,,,,,,,,,,,
Wicker Man?,Moth's Beanie|Gain [reduce]1 reduce,2,inflictself(REDUCE); sfx(~_shield~);,Protection,,,RED,,change_power,,,,YES,,alternateversion|powercard,,,,,,,,,,,,
Wicker Man?_downgraded,Raw Bee Power|Inflict [shock]1 shock,2,inflict(SHOCK); sfx(~_shock~);,Protection,,,RED,,,,,,YES,,alternateversion|powercard,,,,,,,,,,,,
Even Cauldron,Do [sword]1 damage[;]|receive [gold]1 gold|[gray](once per battle),1,attack(1); self.gold++; sfx(~pickupgold~); /*this is actually a rather old item. i'm not sure why i removed it*/,Harvest,NORMAL,,YELLOW,change_power,change_power,,,,,YES,showgold,,self.gold++; sfx(~pickupgold~);,,,,,,,,,,
Even Cauldron_upgraded,Do [sword]2 damage[;]|receive [gold]2 gold|[gray](once per battle),1,attack(2); self.gold += 2; sfx(~pickupgold~);,Harvest,NORMAL|NORMAL,,YELLOW,,,,,,,YES,showgold,,self.gold += 2; sfx(~pickupgold~);,,,,,,,,,,
Even Cauldron_downgraded,Receive [gold]1 gold|[gray](once per battle),1,self.gold++;,Harvest,NORMAL,,YELLOW,,,,pickupgold,,YES,YES,showgold,,,,,,,,,,,,
Healthcare,Pay [gold]<d6>[;] heal <double>|Return dice if unaffordable,1,if (self.gold >= d) { self.gold -= d; attackself(-d * 2); sfx(~_heal~); sfx(~pickupgold~); } else { givedice(d); },Health Pack,MAX4,,YELLOW,increaserange,change_power,,,,YES,,showgold,,,,,,,,,,,,
Healthcare_downgraded,Pay [gold]<d6>[;] heal <double>,1,if (self.gold >= d) { self.gold -= d; attackself(-d * 2); sfx(~_heal~); sfx(~pickupgold~); } else { self.textparticle(~Can't afford!~); },Health Pack,MAX4,,YELLOW,,,,,,YES,,showgold,,,,,,,,,,,,
Lucky Charm,Double the success odds|of chance based items,1,inflictself(~luck~);,Rejuvenate,EVEN,,GREEN,simplify,complicate,,none,0,YES,,,,,,,,,,,,,,
Reckless Flailing,(100/<d6>)% chance: [sword]<triple>|Otherwise[;] no effect,1,var odds = (100 / d); if(getstatusself(~luck~) > 0){ odds *= 2; } if(getstatusself(~luck+~) > 0 # odds > 100){ odds = 100; } if(chance(odds)) { self.textparticle(~Success!~); attack(d * 3); sfxdamage(target|d * 3); } else { self.textparticle(~No effect!~); },Rubber Bullet,NORMAL,,RED,change_power,change_power,,none,0,NO,,,,,,,,,,,,,,
Reckless Flailing_upgraded,(100/<d6>)% chance: [sword]<triple>|Otherwise[;] do [sword]2 damage,1,var odds = (100 / d); if(getstatusself(~luck~) > 0){ odds *= 2; } if(getstatusself(~luck+~) > 0 # odds > 100){ odds = 100; } if(chance(odds)) { self.textparticle(~Success!~); attack(d * 3); sfxdamage(target|d * 3); } else { attack(2); sfxdamage(target|2); },Rubber Bullet,NORMAL,,RED,,,,none,0,NO,,,,,,,,,,,,,,
Reckless Flailing_downgraded,(100/<d6>)% chance: [sword]<double>|Otherwise[;] no effect,1,var odds = (100 / d); if(getstatusself(~luck~) > 0){ odds *= 2; } if(getstatusself(~luck+~) > 0 # odds > 100){ odds = 100; } if(chance(odds)) { self.textparticle(~Success!~); attack(d * 2); sfxdamage(target|d * 3); } else { self.textparticle(~No effect!~); },Rubber Bullet,NORMAL,,RED,,,,none,0,NO,,,,,,,,,,,,,,
Beginner's Luck,If you have [heal]Luck[;]|exchange it for a blessing|Return the dice,1,if(getstatusself(~luck~) > 0 # getstatusself(~luck+~) > 0) { removestatusself(~luck~); removestatusself(~luck+~); var sfxdelay = 0; for(i in 0...0) { var randomstatus = SHIELD; if(getstatusself(FURY) == 0) { randomstatus = rand([SHIELD|FURY|REDUCE|REEQUIPNEXT|DODGE]); } else { randomstatus = rand([SHIELD|REDUCE|REEQUIPNEXT|DODGE]); } var a = 1; if (randomstatus == SHIELD) a = 4; if (randomstatus == REDUCE) a = 2; inflictself(randomstatus | a); sfx(~_~ + randomstatus.toLowerCase()|~~|sfxdelay); sfxdelay += 0.1; } } else { self.textparticle(~No effect!~); } givedice(d);,Power Up,NORMAL,,GREEN,change_power,change_power,,none,0,YES,,,,,,,,,,donothing();,,,,
Beginner's Luck_upgraded,If you have [heal]Luck[;]|gain a blessing|Return the dice,1,if(getstatusself(~luck~) > 0 # getstatusself(~luck+~) > 0) { var sfxdelay = 0; for(i in 0...0) { var randomstatus = SHIELD; if(getstatusself(FURY) == 0) { randomstatus = rand([SHIELD|FURY|REDUCE|REEQUIPNEXT|DODGE]); } else { randomstatus = rand([SHIELD|REDUCE|REEQUIPNEXT|DODGE]); } var a = 1; if (randomstatus == SHIELD) a = 4; if (randomstatus == REDUCE) a = 2; inflictself(randomstatus | a); sfx(~_~ + randomstatus.toLowerCase()|~~|sfxdelay); sfxdelay += 0.1; } } else { self.textparticle(~No effect!~); } givedice(d);,Power Up,NORMAL,,GREEN,,,,none,0,YES,,,,,,,,,,donothing();,,,,
Beginner's Luck_downgraded,If you have [heal]Luck[;]|exchange it for a blessing,1,if(getstatusself(~luck~) > 0 # getstatusself(~luck+~) > 0) { removestatusself(~luck~); removestatusself(~luck+~); var sfxdelay = 0; for(i in 0...0) { var randomstatus = SHIELD; if(getstatusself(FURY) == 0) { randomstatus = rand([SHIELD|FURY|REDUCE|REEQUIPNEXT|DODGE]); } else { randomstatus = rand([SHIELD|REDUCE|REEQUIPNEXT|DODGE]); } var a = 1; if (randomstatus == SHIELD) a = 4; if (randomstatus == REDUCE) a = 2; inflictself(randomstatus | a); sfx(~_~ + randomstatus.toLowerCase()|~~|sfxdelay); sfxdelay += 0.1; } } else { self.textparticle(~No effect!~); },Power Up,NORMAL,,GREEN,,,,none,0,YES,,,,,,,,,,,,,,
Fissure@ncrmod,33% chance: [fire]<triple> dmg|Otherwise[;] no effect,2,var odds = 33; if(getstatusself(~luck~) > 0){ odds *= 2; } if(getstatusself(~luck+~) > 0){ odds = 100; } if(chance(odds)) { self.textparticle(~Success!~); attack(d * 3|FIRE); sfxdamage(target|d * 3); } else { self.textparticle(~No effect!~); },Heat Ray,ODD,,RED,change_power,change_power,,none,0,NO,,,,,,,,,,,,,,
Fissure@ncrmod_upgraded,33% chance: [fire]<triple> dmg|Otherwise[;] roll a burnt dice,2,var odds = 33; if(getstatusself(~luck~) > 0){ odds *= 2; } if(getstatusself(~luck+~) > 0){ odds = 100; } if(chance(odds)) { self.textparticle(~Success!~); attack(d * 3|FIRE); sfxdamage(target|d * 3); } else { inflictself(FIRE); givedice(); },Heat Ray,ODD,,RED,,,,none,0,NO,,,,,,,,,,,,,,
Fissure@ncrmod_downgraded,33% chance: [fire]<triple> dmg|Otherwise[;] take [fire]3 dmg,2,var odds = 33; if(getstatusself(~luck~) > 0){ odds *= 2; } if(getstatusself(~luck+~) > 0){ odds = 100; } if(chance(odds)) { self.textparticle(~Success!~); attack(d * 3|FIRE); sfxdamage(target|d * 3); } else { attackself(3|FIRE); },Heat Ray,ODD,,RED,,,,none,0,NO,,,,,,,,,,,,,,
Sheer Cold,33% chance: [ice]<triple> dmg|Otherwise[;] no effect,2,var odds = 33; if(getstatusself(~luck~) > 0){ odds *= 2; } if(getstatusself(~luck+~) > 0){ odds = 100; } if(chance(odds)) { self.textparticle(~Success!~); attack(d * 3|ICE); sfxdamage(target|d * 3); } else { self.textparticle(~No effect!~); },Arctic Storm,ODD,,BRIGHTCYAN,change_power,change_power,,none,0,NO,,,,,,,,,,,,,,
Sheer Cold_upgraded,33% chance: [ice]<triple> dmg|Otherwise[;] roll a 1,2,var odds = 33; if(getstatusself(~luck~) > 0){ odds *= 2; } if(getstatusself(~luck+~) > 0){ odds = 100; } if(chance(odds)) { self.textparticle(~Success!~); attack(d * 3|ICE); sfxdamage(target|d * 3); } else { givedice(1); },Arctic Storm,ODD,,BRIGHTCYAN,,,,none,0,NO,,,,,,,,,,,,,,
Sheer Cold_downgraded,33% chance: [ice]<triple> dmg|Otherwise[;] take [ice]3 dmg,2,var odds = 33; if(getstatusself(~luck~) > 0){ odds *= 2; } if(getstatusself(~luck+~) > 0){ odds = 100; } if(chance(odds)) { self.textparticle(~Success!~); attack(d * 3|ICE); sfxdamage(target|d * 3); } else { attackself(3|ICE); },Arctic Storm,ODD,,BRIGHTCYAN,,,,none,0,NO,,,,,,,,,,,,,,
Guillotine,33% chance: [vanish]<triple> dmg|Otherwise[;] no effect,2,var odds = 33; if(getstatusself(~luck~) > 0){ odds *= 2; } if(getstatusself(~luck+~) > 0){ odds = 100; } if(chance(odds)) { self.textparticle(~Success!~); attack(d * 3|VANISH); sfxdamage(target|d * 3); } else { self.textparticle(~No effect!~); },Mass Deception,ODD,,PINK,change_power,change_power,,none,0,NO,,,,,,,,,,,,,,
Guillotine_upgraded,33% chance: [vanish]<triple> dmg|Otherwise[;] roll a dice[;] get [vanish]1,2,var odds = 33; if(getstatusself(~luck~) > 0){ odds *= 2; } if(getstatusself(~luck+~) > 0){ odds = 100; } if(chance(odds)) { self.textparticle(~Success!~); attack(d * 3|VANISH); sfxdamage(target|d * 3); } else { givedice(); inflictself(~ncr_vanish~); },Mass Deception,ODD,,PINK,,,,none,0,NO,,,,,,,,,,,,,,
Guillotine_downgraded,33% chance: [vanish]<triple> dmg|Otherwise[;] take [vanish]3 dmg,2,var odds = 33; if(getstatusself(~luck~) > 0){ odds *= 2; } if(getstatusself(~luck+~) > 0){ odds = 100; } if(chance(odds)) { self.textparticle(~Success!~); attack(d * 3|VANISH); sfxdamage(target|d * 3); } else { self.textparticle(~No effect!~); },Mass Deception,ODD,,PINK,,,,none,0,NO,,,,,,,,,,,,,,
Healer Staff,Do [sword]<d6> damage|20% chance to heal [heal]<d6>,2,var odds = 20; if(getstatusself(~luck~) > 0){ odds *= 2; } if(getstatusself(~luck+~) > 0){ odds = 100; } attack(d); if(chance(odds)) { self.textparticle(~Success!~); attackself(-d); sfx(~_heal~|~~|0.2); } sfxdamage(target|d); ,Regenerate,EVEN,,GREEN,simplify,complicate,,none,0,NO,,,,,,,,,,,,,,
Boiling Cauldron,Take [fire]2 damage[;]|get 2 new dice,1,attackself(2|FIRE); sfx(~_fire~); givedice([for(i in 0...2) rand([1|2|3|4|5|6])]);,Oh Shit!,NORMAL,,RED,change_power,change_power,,,,YES,,,,,,,,,,,,,,
Boiling Cauldron_upgraded,Take [fire]3 damage[;]|get 3 new dice,1,attackself(3|FIRE); sfx(~_fire~); givedice([for(i in 0...3) rand([1|2|3|4|5|6])]);,Oh Shit!,NORMAL,,RED,,,,,,YES,,,,,,,,,,,,,,
Boiling Cauldron_downgraded,Take [fire]1 damage[;]|get a new dice,1,attackself(1|FIRE); sfx(~_fire~); givedice();,Oh Shit!,NORMAL,,RED,,,,,,YES,,,,,,,,,,,,,,
Coldron,Take [ice]2 damage[;]|get 2 new dice,1,attackself(2|ICE); sfx(~_ice~); givedice([for(i in 0...2) rand([1|2|3|4|5|6])]);,Oh Shit!,NORMAL,,BRIGHTCYAN,change_power,change_power,,,,YES,,,,,,,,,,,,,,
Coldron_upgraded,Take [ice]3 damage[;]|get 3 new dice,1,attackself(3|ICE); sfx(~_ice~); givedice([for(i in 0...3) rand([1|2|3|4|5|6])]);,Oh Shit!,NORMAL,,BRIGHTCYAN,,,,,,YES,,,,,,,,,,,,,,
Coldron_downgraded,Take [ice]1 damage[;]|get a new dice,1,attackself(1|ICE); sfx(~_ice~); givedice();,Oh Shit!,NORMAL,,BRIGHTCYAN,,,,,,YES,,,,,,,,,,,,,,
Ritual Cauldron,Take [vanish]2 damage[;]|get 2 new dice,1,attackself(2|VANISH); sfx(~_vanish~); givedice([for(i in 0...2) rand([1|2|3|4|5|6])]);,Oh Shit!,NORMAL,,PINK,change_power,change_power,,,,YES,,,,,,,,,,,,,,
Ritual Cauldron_upgraded,Take [vanish]3 damage[;]|get 3 new dice,1,attackself(3|VANISH); sfx(~_vanish~); givedice([for(i in 0...3) rand([1|2|3|4|5|6])]);,Oh Shit!,NORMAL,,PINK,,,,,,YES,,,,,,,,,,,,,,
Ritual Cauldron_downgraded,Take [vanish]1 damage[;]|get a new dice,1,attackself(1|VANISH); sfx(~_vanish~); givedice();,Oh Shit!,NORMAL,,PINK,,,,,,YES,,,,,,,,,,,,,,
Planet Nine,Odd turns: do [vanish]<oddturn_d6> damage|Even: inflict [vanish]1[;] return dice,2,if(turn % 2 == 1) { attack(d|VANISH); sfxdamage(target|d); } else { inflict(~ncr_vanish~); sfx(~_vanish~); givedice(d); },Neutron Star,NORMAL,,PINK,reducesize,complicate,,,,,,,,if(turn % 2 == 0) { givedice(d); },,,,,,,,,,
Red Dwarf,Odd turns: do [fire]<oddturn_d6> damage|Even: inflict [fire]1[;] return dice,2,if(turn % 2 == 1) { attack(d|FIRE); sfxdamage(target|d); } else { inflict(FIRE); sfx(~_fire~); givedice(d); },Neutron Star,NORMAL,,RED,reducesize,complicate,,,,,,,,if(turn % 2 == 0) { givedice(d); },,,,,,,,,,
Shiver Star,Odd turns: do [ice]<oddturn_d6> damage|Even: inflict [ice]1[;] return dice,2,if(turn % 2 == 1) { attack(d|ICE); sfxdamage(target|d); } else { inflict(ICE); sfx(~_ice~); givedice(d); },Neutron Star,NORMAL,,BRIGHTCYAN,reducesize,complicate,,,,,,,,if(turn % 2 == 0) { givedice(d); },,,,,,,,,,
Planet Nine_weakened,Odd turns: do [vanish]<oddturn_d6> damage|Even: inflict [vanish]1[;] return dice,1,if(turn % 2 == 1) { attack(d|VANISH); sfxdamage(target|d); } else { inflict(~ncr_vanish~); sfx(~_vanish~); givedice(d); },Neutron Star,MAX3,,PINK,,,,,,,,,,if(turn % 2 == 0) { givedice(d); },,,,,,,,,,
Red Dwarf_weakened,Odd turns: do [fire]<oddturn_d6> damage|Even: inflict [fire]1[;] return dice,1,if(turn % 2 == 1) { attack(d|FIRE); sfxdamage(target|d); } else { inflict(FIRE); sfx(~_fire~); givedice(d); },Neutron Star,MAX3,,RED,,,,,,,,,,if(turn % 2 == 0) { givedice(d); },,,,,,,,,,
Shiver Star_weakened,Odd turns: do [ice]<oddturn_d6> damage|Even: inflict [ice]1[;] return dice,1,if(turn % 2 == 1) { attack(d|ICE); sfxdamage(target|d); } else { inflict(ICE); sfx(~_ice~); givedice(d); },Neutron Star,MAX3,,BRIGHTCYAN,,,,,,,,,,if(turn % 2 == 0) { givedice(d); },,,,,,,,,,
Planet Nine_deckupgrade,Odd turns: do [vanish]<oddturn_d6> dmg|Even: inflict [vanish]1[;] reroll dice,2,if(turn % 2 == 1) { attack(d|VANISH); sfxdamage(target|d); } else { inflict(~ncr_vanish~); sfx(~_vanish~); givedice(); },Neutron Star,NORMAL|FREE2,,PINK,reducesize,complicate,,,,,,,,if(turn % 2 == 0) { givedice(d); },,,,,,,,,,
Red Dwarf_deckupgrade,Odd turns: do [fire]<oddturn_d6> dmg|Even: inflict [fire]1[;] reroll dice,2,if(turn % 2 == 1) { attack(d|FIRE); sfxdamage(target|d); } else { inflict(FIRE); sfx(~_fire~); givedice(); },Neutron Star,NORMAL|FREE2,,RED,reducesize,complicate,,,,,,,,if(turn % 2 == 0) { givedice(d); },,,,,,,,,,
Shiver Star_deckupgrade,Odd turns: do [ice]<oddturn_d6> dmg|Even: inflict [ice]1[;] reroll dice,2,if(turn % 2 == 1) { attack(d|ICE); sfxdamage(target|d); } else { inflict(ICE); sfx(~_ice~); givedice(); },Neutron Star,NORMAL|FREE2,,BRIGHTCYAN,reducesize,complicate,,,,,,,,if(turn % 2 == 0) { givedice(d); },,,,,,,,,,
Radioactive Decay,If this is the <d6>th card used|this turn[;] inflict [poison]<d6> poison|(cards used: <equipmentuse>),2,if(self.equipmentused == d) { inflict(POISON|d); sfx(~_poison~); } else { self.textparticle(~No effect!~); },Anthrax,NORMAL,,PURPLE,reducesize,change_power,,,,,,,,,,,,,,,,,,
Radioactive Decay_downgraded,If this is the <d6>th card used|this turn[;] inflict [poison]<d6> poison|(cards used: <equipmentuse>),2,if(self.equipmentused == d) { inflict(POISON|d); sfx(~_poison~); } else { self.textparticle(~No effect!~); },Anthrax,MAX4,,PURPLE,,,,,,,,,,,,,,,,,,,,
Radioactive Decay_weakened,If this is the <d6>th card used|this turn[;] inflict [poison]<d6> poison|(cards used: <equipmentuse>),1,if(self.equipmentused == d) { inflict(POISON|d); sfx(~_poison~); } else { self.textparticle(~No effect!~); },Anthrax,MAX4,,PURPLE,,,,,,,,,,,,,,,,,,,,
Radioactive Decay_deckupgrade,If this is the <d6>th card used|this turn[;] inflict [poison]<d6> poison|(cards used: <equipmentuse>),2,if(self.equipmentused == d) { inflict(POISON|d); sfx(~_poison~); } else { self.textparticle(~No effect!~); },Anthrax,NORMAL|FREE2,,PURPLE,,,,,,,,,,,,,,,,,,,,
Super Backfire,Lose [heart]5 health|Return the dice,1,pierceattackself(5); givedice(d);,Oh Shit!,REQUIRE1,,PURPLE,change_backfire,change_power,,_heal,0,YES,NO,,1,,,,,,,,,,,
Super Backfire_downgraded,Lose [heart]15 health|Return the dice,1,pierceattackself(15); givedice(d);,Oh Shit!,REQUIRE1,,PURPLE,,,,_heal,0,YES,NO,,,,,,,,,,,,,
Super Backfire_weakened,Lose [heart]15 health|Return the dice,1,pierceattackself(15); givedice(d);,Oh Shit!,REQUIRE1,,PURPLE,,,,_heal,0,YES,NO,,,,,,,,,,,,,
Super Backfire_upgraded,Lose [heart]10 health|Return the dice,1,pierceattackself(10); givedice(d);,Oh Shit!,REQUIRE1,,PURPLE,,,,_heal,0,YES,NO,,,,,,,,,,,,,
Cyclone,Do [sword]<d6> damage[;]|roll two locked dice,2,attack(d); sfxdamage(target|d); givedice([for(i in 0...2) rand([1|2|3|4|5|6])]); var lockisalt = false; var dummyfighter = new elements.Fighter(~Wisp~); dummyfighter.addstatus(~lock~|1); trace(dummyfighter.status.length); if(dummyfighter.status.length > 0) { for(stat in dummyfighter.status) { if(stat.type == ~alternate_lock~) { lockisalt = true; } } }  if(lockisalt) {  for(mydice in [for(i in 0...2) self.dicepool[(self.dicepool.length - 1) - i]]) {   mydice.animate(~alternate_lock~);  }  inflictself(~alternate_lock~|2); } else {  for(mydice in [for(i in 0...2) self.dicepool[(self.dicepool.length - 1) - i]]) {   mydice.locked = true;  }  sfx(~_lock~); },Copyright Strike,NORMAL,,PURPLE,change_power,change_power,,,,,,,,givedice([for(i in 0...2) rand([1|2|3|4|5|6])]); var lockisalt = false; var dummyfighter = new elements.Fighter(~Wisp~); dummyfighter.addstatus(~lock~|1); trace(dummyfighter.status.length); if(dummyfighter.status.length > 0) { for(stat in dummyfighter.status) { if(stat.type == ~alternate_lock~) { lockisalt = true; } } }  if(lockisalt) {  for(mydice in [for(i in 0...2) self.dicepool[(self.dicepool.length - 1) - i]]) {   mydice.animate(~alternate_lock~);  }  inflictself(~alternate_lock~|2); } else {  for(mydice in [for(i in 0...2) self.dicepool[(self.dicepool.length - 1) - i]]) {   mydice.locked = true;  }  sfx(~_lock~); },,,,,,,,,,
Cyclone_upgraded,Do [sword]<d6> damage[;]|roll three locked dice,2,attack(d); sfxdamage(target|d); givedice([for(i in 0...3) rand([1|2|3|4|5|6])]); var lockisalt = false; var dummyfighter = new elements.Fighter(~Wisp~); dummyfighter.addstatus(~lock~|1); trace(dummyfighter.status.length); if(dummyfighter.status.length > 0) { for(stat in dummyfighter.status) { if(stat.type == ~alternate_lock~) { lockisalt = true; } } }  if(lockisalt) {  for(mydice in [for(i in 0...3) self.dicepool[(self.dicepool.length - 1) - i]]) {   mydice.animate(~alternate_lock~);  }  inflictself(~alternate_lock~|3); } else {  for(mydice in [for(i in 0...3) self.dicepool[(self.dicepool.length - 1) - i]]) {   mydice.locked = true;  }  sfx(~_lock~); },Copyright Strike,NORMAL,,PURPLE,,,,,,,,,,givedice([for(i in 0...3) rand([1|2|3|4|5|6])]); var lockisalt = false; var dummyfighter = new elements.Fighter(~Wisp~); dummyfighter.addstatus(~lock~|1); trace(dummyfighter.status.length); if(dummyfighter.status.length > 0) { for(stat in dummyfighter.status) { if(stat.type == ~alternate_lock~) { lockisalt = true; } } }  if(lockisalt) {  for(mydice in [for(i in 0...3) self.dicepool[(self.dicepool.length - 1) - i]]) {   mydice.animate(~alternate_lock~);  }  inflictself(~alternate_lock~|3); } else {  for(mydice in [for(i in 0...3) self.dicepool[(self.dicepool.length - 1) - i]]) {   mydice.locked = true;  }  sfx(~_lock~); },,,,,,,,,,
Cyclone_downgraded,Do [sword]<d6> damage[;]|roll a locked dice,2,attack(d); sfxdamage(target|d); givedice([for(i in 0...1) rand([1|2|3|4|5|6])]); var lockisalt = false; var dummyfighter = new elements.Fighter(~Wisp~); dummyfighter.addstatus(~lock~|1); trace(dummyfighter.status.length); if(dummyfighter.status.length > 0) { for(stat in dummyfighter.status) { if(stat.type == ~alternate_lock~) { lockisalt = true; } } }  if(lockisalt) {  for(mydice in [for(i in 0...1) self.dicepool[(self.dicepool.length - 1) - i]]) {   mydice.animate(~alternate_lock~);  }  inflictself(~alternate_lock~|1); } else {  for(mydice in [for(i in 0...1) self.dicepool[(self.dicepool.length - 1) - i]]) {   mydice.locked = true;  }  sfx(~_lock~); } /*having the downgrade be a double-dose (smaller range and suppressed secondary effect) just felt natural in this case; for some reason?*/,Copyright Strike,MAX3,,PURPLE,,,,,,,,,,givedice([for(i in 0...1) rand([1|2|3|4|5|6])]); var lockisalt = false; var dummyfighter = new elements.Fighter(~Wisp~); dummyfighter.addstatus(~lock~|1); trace(dummyfighter.status.length); if(dummyfighter.status.length > 0) { for(stat in dummyfighter.status) { if(stat.type == ~alternate_lock~) { lockisalt = true; } } }  if(lockisalt) {  for(mydice in [for(i in 0...1) self.dicepool[(self.dicepool.length - 1) - i]]) {   mydice.animate(~alternate_lock~);  }  inflictself(~alternate_lock~|1); } else {  for(mydice in [for(i in 0...1) self.dicepool[(self.dicepool.length - 1) - i]]) {   mydice.locked = true;  }  sfx(~_lock~); },,,,,,,,,,
Wind Chimes,Unlock all your dice,1,removestatusself(LOCK|ALL); for(i in 1...7) removestatusself(~counter_~ + i); for(mydice in self.dicepool) { if(mydice.locked # mydice.priority) { mydice.locked = false; mydice.priority = false; mydice.canbedragged = true; mydice.animate(~flashshake~); } },Reset Button,EVEN,,PURPLE,change_power,change_power,,_lock,,YES,,,,,,,,,,,,,,
Wind Chimes_upgraded,Unlock all your dice,1,removestatusself(LOCK|ALL); for(i in 1...7) removestatusself(~counter_~ + i); for(mydice in self.dicepool) { if(mydice.locked # mydice.priority) { mydice.locked = false; mydice.priority = false; mydice.canbedragged = true; mydice.animate(~flashshake~); } },Reset Button,NORMAL,,PURPLE,,,,_lock,,YES,,,,,,,,,,,,,,
Wind Chimes_downgraded,Unlock half your dice,1,removestatusself(LOCK|ALL); for(i in 1...7) removestatusself(~counter_~ + i); var dicelist = []; for(mydice in self.dicepool) { if(mydice.locked # mydice.priority) { dicelist.push(mydice); } } shuffle(mydice); var halflength = dicelist.length / 2; halflength += (1 - (dicelist.length % 1)); for(i in 0...halflength) { var mydice = dicelist[i]; mydice.locked = false; mydice.priority = false; mydice.canbedragged = true; mydice.animate(~flashshake~); },Reset Button,EVEN,,PURPLE,,,,_lock,,YES,,,,,,,,,,,,,,
Ivy,Gain [thorns]1 thorn|Return the dice,1,inflictself(THORNS); givedice(d);,Needle,EVEN,,GREEN,change_power,complicate,,_thorns,,YES,,,,,,,,,,,,,,
Ivy_upgraded,Gain [thorns]1 thorn|Bump the dice,1,inflictself(THORNS); if(d >= 6){ givedice([6| 1]); } else { givedice(d + 1); },Needle,EVEN,,GREEN,,,,_thorns,,YES,,,,,,,,,,,,,,
Speak Softly,Heal [heal]2 per thorn,2,attackself(-getstatusself(THORNS) * 2); if(getstatusself(THORNS) > 0) { sfx(~_heal~); sfx(~_thorns~|~~|0.1); } else { sfx(~_thorns~); },Deep Breath,ODD,,GREEN,change_power,change_power,thorns,,,YES,,,,,,,,,,,,,,
Speak Softly_downgraded,Heal [heal]1 per thorn,2,attackself(-getstatusself(THORNS)); if(getstatusself(THORNS) > 0) { sfx(~_heal~); sfx(~_thorns~|~~|0.1); } else { sfx(~_thorns~); },Deep Breath,ODD,,GREEN,,,,,,YES,,,,,,,,,,,,,,
Speak Softly_upgraded,Heal [heal]2 per thorn|Return the dice,2,attackself(-getstatusself(THORNS) * 2); givedice(d); if(getstatusself(THORNS) > 0) { sfx(~_heal~); sfx(~_thorns~|~~|0.1); } else { sfx(~_thorns~); },Deep Breath,ODD,,GREEN,,,,,,YES,,,,,,,,,,,,,,
Dark Hedges,Gain [thorns]5 thorns|[gray](once per battle),2,inflictself(THORNS| 5); /*battle cry used to be this back in closed beta when thorns? was identical to weaken? but made you do extra damage instead of making the enemy take extra damage*/,Briar Bush,REQUIRE5,,GREEN,reducesize,change_power,,_thorns,0,YES,YES,,,,,,,,,,,,,
Dark Hedges_downgraded,Gain [thorns]3 thorns|[gray](once per battle),2,inflictself(THORNS| 3);,Briar Bush,REQUIRE3,,GREEN,,,,_thorns,0,YES,YES,,,,,,,,,,,,,
Dark Hedges_weakened,Gain [thorns]3 thorns|[gray](once per battle),1,inflictself(THORNS| 3);,Briar Bush,REQUIRE3,,GREEN,,,,_thorns,0,YES,YES,,,,,,,,,,,,,
Dark Hedges_deckupgrade,Gain [thorns]5 thorns|[gray](once per battle),2,inflictself(THORNS| 5);,Briar Bush,MIN5,,GREEN,,,,_thorns,0,YES,YES,,,,,,,,,,,,,
Turbine,Do [sword]1 per locked dice|you have[;] return the dice,1,var lockcount = 0; for(mydice in self.dicepool) { if(mydice.availableorlocked() && mydice.locked) { lockcount++; } } attack(lockcount); sfxdamage(target|lockcount); sfx(~_lock~|~~|0.2); givedice(d);,Confiscate,EVEN,,PURPLE,simplify,change_power,,,,,,,,givedice(d);,,,,,,,,,,
Turbine_downgraded,Do [sword]1 per locked dice|you have[;] lock this dice,1,var lockcount = 0; for(mydice in self.dicepool) { if(mydice.availableorlocked() && mydice.locked) { lockcount++; } } attack(lockcount); sfxdamage(target|lockcount); sfx(~_lock~|~~|0.2); givedice(d); var lockisalt = false; var dummyfighter = new elements.Fighter(~Wisp~); dummyfighter.addstatus(~lock~|1); trace(dummyfighter.status.length); if(dummyfighter.status.length > 0) { for(stat in dummyfighter.status) { if(stat.type == ~alternate_lock~) { lockisalt = true; } } }  if(lockisalt) {  for(mydice in [for(i in 0...1) self.dicepool[(self.dicepool.length - 1) - i]]) {   mydice.animate(~alternate_lock~);  }  inflictself(~alternate_lock~|1); } else {  for(mydice in [for(i in 0...1) self.dicepool[(self.dicepool.length - 1) - i]]) {   mydice.locked = true;  }  sfx(~_lock~); },Confiscate,EVEN,,PURPLE,,,,,,,,,,givedice(d); var lockisalt = false; var dummyfighter = new elements.Fighter(~Wisp~); dummyfighter.addstatus(~lock~|1); trace(dummyfighter.status.length); if(dummyfighter.status.length > 0) { for(stat in dummyfighter.status) { if(stat.type == ~alternate_lock~) { lockisalt = true; } } }  if(lockisalt) {  for(mydice in [for(i in 0...1) self.dicepool[(self.dicepool.length - 1) - i]]) {   mydice.animate(~alternate_lock~);  }  inflictself(~alternate_lock~|1); } else {  for(mydice in [for(i in 0...1) self.dicepool[(self.dicepool.length - 1) - i]]) {   mydice.locked = true;  }  sfx(~_lock~); },,,,,,,,,,
Mirror on a Stick,Do [sword]<d6> damage. On 6[;] in|two turns[;] +1 [dice] this fight,2,attack(d); sfxdamage(target|d); if(d == 6) { jinx(~Mirror on a Stick~|~gain an extra dice this fight~|~Gain an extra dice this fight~|~target.extradice++; sfx(\~magic_gaindice\~);~|self|self|2|d);  sfx(~_thinghappens~); } /*in a very early alpha i wasn't present for (before the game even had real graphics) counterfeit was called 'mirror on a stick'*/,Plexiglass,NORMAL,,PURPLE,reducesize,change_power,,,,,,,,if(d == 6) { jinx(~Mirror on a Stick~|~gain an extra dice this fight~|~Gain an extra dice this fight~|~self.extradice++; sfx(\~magic_gaindice\~);~|self|self|2|d);  sfx(~_thinghappens~); },,,,,,,,,,
Mirror on a Stick_downgraded,Do [sword]<d6> damage. On 6[;] in|two turns[;] +1 [dice] that turn,2,attack(d); sfxdamage(target|d); if(d == 6) { jinx(~Mirror on a Stick-~|~gain an extra dice this turn~|~Gain an extra dice this turn~|~inflict(\~stash\~ + rand([1|2|3|4|5|6])); sfx(\~magic\~);~|self|self|2|d);  sfx(~_thinghappens~); },Plexiglass,NORMAL,,PURPLE,,,,,,,,,,if(d == 6) { jinx(~Mirror on a Stick-~|~gain an extra dice this turn~|~Gain an extra dice this turn~|~inflict(\~stash\~ + rand([1|2|3|4|5|6])); sfx(\~magic\~);~|self|self|2|d);  sfx(~_thinghappens~); },,,,,,,,,,
Mirror on a Stick_weakened,Do [sword]<d6> damage. On 6[;] in|two turns[;] +1 [dice] that turn,1,attack(d); sfxdamage(target|d); if(d == 6) { jinx(~Mirror on a Stick-~|~gain an extra dice this turn~|~Gain an extra dice this turn~|~inflict(\~stash\~ + rand([1|2|3|4|5|6])); sfx(\~magic\~);~|self|self|2|d);  sfx(~_thinghappens~); },Plexiglass,NORMAL,,PURPLE,,,,,,,,,,if(d == 6) { jinx(~Mirror on a Stick-~|~gain an extra dice this turn~|~Gain an extra dice this turn~|~inflict(\~stash\~ + rand([1|2|3|4|5|6])); sfx(\~magic\~);~|self|self|2|d);  sfx(~_thinghappens~); },,,,,,,,,,
Mirror on a Stick_deckupgrade,Do [sword]<d6> damage. On 6[;]|[]+1 dice this fight,2,attack(d); sfxdamage(target|d); if(d == 6) { self.extradice++; sfx(~magic_gaindice~|~~|0.1); },Plexiglass,NORMAL,,PURPLE,,,,,,,,,,if(d == 6) { self.extradice++; sfx(~magic_gaindice~|~~|0.1); },,,,,,,,,,
Smoke Signal,Stash dice for next|turn[;] then return it,1,inflictself(~stash~+d|1); inflictself(~illuminate~); givedice(d);,Light Switch,MIN4,,RED,simplify,complicate,,magic,0,YES,,,,,,,,,,,,,,
new elements.Equipment(null);,Error an enemy equipment,2,inflict(~ncr_error~);,Broken Gadget,EVEN,,GRAY,,,,roboterror,,,,,,,,,,,,,,,,
Ancestral Staff,Deal 8 fire damage|Burn Enemy|[gray](dice might cost 2 health),2,attack(8|FIRE); sfxdamage(target|8); sfx(~_fire~|~~|0.2); inflict(FIRE); /*the 7drl version of staff actually didn't inflict burn; burn didn't exist until a while into the versions with actual (dev art) graphics*/,Blowtorch,NORMAL|NORMAL,8,RED,change_power,changetotal10,,,,,,,,,,,,,,,,,,
Ancestral Staff_upgraded,Deal 8 fire damage|Burn Enemy twice|[gray](dice might cost 2 health),2,attack(8|FIRE); sfxdamage(target|8); sfx(~_fire~|~~|0.2); inflict(FIRE|2);,Blowtorch,NORMAL|NORMAL,8,RED,,,,,,,,,,,,,,,,,,,,
Ancestral Gemstaff,Deal 8 ice damage|Freeze Enemy|[gray](dice might be unusable),2,attack(8|ICE); sfxdamage(target|8); sfx(~_ice~|~~|0.2); inflict(ICE);,Flash Freeze,NORMAL|NORMAL,8,BRIGHTCYAN,change_power,changetotal10,,,,,,excludefromrandomlists,,,,,,,,,,,,
Ancestral Gemstaff_upgraded,Deal 8 ice damage|Freeze Enemy twice|[gray](dice might be unusable),2,attack(8|ICE); sfxdamage(target|8); sfx(~_ice~|~~|0.2); inflict(ICE|2);,Flash Freeze,NORMAL|NORMAL,8,BRIGHTCYAN,,,,,,,,excludefromrandomlists,,,,,,,,,,,,
Ancestral Sceptre,Deal 8 vanish damage|Vanish Enemy[gray](todo: try wisp redesign),2,attack(8|VANISH); sfxdamage(target|8); sfx(~_vanish~|~~|0.2); inflict(~ncr_vanish~); /*vanish (& wisp's equipment loadout) was a literal last-day addition*/,Hadoken,NORMAL|NORMAL,8,PINK,change_power,changetotal10,,,,,,excludefromrandomlists,,,,,,,,,,,,
Ancestral Sceptre_upgraded,Deal 8 vanish damage|Vanish Enemy twice[gray](todo: unique wisp status?),2,attack(8|VANISH); sfxdamage(target|8); sfx(~_vanish~|~~|0.2); inflict(~ncr_vanish~|2);,Hadoken,NORMAL|NORMAL,8,PINK,,,,,,,,excludefromrandomlists,,,,,,,,,,,,
Alchemist[],Brewery|Random effect|(never harms you),2,var effects = [~damage~|~heal~|~poison~|~fire~|~ice~|~ncr_vanish~]; var selectableeffects = effects.copy(); selectableeffects.remove(~heal~); var adjectives = [~Spiky~|~Healthy~|~Toxic~|~Fire~|~Ice~|~Milky~]; var effect = rand(selectableeffects); if(e.castdirection == -1) effect = ~heal~; var adjective = adjectives[effects.indexOf(effect)]; self.textparticle(adjective + ~ Brew!~); if(effect == ~damage~) { sfxdamage(target|2); attack(2); } if(effect == ~heal~) { sfx(~_heal~); attackself(-2); } if(effect != ~damage~ && effect != ~heal~) { sfx(~_~ + effect); if(effect == ~poison~) { inflict(effect|2); } else { inflict(effect); } },Stardust,,,GRAY,,change_function,,,,,,powercard,,,,,,,,,if(chance(100/6)) e.castdirection = -1; else e.castdirection = 1;,,,
Alchemist[]_downgraded,Potion of Water|No effect,2,self.textparticle(~No effect!~);,Stardust,,,GRAY,,,,,,,,powercard,,,,,,,,,,,,
Alchemist?,[80%]Negative Suggestion|Inflict [weaken]1 weaken,2,inflict(WEAKEN); sfx(~_weaken~); /*'negative' because it makes cards switch to their - version; 'suggestion' because weaken's modern form was first suggested by yinyin*/,Burrower,,,GRAY,,change_function,,,,,,alternateversion|powercard,,,,,,,,,,,,
Alchemist?_downgraded,Rumble|Mix up slots on|enemy cards,2,inflict(~ncr_jumble~); sfx(~_weaken~); /*another form of weaken suggested by yinyin*/,Burrower,,,GRAY,,,,,,,,alternateversion|powercard,,,,,,,,,,,,
Cactus?,Lead Balloon|Roll 3 new dice[;] but|they're filled with lead,2,/*funny enough i actually looked at mysticsword's 'helium shooter' for reference since i wanted the dice to accelerate when falling - helium balloon itself just continuously kicks dice upward*/  if(!self.isplayer) { bonus(-99999999); self.textparticle(~No effect!~); }  if(self.isplayer) {  var gravityindices = self.getvar(~gravityindices~);  var gravityspeedindices = self.getvar(~gravityspeedindices~);  givedice([rand([1|2|3|4|5|6])|rand([1|2|3|4|5|6])|rand([1|2|3|4|5|6])]);  gravityindices.push(self.dicepool.length - 1);  gravityindices.push(self.dicepool.length - 2);  gravityindices.push(self.dicepool.length - 3);  self.setvar(~gravityindices~|gravityindices);  for(i in 0...gravityindices.length) {   gravityspeedindices.push(0);  }  self.setvar(~gravityspeedindices~|gravityspeedindices); }  var skipsetup = false;  if(self.getvar(~leadactuator~) + 1 == ~SimpleActuator1~ # !self.isplayer) skipsetup = true; trace(skipsetup); if(skipsetup) trace(~skipping setup~); if(!skipsetup) {  trace(~starting lead actuator~);  var tw = new motion.actuators.SimpleActuator(null|0|null);  tw._repeat = -1;  var s = new elements.Skill(~Against all odds_old~);  s.script = ~   var gravityindices = self.getvar(\~gravityindices\~);   var gravityspeedindices = self.getvar(\~gravityspeedindices\~);   var changesmade = false;   var diceavailable = false;   if(self.doendturnnow # self.hp <= 0 # self.graphic == null # target == null # target.graphic == null # target.hp <= 0) {    trace(\~lead actuator stopped\~);    self.getvar(\~leadactuator\~).stop();    self.resetvar(\~leadactuator\~);    self.setvar(\~gravityindices\~|[]);    self.setvar(\~gravityspeedindices\~|[]);    diceavailable = true; /*kludge so the second 'can we leave yet?' check is bypassed*/   }   else {    if(gravityindices.length == 0) {     trace(\~gravityindices is empty! stopping\~);     self.getvar(\~leadactuator\~).stop();     self.resetvar(\~leadactuator\~);     self.setvar(\~gravityindices\~|[]);     self.setvar(\~gravityspeedindices\~|[]);    }    else {     for(indice in gravityindices) { /*my x key is being uncooperative*/      var mydice = self.dicepool[indice];      if(mydice == null) {       trace(\~a dice referred to by gravityindices is null. stopping\~);       self.getvar(\~leadactuator\~).stop();       self.resetvar(\~leadactuator\~);       self.setvar(\~gravityindices\~|[]);       self.setvar(\~gravityspeedindices\~|[]);       break;      }      if(!mydice.intween() && !mydice.grabbed && !mydice.consumed && mydice.assigned == null) {       if(mydice.y > 4000) { /*guessing this is roughly below the bottom of the screen. no way to get screen height currently*/        mydice.consumed = true;        }       mydice.y = mydice.y + gravityspeedindices[gravityindices.indexOf(indice)];       gravityspeedindices[gravityindices.indexOf(indice)] += 0.275;       changesmade = true;      }      if(mydice.intween() # mydice.grabbed # mydice.consumed # mydice.assigned != null) {       gravityspeedindices[gravityindices.indexOf(indice)] = 0;       changesmade = true;      }      if(!diceavailable && !mydice.consumed) {       if(mydice.assigned == null # mydice.assigned.ready) {        diceavailable = true;       }      }     }    }   }   if(changesmade) {    self.setvar(\~gravityindices\~|gravityindices);    self.setvar(\~gravityspeedindices\~|gravityspeedindices);   }   if(!diceavailable) {    trace(\~all lead dice gone! stopping\~);    self.getvar(\~leadactuator\~).stop();    self.resetvar(\~leadactuator\~);    self.setvar(\~gravityindices\~|[]);    self.setvar(\~gravityspeedindices\~|[]);   }  ~;  tw.onRepeat(s.execute|[self|target]);  self.setvar(~leadactuator~|tw);  s.execute(self|target);  tw.move(); },Less Fluff,,,GREEN,,change_function,,,,YES,,alternateversion|powercard,,,,,self.setvar(~gravityindices~|[]); self.setvar(~gravityspeedindices~|[]);,,,,,,,
Cactus?_downgraded,Torture Machine|Split all dice below 2,2,var dicelist = []; for (mydice in self.dicepool){ if (mydice.available() && mydice.basevalue < 2){ dicelist.push(mydice); } } if(dicelist.length > 0) { sfx(~splitdice~); for(mydice in dicelist) { mydice.removedice(self.screenposition()); givedice(split(mydice.basevalue)); } },Less Fluff,,,GREEN,,,,,,YES,,alternateversion|powercard,,,,,,,,,,,,
beep,beep|,1,attack(2); sfxdamage(target|2);,,COUNTDOWN,5,,,,,,-1,,,testitem|excludefromrandomlists,,,,,,,,,,,,
revolver 2,the sequel|,1,self.setvar(~ereference~|e); var tw = new motion.actuators.SimpleActuator(null|0.01|null); var s = new elements.Skill(~Against all odds_old~); s.script = ~var e = self.getvar(\~ereference\~); if(e.dicehistory.length == 0) { e.dicehistory = self.getvar(\~diceshit\~); } var sum = 0; trace(e.dicehistory); for(dice in e.dicehistory) { sum += dice.basevalue; if(sum > e.countdown) break; } if(sum - e.countdown > 0) { attack((sum - e.countdown) * 2); sfxdamage(target|(sum - e.countdown) * 2); } else { self.textparticle(\~No effect!\~); } self.resetvar(\~ereference\~);~; tw.onComplete(s.execute|[self|target]); tw.move();,Oh Shit!,COUNTDOWN,9,,,,,,-1,,,testitem|excludefromrandomlists,,,,,,,,,,,,
Pepper Spray,Enemy flees immediately|No EXP is gained from this,1,if(target.template.boss) { self.textparticle(~No effect!~); } else { var s = new elements.Skill(~Against all odds_old~); s.script = ~flee();~; s.execute(target|self); sfx(~_fire~|~~|0.1); screenshake(); },Blowtorch,COUNTDOWN,24,RED,change_power,change_power,,,,,,,1,,,,,,,,,,,
Pepper Spray_upgraded,Enemy flees immediately|No EXP is gained from this,1,if(target.template.boss) { self.textparticle(~No effect!~); } else { var s = new elements.Skill(~Against all odds_old~); s.script = ~flee();~; s.execute(target|self); sfx(~_fire~|~~|0.1); screenshake(); },Blowtorch,COUNTDOWN,18,RED,,,,,,,,,,,,,,,,,,,,
Pepper Spray_downgraded,Lose [heart]5 hp[;] enemy flees|No EXP is gained from this,1,if(target.template.boss) { self.textparticle(~No effect!~); } else { pierceattackself(5); sfx(~_drain~); var s = new elements.Skill(~Against all odds_old~); s.script = ~flee();~; s.execute(target|self); sfx(~_fire~|~~|0.1); screenshake(); },Blowtorch,COUNTDOWN,24,RED,,,,,,,,,,,,,,,,,,,,
Pepper Spray_weakened,Lose [heart]5 hp[;] enemy flees|No EXP is gained from this,1,if(target.template.boss) { self.textparticle(~No effect!~); } else { pierceattackself(5); sfx(~_drain~); var s = new elements.Skill(~Against all odds_old~); s.script = ~flee();~; s.execute(target|self); sfx(~_fire~|~~|0.1); screenshake(); },Blowtorch,COUNTDOWN,18,RED,,,,,,,,,,,,,,,,,,,,
Oobleck Cauldron,Do [sword]1[;] get a non-6 dice|(Scraps to current gadget),1,attack(1); sfxdamage(target|1); givedice(rand([1|2|3|4|5]));,Broken Gadget,NORMAL,,PINK,change_power,change_power,,,,,,preservesgadget,,,,,,,,,,,,
Oobleck Cauldron_upgraded,Do [sword]2[;] get 2 non-6 dice|(Scraps to current gadget),1,attack(2); sfxdamage(target|2); givedice([rand([1|2|3|4|5])|rand([1|2|3|4|5])]);,Broken Gadget,NORMAL|NORMAL,,PINK,,,,,,,,preservesgadget,,,,,,,,,,,,
Oobleck Cauldron_downgraded,Do [sword]1[;] get a non-6 dice|(Scraps to current gadget),1,attack(1); sfxdamage(target|1); givedice(rand([1|2|3|4|5]));,Broken Gadget,MIN4,,PINK,,,,,,,,preservesgadget,,,,,,,,,,,,
Oobleck Mirror,[]+<timesused> dice next turn[;] +1 per use|(Scraps to current gadget),1,self.bonusdice += e.timesused + 1; self.bonusdicenextturn += e.timesused + 1; sfx(~magic_gaindice~);,Broken Gadget,REQUIRE6,,PINK,simplify,doublerequirements,,,,,,preservesgadget,,,,,,,,,,,,
Oobleck Hammer,Do [sword]<d6> damage[;]|on even[;] inflict [shock]1 instead|(Scraps to current gadget),2,if(d % 2 == 0) { inflict(SHOCK); sfx(~_shock~); } else { attack(d); sfxdamage(target|d); },Broken Gadget,NORMAL,,PINK,reducesize,change_power,,,,,,preservesgadget,,,,,,,,,,,,
Oobleck Hammer_downgraded,Do [sword]<d6> damage|(Scraps to current gadget),2,attack(d); sfxdamage(target|d);,Broken Gadget,ODD,,PINK,,,,,,,,preservesgadget,,,,,,,,,,,,
Oobleck Hammer_weakened,Do [sword]<d6> damage|(Scraps to current gadget),1,attack(d); sfxdamage(target|d);,Broken Gadget,ODD,,PINK,,,,,,,,preservesgadget,,,,,,,,,,,,
Oobleck Hammer_deckupgrade,Do [sword]<d6> damage[;]|on even[;] inflict [shock]2 instead|(Scraps to current gadget),2,if(d % 2 == 0) { inflict(SHOCK|2); sfx(~_shock~); } else { attack(d); sfxdamage(target|d); },Broken Gadget,NORMAL,,PINK,,,,,,,,preservesgadget,,,,,,,,,,,,
Oobleck Shovel,Do [sword]<d6> damage[;]|on even[;] inflict [weaken]1 instead|(Scraps to current gadget),2,if(d % 2 == 0) { inflict(WEAKEN); sfx(~_weaken~); } else { attack(d); sfxdamage(target|d); },Broken Gadget,NORMAL,,PINK,reducesize,change_power,,,,,,preservesgadget,,,,,,,,,,,,
Oobleck Shovel_downgraded,Do [sword]<d6> damage|(Scraps to current gadget),2,attack(d); sfxdamage(target|d);,Broken Gadget,ODD,,PINK,,,,,,,,preservesgadget,,,,,,,,,,,,
Oobleck Shovel_weakened,Do [sword]<d6> damage|(Scraps to current gadget),1,attack(d); sfxdamage(target|d);,Broken Gadget,ODD,,PINK,,,,,,,,preservesgadget,,,,,,,,,,,,
Oobleck Shovel_deckupgrade,Do [sword]<d6> damage[;]|on even[;] inflict [weaken]2 instead|(Scraps to current gadget),2,if(d % 2 == 0) { inflict(WEAKEN|2); sfx(~_weaken~); } else { attack(d); sfxdamage(target|d); },Broken Gadget,NORMAL,,PINK,,,,,,,,preservesgadget,,,,,,,,,,,,
Haunted Jar[],Haunted Tray|If you are out of dice[;]|inflict [poison]3 poison,2,var diceavailable = false; for(dice in self.dicepool) { if(dice.available()) { diceavailable = true; break; } } for(eq in self.equipment) { if(eq.isready() && eq.assigneddice.length > 0) { for(dice in eq.assigneddice) { if(dice != null && dice.available()) { diceavailable = true; break; } } } } if(!diceavailable) { inflict(POISON|3); sfx(~_poison~); } else { self.textparticle(~No effect!~); },Anthrax,,,PURPLE,,change_function,,,,,,powercard,,,,,,,,,,,,
Haunted Jar?,True Purple|Get a random purple card,2,if(self.layout != ~DECK~ && !simulation) { for(eq in self.equipment) { eq.setvar(~alreadyheretemp~|1); } } if(self.layout != ~DECK~ && !simulation) { var descriptionblacklist = loadtext(~ncrmod/itemspawnerdescblacklist~); var scriptblacklist = [~self.equipment~|~new elements.Equipment~|~self.getvar(\~fixedeqlist\~).indexOf(e)~]; var checkblacklist = function(text|list) {  for(phrase in list) {   if(text.indexOf(phrase) != -1) {    return(false);   }  }  return(true); }; var purpleeq = ~~; var exceptions = [~skillcard~|~excludefromrandomlists~|~alternateversion~|~robotonly~|~witchonly~|~inventoronly~|~onceperbattle~]; if(self.usecpuinsteadofdice) exceptions.remove(~robotonly~); if(self.getskillcard() != null && self.getskillcard().skillcard == ~witch~) exceptions.remove(~witchonly~); if(self.getskillcard() != null && self.getskillcard().skillcard == ~inventor~) exceptions.remove(~inventoronly~); var geteqs = getequipmentlist(null|[]|exceptions); geteqs = shuffle(geteqs); var placeholder = new elements.Equipment(~Seize~); var count = 0; while(purpleeq == ~~) {  placeholder.create(geteqs[count]);  trace(placeholder.fulldescription); trace(placeholder.getslots());  var ds = placeholder.fulldescription;  var sc = placeholder.script;  var scbx = placeholder.scriptbeforeexecute;  if(   placeholder.equipmentcol == 5 &&   !(placeholder.hastag(~powercard~)) &&   checkblacklist(ds|descriptionblacklist) &&   checkblacklist(sc|scriptblacklist) &&   checkblacklist(scbx|scriptblacklist)  ) {   purpleeq = placeholder.name;  } /*else { geteqs.remove(placeholder.name); }*/ count++; trace(count); if(count >= geteqs.length) { placeholder.create(~Seize~); purpleeq = ~Seize~; break; } } if( self.layout == ~DECK~) { replacemewith(purpleeq|-1); } else { giveequipment(purpleeq); } for(eq in self.equipment) { if(eq.getvar(~alreadyheretemp~) != 1) { self.setvar(~doonthis~|eq); } } var estandardize = ~var e = self.getvar(\~doonthis\~); ~;var doscripts = new elements.Skill(~Against all odds_old~); doscripts.script = estandardize + placeholder.scriptbeforecombat; doscripts.execute(self|target); doscripts.script = estandardize + placeholder.scriptbeforestartturn; doscripts.execute(self|target); doscripts.script = estandardize + placeholder.scriptonstartturn; doscripts.execute(self|target); self.resetvar(~doonthis~); placeholder.name = ~deletemetemp~; self.equipment.push(placeholder); removeequipment(~deletemetemp~); for(eq in self.equipment) { eq.resetvar(~alreadyheretemp~); } } //$trace(~yo~); trace(Deck.getcardlist(~all~)); if((self.layout == ~DECK~) && !simulation) { for(eq in self.equipment) { eq.setvar(~alreadyheretemp~|1); } } if((self.layout == ~DECK~) && !simulation) { var descriptionblacklist = loadtext(~ncrmod/itemspawnerdescblacklist~); var scriptblacklist = [~self.equipment~|~new elements.Equipment~|~self.getvar(\~fixedeqlist\~).indexOf(e)~]; var checkblacklist = function(text|list) {  for(phrase in list) {   if(text.indexOf(phrase) != -1) {    return(false);   }  }  return(true); }; var purpleeq = ~~; var exceptions = [~skillcard~|~excludefromrandomlists~|~alternateversion~|~robotonly~|~witchonly~|~inventoronly~|~onceperbattle~]; if(self.usecpuinsteadofdice) exceptions.remove(~robotonly~); if(self.getskillcard() != null && self.getskillcard().skillcard == ~witch~) exceptions.remove(~witchonly~); if(self.getskillcard() != null && self.getskillcard().skillcard == ~inventor~) exceptions.remove(~inventoronly~); var geteqs = getequipmentlist(null|[]|exceptions); geteqs = shuffle(geteqs); var placeholder = new elements.Equipment(~Seize~); var count = 0; while(purpleeq == ~~) {  placeholder.create(geteqs[count]);  trace(placeholder.fulldescription); trace(placeholder.getslots());  var ds = placeholder.fulldescription;  var sc = placeholder.script;  var scbx = placeholder.scriptbeforeexecute;  if(   placeholder.equipmentcol == 5 &&   !(placeholder.hastag(~powercard~)) &&   checkblacklist(ds|descriptionblacklist) &&   checkblacklist(sc|scriptblacklist) &&   checkblacklist(scbx|scriptblacklist)  ) {   purpleeq = placeholder.name;  } count++; trace(count); if(count >= geteqs.length) { placeholder.create(~Seize~); purpleeq = ~Seize~; break; } } if(self.layout == ~DECK~) { trace(~doing jester replace~); replacemewith(purpleeq|-1); } else { trace(~doing... other replace~); giveequipment(purpleeq); } for(eq in self.equipment) { if(eq.getvar(~alreadyheretemp~) != 1) { self.setvar(~doonthis~|eq); } } var estandardize = ~var e = self.getvar(\~doonthis\~); ~;var doscripts = new elements.Skill(~Against all odds_old~); doscripts.script = estandardize + placeholder.scriptbeforecombat; doscripts.execute(self|target); doscripts.script = estandardize + placeholder.scriptbeforestartturn; doscripts.execute(self|target); doscripts.script = estandardize + placeholder.scriptonstartturn; doscripts.execute(self|target); self.resetvar(~doonthis~); placeholder.name = ~deletemetemp~; self.equipment.push(placeholder); removeequipment(~deletemetemp~); for(eq in self.equipment) { eq.resetvar(~alreadyheretemp~); } }$,Plasma Gun,,,PURPLE,,change_function,,,,YES,,alternateversion|powercard|cannotreuse,,,,,,,,,,,e.preventdefault = true; e.maintainfury = true;,
Haunted Jar[]_downgraded,Cough|Inflict [poison]1 poison,2,inflict(POISON); sfx(~_poison~);,Anthrax,,,PURPLE,,,,,,,,powercard,,,,,,,,,,,,
Haunted Jar?_downgraded,Architecture Simulator|Get a Plasma Cannon,2,if( self.layout == ~DECK~) { replacemewith(~Plasma Cannon~|-1); } else { giveequipment(~Plasma Cannon~); },Plasma Gun,,,PURPLE,,,,,,YES,,alternateversion|powercard|cannotreuse,,,,,,,,,,,e.preventdefault = true; e.maintainfury = true;,
Robobot[],Electrocute|Do [shock]4 damage[;] but|[shock]shock your other 2 cards,2,attack(SHOCK|4); //$inflictself(SHOCK|2); var hasshockavoid = e.hastag(~shockavoid~); e.addtag(~shockavoid~); self.applyequipmentcurses(); if(!hasshockavoid) e.removetag(~shockavoid~);$,Static Shock,,,YELLOW,,change_function,,_shock,,,,powercard,,,,,,,,,,,e.preventdefault = true; e.maintainfury = true;,
Robobot[]_downgraded,Broken Charger|Inflict [shock]1 shock[;] but|[shock]shock your other 2 cards,2,inflict(SHOCK); //$inflictself(SHOCK|2); var hasshockavoid = e.hastag(~shockavoid~); e.addtag(~shockavoid~); self.applyequipmentcurses(); if(!hasshockavoid) e.removetag(~shockavoid~);$,Static Shock,,,YELLOW,,,,_shock,,,,powercard,,,,,,,,,,,e.preventdefault = true; e.maintainfury = true;,
Robobot?,Short Temper|For the next 5 seconds[;] deal|and take +[sword]2 for all attacks,2,if(!self.isplayer) { bonus(-99999999); self.textparticle(~No effect!~); }  var skipsetup = false;  if(self.getvar(~poweractuator~) + 1 == ~SimpleActuator1~ # !self.isplayer) skipsetup = true; trace(skipsetup); if(skipsetup && self.isplayer) { trace(~skipping setup~); self.setvar(~ncrpowertime~|self.getvar(~ncrpowertime~) + 5.0); } if(!skipsetup) {  trace(~starting power actuator~);  var Rules = self.getvar(~ncr_get_Rules~);  self.setvar(~ncrpowertime~|5.0);  if(Rules.bonusdamage == null) Rules.bonusdamage = 0;  self.setvar(~oldbonusdamage~|Rules.bonusdamage);  Rules.bonusdamage += 2;  inflictself(~extradamage~|2);  inflict(~extradamage~|2);  var tw = new motion.actuators.SimpleActuator(null|0.1|null);  tw._repeat = -1;  var s = new elements.Skill(~Against all odds_old~);  s.script = ~   var Rules = self.getvar(\~ncr_get_Rules\~);   if(self.getvar(\~ncrpowertime\~) <= 0.01 # self.doendturnnow # self.hp <= 0 # self.graphic == null # target == null # target.graphic == null # target.hp <= 0) {    trace(\~power actuator stopping\~);    Rules.bonusdamage = self.getvar(\~oldbonusdamage\~);    removestatusself(\~extradamage\~|2);    if(target.status != null) removestatus(\~extradamage\~|2);    self.resetvar(\~oldbonusdamage\~);    self.getvar(\~poweractuator\~).stop();    self.resetvar(\~poweractuator\~);    self.resetvar(\~ncr_get_Rules\~);    new elements.CombatCommand(\~msg\~|\~\~).execute();    sfx(\~_weaken\~);   }   else {    var time = self.getvar(\~ncrpowertime\~);    var timestring = time + \~\~;    timestring = timestring.split(\~0000\~)[0];    if(timestring.length < 2) timestring += \~.0\~;    new elements.CombatCommand(\~msg\~|\~[200%]\~ + timestring).execute();    time -= 0.1;    self.setvar(\~ncrpowertime\~|time);   }  ~;  tw.onRepeat(s.execute|[self|target]);  self.setvar(~poweractuator~|tw);  s.execute(self|target);  tw.move(); },Scabbard (1/2),,,YELLOW,,change_function,,upgradeequipment,,YES,,alternateversion|powercard|curseavoid,,,,,,,self.resetvar(~ncr_get_Rules~|Rules);,,self.setvar(~ncr_get_Rules~|Rules);,,e.preventdefault = true; e.maintainfury = true;,
Robobot?_downgraded,Mystic's Sword|Do [sword]2 damage,2,attack(2); sfxdamage(target|2);,Scabbard (1/2),,,YELLOW,,,,,,,,alternateversion|powercard,,,,,,,self.resetvar(~ncr_get_Rules~|Rules);,,self.setvar(~ncr_get_Rules~|Rules);,,,
Aoife[],Guard|Gain [shield]3 shield,2,inflictself(SHIELD|3);,Safeguard,,,PINK,,change_function,,_shield,,,,powercard,,,,,,,,,,,,
Aoife[]_downgraded,Sabre|Bash with shield,2,if(getstatusself(SHIELD) == 0) { attack(0); sfxdamage(target|0); sfx(~_shield~|~~|0.2); self.textparticle(~No effect!~); } else { attack(getstatusself(SHIELD)); sfxdamage(target|getstatusself(SHIELD)); sfx(~_shield~|~~|0.2); },Safeguard,,,PINK,,,,,,,,powercard,,,,,,,,,,,,
Aoife?,Compass Rose|Do [sword]dmg equal to length|of 1st word on 1st card,2,//$trace(~test~); trace(~test~ - 0); var dmgamt = 0; var firstcard = Deck.getcard(0); if(firstcard != null && firstcard.equipment != null && firstcard.equipment.fulldescription.length > 0) { var desc = firstcard.equipment.fulldescription; if(desc != null && desc.length > 0) { if(firstcard.equipment.hastag(~powercard~)) { desc = desc.split(~#~.substr(0|1)); if(desc.length > 1) desc = desc.splice(1|desc.length - 1); desc = desc.join(~#~.substr(0|1)); } desc = desc.split(~[~); for(i in 0...desc.length) { if(desc[i].split(~]~).length > 1) { desc[i] = desc[i].split(~]~)[1]; } } desc = desc.join(~~); desc = desc.split(~|~).join(~~).split(~.~).join(~~).split(~!~).join(~~).split(~?~).join(~~).split(~;~).join(~~).split(~-~).join(~ ~).split(~:~).join(~~).split(~\~~).join(~~).split(~ ~); if(desc[0] - 0 != 0 # desc[0] == ~0~) desc.shift(); trace(desc); dmgamt = desc[0].length; } } attack(dmgamt); sfxdamage(target|dmgamt);$,Vaporizer,,,PINK,,change_function,,,,,,alternateversion|powercard,,,,,,,,,,,,
Aoife?_downgraded,Pace Mace|Do [sword]2 damage,2,attack(2); sfxdamage(target|2);,Vaporizer,,,PINK,,,,,,,,alternateversion|powercard,,,,,,,,,,,,
Gardener[],Shovel Whack|If your dice sum to 15|or more[;] inflict [weaken]2,2,var dicesum = 0; if(self.dicepool.length > 0) for(dice in self.dicepool) { if(dice.available()) { dicesum += dice.basevalue; } } for(eq in self.equipment) { if(eq.isready() && eq.assigneddice.length > 0) { for(dice in eq.assigneddice) { if(dice != null && dice.available()) {dicesum += dice.basevalue; } } } } if(dicesum >= 15) { inflict(WEAKEN|2); sfx(~_weaken~); } else { self.textparticle(~No effect!~); },Stardust,,,BRIGHTCYAN,,change_function,,,,,,powercard,,,,,,,,,,,,
Gardener[]_downgraded,Gardening Accident|If sum of dice is odd[;] get [weaken]1|If sum of dice is even[;] get [shock]1,2,var dicesum = 0; if(self.dicepool.length > 0) for(dice in self.dicepool) { if(dice.available()) { dicesum += dice.basevalue; } } for(eq in self.equipment) { if(eq.isready() && eq.assigneddice.length > 0) { for(dice in eq.assigneddice) { if(dice != null && dice.available()) {dicesum += dice.basevalue; } } } } if(dicesum % 2 == 1) { inflictself(WEAKEN); sfx(~_weaken~); } else { inflictself(SHOCK); sfx(~_shock~); } self.applyequipmentcurses();,Stardust,,,BRIGHTCYAN,,,,,,YES,,powercard,,,,,,,,,,,,
Gardener?,Livestream|Inflict [shock]1 shock whenever|the enemy attacks you,2,inflict(~ncr_paralysis_all~); /*i actually dunno what hupfen does aside from her livestreaming :(*/,Discharge,,,BRIGHTCYAN,,change_function,,_shock,,,,alternateversion|powercard,,,,,,,,,,,,
Gardener?_downgraded,Quantum Circuit|Inflict a random status|(out of: [shock][;] [shock][;] [shock][;] [shock][]),2,inflict(SHOCK);,Discharge,,,BRIGHTCYAN,,,,_shock,,,,alternateversion|powercard,,,,,,,,,,,,
Broadchucks,[sword]<d6>[;] return difference,2,attack(d); var bigdice = 0; var smalldice = 7; for(ad in actualdice) { if(ad.basevalue > bigdice) bigdice = ad.basevalue; if(ad.basevalue < smalldice) smalldice = ad.basevalue; } if((bigdice - smalldice) >= 1) givedice([(bigdice - smalldice)]| ~combinedice~);,Magic Lockpick,MAX4|MAX4,,RED,increaserange,decreaserange,,,0,NO,NO,,,,,,,,,,,,,var bigdice = 0; var smalldice = 7; for(ad in actualdice) { if(ad.basevalue > bigdice) bigdice = ad.basevalue; if(ad.basevalue < smalldice) smalldice = ad.basevalue; } if((bigdice - smalldice) >= 1) givedice([(bigdice - smalldice)]| ~combinedice~);
Mystical Chip,Inflict [vanish]1 vanish|Counts as a chip,2,inflict(~ncr_vanish~|1); sfx(~_vanish~|~~|0.2); self.setvar(~icchips~|self.getvar(~icchips~) + 2); self.setvar(~actualicchips~|self.getvar(~actualicchips~) + 1);,Delude,MIN3,,PINK,change_power,change_function,,chip,,,,,,,,,,,,,,,,
Mystical Chip_upgraded,Inflict [vanish]2 vanish|Counts as a chip,2,inflict(~ncr_vanish~|2); sfx(~_vanish~|~~|0.2); self.setvar(~icchips~|self.getvar(~icchips~) + 2); self.setvar(~actualicchips~|self.getvar(~actualicchips~) + 1);,Delude,MIN3,,PINK,,,,chip,,,,,,,,,,,,,,,,
Mystical Chip_downgraded,Inflict [vanish]1 vanish,2,inflict(~ncr_vanish~|1); sfx(~_vanish~);,Delude,MIN3,,PINK,,,,,,,,,,,,,,,,,,,,
Brushfire,Inflict [fire]1 burn|Counts as a chip,2,inflict(FIRE|1); sfx(~_fire~|~~|0.2); self.setvar(~icchips~|self.getvar(~icchips~) + 2); self.setvar(~actualicchips~|self.getvar(~actualicchips~) + 1);,Ember,MIN3,,RED,change_power,change_function,,chip,,,,,,,,,,,,,,,,
Brushfire_upgraded,Inflict [fire]2 burn|Counts as a chip,2,inflict(FIRE|2); sfx(~_fire~|~~|0.2); self.setvar(~icchips~|self.getvar(~icchips~) + 2); self.setvar(~actualicchips~|self.getvar(~actualicchips~) + 1);,Ember,MIN3,,RED,,,,chip,,,,,,,,,,,,,,,,
Brushfire_downgraded,Inflict [fire]1 burn,2,inflict(FIRE|1); sfx(~_fire~);,Ember,MIN3,,RED,,,,,,,,,,,,,,,,,,,,
Icedeath,Inflict [ice]1 freeze|Counts as a chip,2,inflict(ICE|1); sfx(~_ice~|~~|0.2); self.setvar(~icchips~|self.getvar(~icchips~) + 2); self.setvar(~actualicchips~|self.getvar(~actualicchips~) + 1);,Refrigerator,MIN3,,BRIGHTCYAN,change_power,change_function,,chip,,,,,,,,,,,,,,,,
Icedeath_upgraded,Inflict [ice]2 freeze|Counts as a chip,2,inflict(ICE|2); sfx(~_ice~|~~|0.2); self.setvar(~icchips~|self.getvar(~icchips~) + 2); self.setvar(~actualicchips~|self.getvar(~actualicchips~) + 1);,Refrigerator,MIN3,,BRIGHTCYAN,,,,chip,,,,,,,,,,,,,,,,
Icedeath_downgraded,Inflict [ice]1 freeze,2,inflict(ICE|1); sfx(~_ice~);,Refrigerator,MIN3,,BRIGHTCYAN,,,,,,,,,,,,,,,,,,,,
Force Field,Discard current hand|Counts as a chip,2,self.setvar(~icchips~|self.getvar(~icchips~) + 2); self.setvar(~actualicchips~|self.getvar(~actualicchips~) + 1); Deck.discardhand(); sfx(~jester_discard~);,Jetpack,ODD,,GREEN,simplify,complicate,,chip,0,YES,NO,,,,,,,,,,,,e.preventdefault = true; e.maintainfury = true;,
Chchchips,Counts as 3 chips|[gray](once per battle),2,self.setvar(~icchips~|self.getvar(~icchips~) + 6);,Harvest,MIN5,,GRAY,increaserange,complicate,,chip,,YES,YES,,,,,,,,,,,,,
Chipmine,Chipmine|Get a random chip,2,//$replacemewith(rand(loadtext(~ncrmod/chipminespawnablechips~))| -1);$ /*originally the button text for this was going to be 'ggja' because that's the password to chipmine but that would be nonsensical to anyone who doesn't play chips*/,lolsorandom,,,GRAY,,,,,,YES,,powercard|weakenavoid,,,,,,,,,,,,
Southpole,Get a lower dice|Counts as a chip,2,givedice(rand([1|2|3|4|5|6].splice(0|d))); self.setvar(~icchips~|self.getvar(~icchips~) + 2); self.setvar(~actualicchips~|self.getvar(~actualicchips~) + 1);,Magic Lockpick,MIN2,,BRIGHTCYAN,change_power,change_power,,chip,,YES,,,,,,,,,,,,,,
Southpole_upgraded,Get a random dice|Counts as a chip,2,givedice(); self.setvar(~icchips~|self.getvar(~icchips~) + 2); self.setvar(~actualicchips~|self.getvar(~actualicchips~) + 1);,Magic Lockpick,MIN2,,BRIGHTCYAN,,,,chip,,YES,,,,,,,,,,,,,,
Southpole_downgraded,Get a lower dice|Counts as a chip,2,givedice(rand([1|2|3|4|5|6].splice(0|d))); self.setvar(~icchips~|self.getvar(~icchips~) + 2); self.setvar(~actualicchips~|self.getvar(~actualicchips~) + 1);,Magic Lockpick,MIN4,,BRIGHTCYAN,,,,chip,,YES,,,,,,,,,,,,,,
Cellblocked,Lock a dice|Counts as a chip,2,inflict(LOCK); sfx(~_lock~|~~|0.2); self.setvar(~icchips~|self.getvar(~icchips~) + 2); self.setvar(~actualicchips~|self.getvar(~actualicchips~) + 1);,Copyright Strike,MIN5,,PURPLE,increaserange,change_power,,chip,,,,,,self.setvar(~icchips~|self.getvar(~icchips~) + 2); self.setvar(~actualicchips~|self.getvar(~actualicchips~) + 1);,,,,,,,,,,
Cellblocked_downgraded,Counts as a chip,2,self.setvar(~icchips~|self.getvar(~icchips~) + 2); self.setvar(~actualicchips~|self.getvar(~actualicchips~) + 1);,Copyright Strike,MIN5,,PURPLE,,,,chip,,,,,,self.setvar(~icchips~|self.getvar(~icchips~) + 2); self.setvar(~actualicchips~|self.getvar(~actualicchips~) + 1);,,,,,,,,,,
CANYON.MID,Inflict [weaken]weaken|Counts as a chip,2,inflict(WEAKEN); sfx(~_weaken~|~~|0.2); self.setvar(~icchips~|self.getvar(~icchips~) + 2); self.setvar(~actualicchips~|self.getvar(~actualicchips~) + 1);,Guitar Solo,EVEN,,ORANGE,change_power,change_power,,chip,,,,,,self.setvar(~icchips~|self.getvar(~icchips~) + 2); self.setvar(~actualicchips~|self.getvar(~actualicchips~) + 1);,,,,,,,,,,
CANYON.MID_downgraded,Counts as a chip,2,self.setvar(~icchips~|self.getvar(~icchips~) + 2); self.setvar(~actualicchips~|self.getvar(~actualicchips~) + 1);,Guitar Solo,EVEN,,ORANGE,,,,chip,,,,,,self.setvar(~icchips~|self.getvar(~icchips~) + 2); self.setvar(~actualicchips~|self.getvar(~actualicchips~) + 1);,,,,,,,,,,
CANYON.MID_upgraded,Inflict [weaken]weaken|Counts as a chip,2,inflict(WEAKEN); sfx(~_weaken~|~~|0.2); self.setvar(~icchips~|self.getvar(~icchips~) + 2); self.setvar(~actualicchips~|self.getvar(~actualicchips~) + 1);,Guitar Solo,MIN3,,ORANGE,,,,chip,,,,,,self.setvar(~icchips~|self.getvar(~icchips~) + 2); self.setvar(~actualicchips~|self.getvar(~actualicchips~) + 1);,,,,,,,,,,
CHIP01.MID,Inflict [shock]shock|Counts as a chip,2,inflict(SHOCK); sfx(~_shock~|~~|0.2); self.setvar(~icchips~|self.getvar(~icchips~) + 2); self.setvar(~actualicchips~|self.getvar(~actualicchips~) + 1);,Discharge,EVEN,,YELLOW,change_power,change_power,,chip,,,,,,self.setvar(~icchips~|self.getvar(~icchips~) + 2); self.setvar(~actualicchips~|self.getvar(~actualicchips~) + 1);,,,,,,,,,,
CHIP01.MID_downgraded,Counts as a chip,2,self.setvar(~icchips~|self.getvar(~icchips~) + 2); self.setvar(~actualicchips~|self.getvar(~actualicchips~) + 1);,Discharge,EVEN,,YELLOW,,,,chip,,,,,,self.setvar(~icchips~|self.getvar(~icchips~) + 2); self.setvar(~actualicchips~|self.getvar(~actualicchips~) + 1);,,,,,,,,,,
CHIP01.MID_upgraded,Inflict [shock]shock|Counts as a chip,2,inflict(SHOCK); sfx(~_shock~|~~|0.2); self.setvar(~icchips~|self.getvar(~icchips~) + 2); self.setvar(~actualicchips~|self.getvar(~actualicchips~) + 1);,Discharge,MIN3,,YELLOW,,,,chip,,,,,,self.setvar(~icchips~|self.getvar(~icchips~) + 2); self.setvar(~actualicchips~|self.getvar(~actualicchips~) + 1);,,,,,,,,,,
Block Factory,Gain [shield]<d6> shield|Counts as a chip,2,inflictself(SHIELD|d);  sfx(~_shield~|~~|0.2); self.setvar(~icchips~|self.getvar(~icchips~) + 2); self.setvar(~actualicchips~|self.getvar(~actualicchips~) + 1);,Safeguard,MAX3,,ORANGE,increaserange,decreaserange,,chip,,YES,,,,,,,,,,,,,,
Goldkey,Split a dice in two|Counts as a chip,2,givedice(split(d)|~splitdice~); self.setvar(~icchips~|self.getvar(~icchips~) + 2); self.setvar(~actualicchips~|self.getvar(~actualicchips~) + 1);,Razor Blade,MIN5,,YELLOW,increaserange,complicate,,chip,,YES,,,,,,,,,,,,,,
Firetrap,Roll two burning dice|Counts as a chip,2,inflictself(FIRE|2); givedice([rand([1|2|3|4|5|6])|rand([1|2|3|4|5|6])]); self.setvar(~icchips~|self.getvar(~icchips~) + 2); self.setvar(~actualicchips~|self.getvar(~actualicchips~) + 1);,Blowtorch,MIN4,,RED,change_power,change_power,,chip,,YES,,,,,,,,,,,,,,
Firetrap_upgraded,Roll three burning dice|Counts as a chip,2,inflictself(FIRE|3); givedice([rand([1|2|3|4|5|6])|rand([1|2|3|4|5|6])|rand([1|2|3|4|5|6])]); self.setvar(~icchips~|self.getvar(~icchips~) + 2); self.setvar(~actualicchips~|self.getvar(~actualicchips~) + 1);,Blowtorch,MIN4,,RED,,,,chip,,YES,,,,,,,,,,,,,,
Firetrap_downgraded,Roll two burning dice,2,inflictself(FIRE|2); givedice([rand([1|2|3|4|5|6])|rand([1|2|3|4|5|6])]);,Blowtorch,MIN4,,RED,,,,,,YES,,,,,,,,,,,,,,
Doublemaze,Roll two 1s|Counts as a chip,2,givedice([1|1]); self.setvar(~icchips~|self.getvar(~icchips~) + 2); self.setvar(~actualicchips~|self.getvar(~actualicchips~) + 1);,Flash Freeze,MIN4,,BRIGHTCYAN,increaserange,change_power,,chip,,YES,,,,,,,,,,,,,,
Doublemaze_downgraded,Roll two 1s,2,givedice([1|1]);,Flash Freeze,MIN4,,BRIGHTCYAN,,,,,,YES,,,,,,,,,,,,,,
Paranoia,Roll 2 dice[;] get [vanish]2 vanish|Counts as a chip,2,inflictself(~ncr_vanish~|2); givedice([rand([1|2|3|4|5|6])|rand([1|2|3|4|5|6])]); self.setvar(~icchips~|self.getvar(~icchips~) + 2); self.setvar(~actualicchips~|self.getvar(~actualicchips~) + 1);,Hadoken,MIN4,,PINK,increaserange,change_power,,chip,,YES,,,,,,,,,,,,,,
Paranoia_downgraded,Roll 2 dice[;] get [vanish]2 vanish,2,inflictself(~ncr_vanish~|2); givedice([rand([1|2|3|4|5|6])|rand([1|2|3|4|5|6])]);,Hadoken,MIN4,,PINK,,,,,,YES,,,,,,,,,,,,,,
Time Lapse,If you have 6 or more chips[;]|start an extra turn & discard|this (chips collected: <var:actualicchips>),2,if(self.getvar(~icchips~) >= 12) { inflictself(EXTRATURN); sfx(~_recycle~); self.endturnnow(); } else { self.textparticle(~No effect!~); } e.onceperbattle = true; e.usedthisbattle = true;,Time Stop,EVEN,,YELLOW,simplify,complicate,,,,YES,,,,,,,self.setvar(~icchips~|0); self.setvar(~actualicchips~|0);,,self.setvar(~icchips~|0); self.setvar(~actualicchips~|0);,,,,e.preventdefault = true; e.maintainfury = true;,
Nail Hat,Gain [reduce]2 reduce|(You lose 3 hp each turn),1,inflictself(REDUCE|2); sfx(~_shield~);,Protection,ODD,,ORANGE,simplify,complicate,,,,YES,,,,,,,,e.animate(~flashandshake~); pierceattackself(2); sfx(~_damage~);,,,,,,
Oobleck Missile,Do [sword]<d6> - 1 damage|(Scraps to current gadget),1,attack(d - 1); sfxdamage(target|d - 1);,Broken Gadget,EVEN,,PINK,change_power,complicate,,magic,,,,preservesgadget,,,,,,,,,,,,
Oobleck Missile_upgraded,Do [sword]<d6> + 2 damage|(Scraps to current gadget),1,attack(d + 2); sfxdamage(target|d + 2);,Broken Gadget,EVEN,,PINK,,,,magic,,,,preservesgadget,,,,,,,,,,,,
Oobleck Hacksaw,Split a dice in three|(Scraps to current gadget),1,givedice(split(d| 3)| ~splitdice~);,Broken Gadget,MAX3,,PINK,simplify,change_power,,none,,YES,,preservesgadget,,,,,,,,,,,,
Oobleck Hacksaw_downgraded,Split a dice in one|(Scraps to current gadget),1,givedice(d| ~splitdice~);,Broken Gadget,MAX3,,PINK,,,,none,,YES,,preservesgadget,,,,,,,,,,,,
Oobleck Capacitor,[shock]<d6> dmg + [shock]1 [gray](Reuseable)|(Scraps to current gadget),1,attack(d| SHOCK); inflict(SHOCK| 1); sfxdamage(target|d); sfx(~_shock~|~~|0.2);,Broken Gadget,NORMAL|NORMAL,5,PINK,change_power,change_power,,none,-1,NO,NO,preservesgadget|hidereuseable,1,,,,,,,,,,,
Oobleck Capacitor_upgraded,[shock]<d6> dmg + [shock]1 [gray](Reuseable)|(Scraps to current gadget),1,attack(d| SHOCK); inflict(SHOCK| 1); sfxdamage(target|d); sfx(~_shock~|~~|0.2);,Broken Gadget,NORMAL|NORMAL|FREE1,6,PINK,,,,none,-1,NO,NO,preservesgadget|hidereuseable,,,,,,,,,,,,
Oobleck Capacitor_downgraded,[shock]2 dmg + [shock]1 [gray](Reuseable)|(Scraps to current gadget),1,attack(2| SHOCK); inflict(SHOCK| 1); sfxdamage(target|2); sfx(~_shock~|~~|0.2);,Broken Gadget,NORMAL|NORMAL,5,PINK,,,,none,-1,NO,NO,preservesgadget|hidereuseable,,,,,,,,,,,,
Oobleck Mixer,[weaken]<d6> dmg + [weaken]1 [gray](Reuseable)|(Scraps to current gadget),1,attack(d| WEAKEN); inflict(WEAKEN| 1); sfxdamage(target|d); sfx(~_weaken~|~~|0.2);,Broken Gadget,NORMAL|NORMAL,5,PINK,change_power,change_power,,none,-1,NO,NO,preservesgadget|hidereuseable,1,,,,,,,,,,,
Oobleck Mixer_upgraded,[weaken]<d6> dmg + [weaken]1 [gray](Reuseable)|(Scraps to current gadget),1,attack(d| WEAKEN); inflict(WEAKEN| 1); sfxdamage(target|d); sfx(~_weaken~|~~|0.2);,Broken Gadget,NORMAL|NORMAL|FREE1,6,PINK,,,,none,-1,NO,NO,preservesgadget|hidereuseable,,,,,,,,,,,,
Oobleck Mixer_downgraded,[weaken]2 dmg + [weaken]1 [gray](Reuseable)|(Scraps to current gadget),1,attack(2| WEAKEN); inflict(WEAKEN| 1); sfxdamage(target|2); sfx(~_weaken~|~~|0.2);,Broken Gadget,NORMAL|NORMAL,5,PINK,,,,none,-1,NO,NO,preservesgadget|hidereuseable,,,,,,,,,,,,
Oobleck Flamethrower,Inflict [fire]2 burn|(Scraps to current gadget),1,inflict(FIRE|2); sfx(~_fire~);,Broken Gadget,NORMAL|NORMAL,,PINK,change_power,complicate,,none,0,NO,,preservesgadget,,,,,,,,,,,,
Oobleck Flamethrower_upgraded,Inflict [fire]4 burn|(Scraps to current gadget),2,inflict(FIRE|4); sfx(~_fire~);,Broken Gadget,NORMAL|NORMAL|NORMAL|NORMAL,,PINK,,,,none,0,NO,,preservesgadget,,,,,,,,,,,,
Oobleck Snowblower,Inflict [ice]2 freeze|(Scraps to current gadget),1,inflict(ICE|2); sfx(~_ice~);,Broken Gadget,NORMAL|NORMAL,,PINK,change_power,complicate,,none,0,NO,,preservesgadget,,,,,,,,,,,,
Oobleck Snowblower_upgraded,Inflict [ice]4 freeze|(Scraps to current gadget),2,inflict(ICE|4); sfx(~_ice~);,Broken Gadget,NORMAL|NORMAL|NORMAL|NORMAL,,PINK,,,,none,0,NO,,preservesgadget,,,,,,,,,,,,
Oobleck Proton Pack,Inflict [vanish]2 vanish|(Scraps to current gadget),1,inflict(~ncr_vanish~|2); sfx(~_vanish~);,Broken Gadget,NORMAL|NORMAL,,PINK,change_power,complicate,,none,0,NO,,preservesgadget,,,,,,,,,,,,
Oobleck Proton Pack_upgraded,Inflict [vanish]4 vanish|(Scraps to current gadget),2,inflict(~ncr_vanish~|4); sfx(~_vanish~);,Broken Gadget,NORMAL|NORMAL|NORMAL|NORMAL,,PINK,,,,none,0,NO,,preservesgadget,,,,,,,,,,,,
Oobleck Box,Very niche|(Scraps to current gadget),1,for(eq in self.equipment) eq.setvar(~alreadyhere~|1); giveequipment(rand(loadtext(~ncrmod/oobleckbox~))| true); for(eq in self.equipment) if(eq.getvar(~alreadyhere~) != 1) { self.createsparedice(eq); } for(eq in self.equipment) eq.resetvar(~alreadyhere~); /*'bad' = actually bad; or just super overspecific for inventor*/ /*consider putting 'do before start turn/on start turn/before combat' functionality in. then add daffodil and plague to the pool.*/ /*also consider a 'check if this item actually is in getequipmentlist and if not pick another' for mod compatibility nobody asked for; yay!*/,Broken Gadget,NORMAL,,PINK,change_power,change_power,,useitem,,YES,,preservesgadget|excludefromrandomlists|cannotreuse,,,,,,,,,,,,
Oobleck Box_upgraded,Contents upgraded|Still very niche|(Scraps to current gadget),1,for(eq in self.equipment) eq.setvar(~alreadyhere~|1); giveequipment(rand(loadtext(~ncrmod/oobleckbox~)) + ~+~| true); for(eq in self.equipment) if(eq.getvar(~alreadyhere~) != 1) { self.createsparedice(eq); } for(eq in self.equipment) eq.resetvar(~alreadyhere~);,Broken Gadget,NORMAL,,PINK,,,,useitem,,YES,,preservesgadget|excludefromrandomlists|cannotreuse,,,,,,,,,,,,
Oobleck Box_downgraded,Even more niche|(Scraps to current gadget),1,giveequipment(~Oobleck Box~|true);,Broken Gadget,NORMAL,,PINK,,,,useitem,,YES,,preservesgadget|excludefromrandomlists|cannotreuse,,,,,,,,,,,,
Ubernudge,-<d6> to all dice[;]|won't nudge below 1,1,var c = 0; var extradice = []; for (mydice in self.dicepool){ if (mydice.available()){ if(mydice.basevalue == 1) continue; else { if(mydice.basevalue - d < 1){ mydice.animatereroll(1| self.screenposition()| c * 0.05); } else { mydice.animatereroll((mydice.basevalue - d)| self.screenposition()| c * 0.05); } c++; } } },Double Whammy,MAX2,,GREEN,increaserange,decreaserange,,diceroll,0,YES,NO,,1,,,,,,,,,,,
Tether,[recycle]Re-equip next card,2,inflictself(REEQUIPNEXT); sfx(~_recycle~);,Sustainability,EVEN,,GREEN,change_power,complicate,reequipnext,,,YES,,,,,,,,,,,,,,
Tether_upgraded,[recycle]Re-equip next 2 cards,2,inflictself(REEQUIPNEXT|2); sfx(~_recycle~);,Sustainability,EVEN,,GREEN,,,,,,YES,,,,,,,,,,,,,,
Tether?,[recycle]Re-equip next dice,2,inflictself(REEQUIPNEXT); sfx(~_recycle~);,Sustainability,EVEN,,GREEN,change_power,complicate,,,,YES,,alternateversion,,,,,,,,,,,,
Tether?_upgraded,[recycle]Re-equip next 2 dice,2,inflictself(REEQUIPNEXT|2); sfx(~_recycle~);,Sustainability,EVEN,,GREEN,,,,,,YES,,alternateversion,,,,,,,,,,,,
Recurring Dream,Get [recycle]re-equip[;] return dice|Counts as a chip,2,inflictself(REEQUIPNEXT); sfx(~_recycle~); self.setvar(~icchips~|self.getvar(~icchips~) + 2); self.setvar(~actualicchips~|self.getvar(~actualicchips~) + 1); givedice(d);,Sustainability,MAX2,,GREEN,change_power,change_power,,chip,,YES,,,,,,,,,,,,,,
Recurring Dream_upgraded,Get [recycle]re-equip[;] reroll dice|Counts as a chip,2,inflictself(REEQUIPNEXT); sfx(~_recycle~); self.setvar(~icchips~|self.getvar(~icchips~) + 2); self.setvar(~actualicchips~|self.getvar(~actualicchips~) + 1); givedice();,Sustainability,MAX2,,GREEN,,,,chip,,YES,,,,,,,,,,,,,,
Recurring Dream_downgraded,Get [recycle]re-equip[;] return dice|Counts as a chip,2,inflictself(REEQUIPNEXT); sfx(~_recycle~); self.setvar(~icchips~|self.getvar(~icchips~) + 2); self.setvar(~actualicchips~|self.getvar(~actualicchips~) + 1); givedice(d);,Sustainability,REQUIRE2,,GREEN,,,,chip,,YES,,,,,,,,,,,,,,
Cow Tool,Do [sword]<d6> damage|On 6[;],2,attack(d); sfxdamage(target|d); if(d == 6) { },Broken Gadget[],NORMAL,,ORANGE,change_power,change_power,,,,,,,,,,,,,,,,,,
Cow Tool_upgraded,Do [sword]<d6> damage|On even[;],2,attack(d); sfxdamage(target|d); if(d % 2 == 0) { },Broken Gadget[],NORMAL,,ORANGE,,,,,,,,,,,,,,,,,,,,
Cow Tool_downgraded,On 6[;],2,if(d == 6) { },Broken Gadget[],REQUIRE6,,ORANGE,,,,,,,,,,,,,,,,,,,,
Tootsie Pop,Reroll the dice. On 6[;]|instead return two 6s,2,if(d == 6) givedice([6|6]); else givedice();,Megabump,NORMAL,,ORANGE,change_power,change_power,,,,YES,,,,,,,,,,,,,,
Tootsie Pop_upgraded,Roll a higher dice. On 6[;]|instead return two 6s,2,if(d >= 6) givedice([6|6]); else givedice(rand([6|5|4|3|2|1].splice(0|6-d))); /*awful. who wrote this*/,Megabump,NORMAL,,ORANGE,,,,,,YES,,,,,,,,,,,,,,
Tootsie Pop_downgraded,Reroll the dice. On 6[;]|instead return two 1s,2,if(d == 6) givedice([1|1]); else givedice();,Megabump,NORMAL,,ORANGE,,,,,,YES,,,,,,,,,,,,,,
Crazy Glue,[lock]Counter a random dice|that's not countered yet,1,var availablecounters = [1|2|3|4|5|6]; for(num in availablecounters) { if(getstatus(~counter_~ + num) > 0) { availablecounters.remove(num); } } if(availablecounters.length == 0) { self.textparticle(~No effect!~); } else { inflict(~counter_~ + rand(availablecounters)); sfx(~_lock~); },Confiscate,NORMAL,,PURPLE,change_power,change_power,,,,,,,,,,,,,,,,,,
Crazy Glue_downgraded,[lock]Counter a random dice|that's not countered yet,1,var availablecounters = [1|2|3|4|5|6]; for(num in availablecounters) { if(getstatus(~counter_~ + num) > 0) { availablecounters.remove(num); } } if(availablecounters.length == 0) { self.textparticle(~No effect!~); } else { inflict(~counter_~ + rand(availablecounters)); sfx(~_lock~); },Confiscate,ODD,,PURPLE,,,,,,,,,,,,,,,,,,,,
Crazy Glue_upgraded,[lock]Counter a random dice|higher than or equal to <d6>,1,var availablecounters = [6|5|4|3|2|1].splice(0|7-d); for(num in availablecounters) { if(getstatus(~counter_~ + num) > 0) { availablecounters.remove(num); } } if(availablecounters.length == 0) { self.textparticle(~No effect!~); } else { inflict(~counter_~ + rand(availablecounters)); sfx(~_lock~); },Confiscate,NORMAL,,PURPLE,,,,,,,,,,,,,,,,,,,,
Blue Wall,Do [sword]4 damage|50% chance to return dice|Counts as a chip,1,attack(4); sfxdamage(target|4); var odds = 50; if(getstatusself(~luck~) > 0 # getstatusself(~luck+~) > 0) odds = 100; if(chance(odds)) { givedice(d); self.textparticle(~Success!~); } self.setvar(~icchips~|self.getvar(~icchips~) + 2); self.setvar(~actualicchips~|self.getvar(~actualicchips~) + 1);,Rubber Bullet,MIN4,,PURPLE,change_power,change_power,,chip,,,,,,var odds = 50; if(getstatusself(~luck~) > 0 # getstatusself(~luck+~) > 0) odds = 100; if(chance(odds)) { givedice(d); self.textparticle(~Success!~); } self.setvar(~icchips~|self.getvar(~icchips~) + 2); self.setvar(~actualicchips~|self.getvar(~actualicchips~) + 1);,,,,,,,,,,
Blue Wall_upgraded,Do [sword]<d6> damage|50% chance to return dice|Counts as a chip,1,attack(d); sfxdamage(target|d); var odds = 50; if(getstatusself(~luck~) > 0 # getstatusself(~luck+~) > 0) odds = 100; if(chance(odds)) { givedice(d); self.textparticle(~Success!~); } self.setvar(~icchips~|self.getvar(~icchips~) + 2); self.setvar(~actualicchips~|self.getvar(~actualicchips~) + 1);,Rubber Bullet,MIN4,,PURPLE,,,,chip,,,,,,var odds = 50; if(getstatusself(~luck~) > 0 # getstatusself(~luck+~) > 0) odds = 100; if(chance(odds)) { givedice(d); self.textparticle(~Success!~); } self.setvar(~icchips~|self.getvar(~icchips~) + 2); self.setvar(~actualicchips~|self.getvar(~actualicchips~) + 1);,,,,,,,,,,
Blue Wall_downgraded,Do [sword]2 damage|50% chance to return dice|Counts as a chip,1,attack(2); sfxdamage(target|2); var odds = 50; if(getstatusself(~luck~) > 0 # getstatusself(~luck+~) > 0) odds = 100; if(chance(odds)) { givedice(d); self.textparticle(~Success!~); } self.setvar(~icchips~|self.getvar(~icchips~) + 2); self.setvar(~actualicchips~|self.getvar(~actualicchips~) + 1);,Rubber Bullet,MIN4,,PURPLE,,,,chip,,,,,,var odds = 50; if(getstatusself(~luck~) > 0 # getstatusself(~luck+~) > 0) odds = 100; if(chance(odds)) { givedice(d); self.textparticle(~Success!~); } self.setvar(~icchips~|self.getvar(~icchips~) + 2); self.setvar(~actualicchips~|self.getvar(~actualicchips~) + 1);,,,,,,,,,,
Sticky Cauldron,Do [sword]2 per counter placed|Receive each countered dice,1,var counters = [1|2|3|4|5|6]; var dicelist = []; for(num in counters) if(getstatus(~counter_~ + num) > 0) dicelist.push(num); if(dicelist.length > 0) { givedice(dicelist); attack(2 * dicelist.length); sfxdamage(target|2 * dicelist.length); } else self.textparticle(~No effect!~); /*good thing this isn't php*/,Copyright Strike,NORMAL,,PURPLE,change_power,change_power,,,,NO,,,,var counters = [1|2|3|4|5|6]; var dicelist = []; for(num in counters) if(getstatus(~counter_~ + num) > 0) dicelist.push(num); if(dicelist.length > 0) givedice(dicelist); else self.textparticle(~No effect!~);,,,,,,,,,,
Sticky Cauldron_upgraded,Do [sword]3 per counter placed|Receive each countered dice,1,var counters = [1|2|3|4|5|6]; var dicelist = []; for(num in counters) if(getstatus(~counter_~ + num) > 0) dicelist.push(num); if(dicelist.length > 0) { givedice(dicelist); attack(3 * dicelist.length); sfxdamage(target|3 * dicelist.length); } else self.textparticle(~No effect!~);,Copyright Strike,NORMAL,,PURPLE,,,,,,NO,,,,var counters = [1|2|3|4|5|6]; var dicelist = []; for(num in counters) if(getstatus(~counter_~ + num) > 0) dicelist.push(num); if(dicelist.length > 0) givedice(dicelist); else self.textparticle(~No effect!~);,,,,,,,,,,
Sticky Cauldron_downgraded,Receive each countered dice,1,var counters = [1|2|3|4|5|6]; var dicelist = []; for(num in counters) if(getstatus(~counter_~ + num) > 0) dicelist.push(num); if(dicelist.length > 0) givedice(dicelist); else self.textparticle(~No effect!~);,Copyright Strike,NORMAL,,PURPLE,,,,,,YES,,,,var counters = [1|2|3|4|5|6]; var dicelist = []; for(num in counters) if(getstatus(~counter_~ + num) > 0) dicelist.push(num); if(dicelist.length > 0) givedice(dicelist); else self.textparticle(~No effect!~);,,,,,,,,,,
Blow,Bump and lock dice[;]|return the dice,1,var lockamt = 1; if(d >= 6) lockamt = 2; var lockisalt = false; var dummyfighter = new elements.Fighter(~Wisp~); dummyfighter.addstatus(~lock~|1); trace(dummyfighter.status.length); if(dummyfighter.status.length > 0) { for(stat in dummyfighter.status) { if(stat.type == ~alternate_lock~) { lockisalt = true; } } } if(lockamt == 1) { givedice([d|d + 1]); } else { givedice([6|1|6]); }  if(lockisalt) {  for(mydice in [for(i in 0...lockamt) self.dicepool[(self.dicepool.length - 1) - i]]) {   mydice.animate(~alternate_lock~);  }  inflictself(~alternate_lock~|lockamt); } else {  for(mydice in [for(i in 0...lockamt) self.dicepool[(self.dicepool.length - 1) - i]]) {   mydice.locked = true;  }  sfx(~_lock~); } /* if(d < 6) { inflictself(LOCK); givedice([d + 1|d]); } else { inflictself(LOCK|2); givedice([6|1|6]); } */,Megabump,MAX5,,PURPLE,simplify,complicate,,_lock,,YES,,,,,,,,,,,,,,
Speak Softly?,Deal [sword]2 dmg per thorn,2,attack(getstatusself(THORNS) * 2); sfxdamage(target|getstatusself(THORNS) * 2); sfx(~_thorns~|~~|0.2);,Deep Breath,ODD,,GREEN,change_power,change_power,,,,,,alternateversion,,,,,,,,,,,,
Speak Softly?_downgraded,Deal [sword]1 dmg per thorn,2,attack(getstatusself(THORNS)); sfxdamage(target|getstatusself(THORNS)); sfx(~_thorns~|~~|0.2);,Deep Breath,ODD,,GREEN,,,,,,,,alternateversion,,,,,,,,,,,,
Speak Softly?_upgraded,Deal [sword]2 dmg per thorn|Return the dice,2,attack(getstatusself(THORNS) * 2); sfxdamage(target|getstatusself(THORNS) * 2); sfx(~_thorns~|~~|0.2); givedice(d);,Deep Breath,ODD,,GREEN,,,,,,,,alternateversion,,givedice(d);,,,,,,,,,,
Mind,Do [sword]<d6> damage|If already used[;] get new dice,2,attack(d); sfxdamage(target|d); if(e.timesused > 0) givedice();,Phillips Head,NORMAL,,GREEN,,,,,,,,,,,,,e.timesused = 0;,,,,,,,
Jester?,Spin the Wheel|50% chance: gain a blessing,2,var odds = 50; if(getstatusself(~luck~) > 0 # getstatusself(~luck+~) > 0){ odds = 100; } if(chance(odds)) { var randomstatus = SHIELD; if(getstatusself(FURY) == 0) { randomstatus = rand([SHIELD|FURY|REDUCE|REEQUIPNEXT|DODGE]); } else { randomstatus = rand([SHIELD|REDUCE|REEQUIPNEXT|DODGE]); } var a = 1; if (randomstatus == SHIELD) a = 4; if (randomstatus == REDUCE) a = 2; inflictself(randomstatus | a); if(randomstatus == REEQUIPNEXT) randomstatus = ~recycle~; if(randomstatus == REDUCE) randomstatus = ~shield~; sfx(~_~ + randomstatus.toLowerCase()|~~|0.2); } else { self.textparticle(~No effect!~); },Rejuvenate,,,RED,,,,,0,YES,NO,alternateversion|powercard,,,,,,,,,var dicelist = []; for (mydice in self.dicepool) { if (mydice.available()){ dicelist.push(mydice); } } dicelist.sort(function(a|b) { return a.basevalue - b.basevalue; } ); d = dicelist[0].basevalue;,,,
Jester_downgraded,Random Roll|Reroll a random dice,2,var availdice = []; if(self.dicepool.length > 0) for (mydice in self.dicepool){ if (mydice.available()){ availdice.push(mydice); } } if(availdice.length > 0) { shuffle(availdice); availdice[0].animatereroll(rand([1|2|3|4|5|6]) | self.screenposition());  },Dice Bash,,,RED,,,,,0,YES,NO,powercard,,,,,,,,,,,,
Jester?_downgraded,Random Roll|Reroll a random dice,2,var availdice = []; if(self.dicepool.length > 0) for (mydice in self.dicepool){ if (mydice.available()){ availdice.push(mydice); } } if(availdice.length > 0) { shuffle(availdice); availdice[0].animatereroll(rand([1|2|3|4|5|6]) | self.screenposition());  },Rejuvenate,,,RED,,,,,0,YES,NO,alternateversion|powercard,,,,,,,,,,,,
Mars Fly Trap,Do [sword]<d6> damage. On 6[;]|heal [heart]6[;] discard this,2,attack(d); sfxdamage(target|d); if(d == 6) { attackself(-6); sfx(~_heal~|~~|0.2); e.onceperbattle = true; e.usedthisbattle = true; } /*thx kirb; cody; and cody again for the name suggestions; respectively*/,Health Pack,NORMAL,,RED,change_power,change_power,,,,,,,,if(d == 6) { attackself(-6); sfx(~_heal~|~~|0.2); e.onceperbattle = true; e.usedthisbattle = true; },,,,,,,,,,
Mars Fly Trap_upgraded,Do [sword]<d6> damage. On 6[;]|heal [heart]6[;] discard this,2,attack(d); sfxdamage(target|d); if(d == 7) { attackself(-6); sfx(~_heal~|~~|0.2); e.onceperbattle = true; e.usedthisbattle = true; } /*thx kirb; cody; and cody again for the name suggestions; respectively*/,Health Pack,NORMAL,,RED,,,,,,,,,,if(d == 6) { attackself(-6); sfx(~_heal~|~~|0.2); e.onceperbattle = true; e.usedthisbattle = true; },,,,,,,,,,
Mars Fly Trap_downgraded,Do [sword]<d6> damage. On 6[;]|heal [heart]3[;] discard this,2,attack(d); sfxdamage(target|d); if(d == 6) { attackself(-3); sfx(~_heal~|~~|0.2); e.onceperbattle = true; e.usedthisbattle = true; } /*thx kirb; cody; and cody again for the name suggestions; respectively*/,Health Pack,NORMAL,,RED,,,,,,,,,,if(d == 6) { attackself(-6); sfx(~_heal~|~~|0.2); e.onceperbattle = true; e.usedthisbattle = true; },,,,,,,,,,
Generous Crystal,Heal [heal]<d6> to whosever|health bar is less full,1,var myhpratio = self.hp / self.maxhp; var enemyhpratio = target == null ? 999 : target.hp / target.maxhp; if(myhpratio == enemyhpratio) self.textparticle(~No effect!~); else { sfx(~_heal~); if(e.castdirection == 1) attack(-d); if(e.castdirection == -1) attackself(-d); },Embrace,MAX5,,GREEN,simplify,complicate,,,,,,,,,,,,,,,var myhpratio = self.hp / self.maxhp; var enemyhpratio = target == null ? 999 : target.hp / target.maxhp; if(myhpratio > enemyhpratio) e.castdirection = 1; if(myhpratio <= enemyhpratio) e.castdirection = -1;,,,
Charger Cable,Gain [confuse]<d6>/2 limit charge|Inflict [shock]1 shock,1,sfx(~_shock~); inflict(SHOCK); if(self.limitvalue != null && self.limitmax != null) { var charge = d / 2; if(charge % 1 != 0) charge += 0.5; self.limitvalue += charge; if(self.limitvalue > self.limitmax) { self.limitvalue = self.limitmax; } },Discharge,EVEN,,YELLOW,simplify,change_power,,,,,,,,if(self.limitvalue != null && self.limitmax != null) { var charge = d / 2; if(charge % 1 != 0) charge += 0.5; self.limitvalue += charge; if(self.limitvalue > self.limitmax) { self.limitvalue = self.limitmax; } },,,,,,,,,,
Charger Cable_downgraded,Gain [confuse]<d6>/2 limit charge,1,sfx(~_shock~); if(self.limitvalue != null && self.limitmax != null) { var charge = d / 2; if(charge % 1 != 0) charge += 0.5; self.limitvalue += charge; if(self.limitvalue > self.limitmax) { self.limitvalue = self.limitmax; } },Discharge,EVEN,,YELLOW,,,,,,YES,,,,,,,,,,,,,,
Oobleck Bump,Bump a random dice[;]|return this dice|(Scraps to current gadget),1,var douses = []; if(actualdice != null && actualdice[0] != null) douses.push(actualdice[0]); for(mydice in self.dicepool) if(mydice.available()) douses.push(mydice); var douse = rand(douses); if(actualdice != null && douse == actualdice[0]) { if(d < 6) givedice(d + 1); else givedice([6|1]); } else { if(douse.basevalue < 6) douse.animatereroll(douse.basevalue + 1 | self.screenposition()); else { douse.animatereroll(6 | self.screenposition()); givedice(1); } },Broken Gadget,NORMAL,,PINK,change_power,complicate,,,,YES,,preservesgadget,,,,,,,,,,,,
Oobleck Bump_upgraded,Bump this dice|(Scraps to current gadget),1,if(d < 6) givedice(d + 1); else givedice([6|1]);,Broken Gadget,NORMAL,,PINK,,,,,,YES,,preservesgadget,,,,,,,,,,,,
Frozen Oobleck,Inflict or receive [ice]1 freeze|(Scraps to current gadget),1,if(e.castdirection == 1) { inflict(ICE); sfx(~_ice~); } else { var oldfreeze = 0; var oldaltfreeze = 0; if(self.status.length > 0) { for(stat in self.status) { if(stat.type == ~ice~) { oldfreeze = stat.value; } if(stat.type == ~alternate_ice~) { oldaltfreeze = stat.value; } } } inflictself(ICE); var inflictwhat = ~~; for(stat in self.status) { if(stat.type == ~ice~ && stat.value != oldfreeze) { inflictwhat = stat.type; } if(stat.type == ~alternate_ice~ && stat.value != oldaltfreeze) { inflictwhat = stat.type; } } if(inflictwhat == ~ice~) { var dicelist = []; for(mydice in self.dicepool) { if(mydice.available() && mydice.burn != true && mydice.animateburn != true) { dicelist.push(mydice); } } if(dicelist.length > 0) { dicelist.sort(function(a|b) return -1 * (a.basevalue - b.basevalue)); dicelist[0].animate(~ice~); } } if(inflictwhat == ~alternate_ice~) { for(mydice in self.dicepool) { if(mydice.available() && mydice.burn != true && mydice.animateburn != true) { mydice.animate(~alternate_ice~); } } } if(self.status.length > 0) { for(stat in self.status) { if(stat.type == inflictwhat) { stat.value--; } } } },Broken Gadget,ODD,,PINK,simplify,complicate,,,,,,preservesgadget,,,,,,,,,var odds = 50; if(getstatusself(~luck~) > 0 # getstatusself(~luck+~) > 0){ odds = 100; } if(chance(odds)) { e.castdirection = 1; } else { e.castdirection = -1; },,,
Warm Oobleck,Inflict or receive [fire]1 burn|(Scraps to current gadget),1,if(e.castdirection == 1) { inflict(FIRE); sfx(~_fire~); } else { var oldburn = 0; var oldaltburn = 0; if(self.status.length > 0) { for(stat in self.status) { if(stat.type == ~fire~) { oldburn = stat.value; } if(stat.type == ~alternate_fire~) { oldaltburn = stat.value; } } } inflictself(FIRE); var inflictwhat = ~~; for(stat in self.status) { if(stat.type == ~fire~ && stat.value != oldburn) { inflictwhat = stat.type; } if(stat.type == ~alternate_fire~ && stat.value != oldaltburn) { inflictwhat = stat.type; } } if(inflictwhat != ~~) { var dicelist = []; for(mydice in self.dicepool) { if(mydice.available() && mydice.burn != true && mydice.alternateburn != true) { dicelist.push(mydice); } } if(dicelist.length > 0) { shuffle(dicelist); dicelist[0].animate(inflictwhat); } if(self.status.length > 0) { for(stat in self.status) { if(stat.type == inflictwhat) { stat.value--; } } } } /*-we walked in?*/ },Broken Gadget,ODD,,PINK,simplify,complicate,,,,,,preservesgadget,,,,,,,,,var odds = 50; if(getstatusself(~luck~) > 0 # getstatusself(~luck+~) > 0){ odds = 100; } if(chance(odds)) { e.castdirection = 1; } else { e.castdirection = -1; },,,
Invisible Oobleck,Inflict or receive [vanish]1 vanish|(Scraps to current gadget),1,if(e.castdirection == 1) { inflict(~ncr_vanish~); sfx(~_vanish~); } else { inflictself(~ncr_vanish~); sfx(~_vanish~); },Broken Gadget,ODD,,PINK,simplify,complicate,,,,,,preservesgadget,,,,,,,,,var odds = 50; if(getstatusself(~luck~) > 0 # getstatusself(~luck+~) > 0){ odds = 100; } if(chance(odds)) { e.castdirection = 1; } else { e.castdirection = -1; },,,
Ooblock,[]+[shield]<d6> shield for both|(Scraps to current gadget),1,inflict(SHIELD|d); inflictself(SHIELD|d); sfx(~_shield~);,Broken Gadget,MAX3,,PINK,change_power,change_power,,,,,,preservesgadget,,inflictself(SHIELD|d); sfx(~_shield~);,,,,,,,,,,
Ooblock_downgraded,[]+[shield]<d6> shield for both[;]|[sword]<d6> damage for both|(Scraps to current gadget),1,inflict(SHIELD|d); inflictself(SHIELD|d); sfx(~_shield~); attack(d); attackself(d); sfxdamage(target|d);,Broken Gadget,MAX3,,PINK,,,,,,,,preservesgadget,,inflictself(SHIELD|d); sfx(~_shield~); attackself(d); sfxdamage(self|d);,,,,,,,,,,
Ooblock_upgraded,[]+[shield]<d6> shield for both|(Scraps to current gadget),1,inflict(SHIELD|d); inflictself(SHIELD|d); sfx(~_shield~);,Broken Gadget,MAX5,,PINK,,,,,,,,preservesgadget,,inflictself(SHIELD|d); sfx(~_shield~);,,,,,,,,,,
Roman Candle@ncrmod,Do [sword]<d6> dmg. VVhen gadget|name reiects improper Latin|letters[;] +[sword]1 dmg per statvs,2,var extradamage = 0; var g = Gadget.getcurrentgadget(self).toLowerCase().split(~j~).join(~~).split(~u~).join(~~).split(~w~); if(g.length == 1) { extradamage = getstatus(ALL); } attack(d + extradamage); sfxdamage(target|d + extradamage); /*this one was thought up by kirby_dungeons; thanks kirb*/,Vaporizer,EVEN,,RED,change_power,change_power,,,,,,inventoronly,,,,,,,,,,,,
Roman Candle@ncrmod_upgraded,Do [sword]<d6> dmg. VVhen gadget|name reiects improper Latin|letters[;] +[sword]2 dmg per statvs,2,var extradamage = 0; var g = Gadget.getcurrentgadget(self).toLowerCase().split(~j~).join(~~).split(~u~).join(~~).split(~w~); if(g.length == 1) { extradamage = getstatus(ALL) * 2; } attack(d + extradamage); sfxdamage(target|d + extradamage);,Vaporizer,EVEN,,RED,,,,,,,,inventoronly,,,,,,,,,,,,
Roman Candle@ncrmod_downgraded,Do [sword]<d6> dmg. VVhen gadget|name reiects improper Latin|letters[;] +[sword]1 dmg per statvs,2,var extradamage = 0; var g = Gadget.getcurrentgadget(self).toLowerCase().split(~j~).join(~~).split(~u~).join(~~).split(~w~); if(g.length == 1) { extradamage = getstatus(ALL); } attack(d + extradamage); sfxdamage(target|d + extradamage);,Vaporizer,REQUIRE6,,RED,,,,,,,,inventoronly,,,,,,,,,,,,
Stealing,After each battle[;] replace|this with the last card|your enemy used.,2,,Steal,,,,,,,,,,,skillcard|excludefromrandomlists|cannotsteal,,,if(self.getskillcard() == e) {  var playerscriptendturn = ~   if(target != null && target.hp <= 0 && target.lastequipmentused != null) {    var eq = target.lastequipmentused;    var replacename = eq.name + eq.namemodifier.split(\~-\~).join(\~\~);    self.replaceskillcard(replacename);    self.getskillcard().resize(2);    self.getskillcard().animate(\~flashandshake\~);    self.getskillcard().y = 630;    self.getskillcard().show = true;   }   if(self.getskillcard() != null && self.getskillcard().onceperbattle && self.getskillcard().usedthisbattle) {    self.getskillcard().usedthisbattle = false;    self.getskillcard().availablenextturn = false;    self.getskillcard().unavailabletext = self.getskillcard().displayname + self.getskillcard().namemodifier;    self.getskillcard().unavailabledetails = [\~Unavailable\~|\~(Once Per Battle)\~];   }  ~;  if(self.scriptendturn.indexOf(playerscriptendturn) == -1) {   self.scriptendturn = playerscriptendturn + self.scriptendturn;  }  var playerscriptonstartturn = ~   if(self.getskillcard() != null && !self.getskillcard().availablethisturn && self.getskillcard().unavailabledetails[1] == \~(Once Per Battle)\~) {  self.getskillcard().availablenextturn = false;   }  ~;  if(self.scriptonstartturn.indexOf(playerscriptonstartturn) == -1) {   self.scriptonstartturn = playerscriptonstartturn + self.scriptonstartturn;  } },,,,,,,,,
Anvil,Do [sword]<d6> damage. On 6[;]|temporarily upgrade stolen card,2,,Steal,NORMAL,,,,,,,,,,unfinished|excludefromrandomlists,,,,,,,,,,,,
Forty Cakes,Borrow an enemy equipment|[80%][gray]''That's as many as four tens.''[],2,if(!simulation){ if(target != null) { var enemyequipment = []; for (eq in target.equipment){ if(!eq.hastag(~cannotsteal~) && eq.skillcard == ~~ && eq.availablenextturn){ enemyequipment.push(eq); } } if(enemyequipment.length > 0){ var randomequipment = rand(enemyequipment); randomequipment.availablenextturn = false; randomequipment.unavailabletext = ~Snatched!~; var stealphrases = [[~Think of it this way:~|~sharing is fun!~]|[~Mind if I borrow this?~]|[~That ~ + randomequipment.name + ~ looks~|~an awful lot like mine.~]|[~I.O.U. 1 ~ + randomequipment.name]|[~It's not your property[;]~|~it's the show's property!~]|[~I'll take this off your~|~hands for a stick of gum.~]]; if(self.name == ~Thief~) { stealphrases.push([~I'm a thief!~|~It's what I do.~]); stealphrases.push([~What's yours is mine[;] and~|~what's mine is also mine.~]); } randomequipment.unavailabledetails = rand(stealphrases).concat([~Signed[;] {enemyname}~]); sfx(~_thinghappens~); giveequipment(randomequipment.name + randomequipment.namemodifier); }}} else { bonus(1000); },Steal,COUNTDOWN,10,PINK,change_power,change_power,,,,,,excludefromrandomlists|cannotsteal|curseavoid|cannotreuse,,,,,,,,,,,,
Forty Cakes_upgraded,Borrow an enemy equipment|[80%][gray]''And that's terrible.''[],2,if(!simulation){ if(target != null) { var enemyequipment = []; for (eq in target.equipment){ if(!eq.hastag(~cannotsteal~) && eq.skillcard == ~~ && eq.availablenextturn){ enemyequipment.push(eq); } } if(enemyequipment.length > 0){ var randomequipment = rand(enemyequipment); randomequipment.availablenextturn = false; randomequipment.unavailabletext = ~Snatched!~; var stealphrases = [[~Think of it this way:~|~sharing is fun!~]|[~Mind if I borrow this?~]|[~That ~ + randomequipment.name + ~ looks~|~an awful lot like mine.~]|[~I.O.U. 1 ~ + randomequipment.name]|[~It's not your property[;]~|~it's the show's property!~]|[~I'll take this off your~|~hands for a stick of gum.~]]; if(self.name == ~Thief~) { stealphrases.push([~I'm a thief!~|~It's what I do.~]); stealphrases.push([~What's yours is mine[;] and~|~what's mine is also mine.~]); } randomequipment.unavailabledetails = rand(stealphrases).concat([~Signed[;] {enemyname}~]); sfx(~_thinghappens~); giveequipment(randomequipment.name + randomequipment.namemodifier); }}} else { bonus(1000); },Steal,COUNTDOWN,7,PINK,,,,,,,,excludefromrandomlists|cannotsteal|curseavoid|cannotreuse,,,,,,,,,,,,
Forty Cakes_downgraded,No effect,2,self.textparticle(~No effect!~);,Steal,COUNTDOWN,10,PINK,,,,,,,,excludefromrandomlists|cannotsteal|curseavoid|cannotreuse,,,,,,,,,,,,
Forty Cakes_weakened,No effect,2,self.textparticle(~No effect!~);,Steal,COUNTDOWN,7,PINK,,,,,,,,excludefromrandomlists|cannotsteal|curseavoid|cannotreuse,,,,,,,,,,,,
Funnel,Do [sword]2 damage[;] roll a dice|1 less than your lowest dice|,1,attack(2); sfxdamage(target|2); var min = d; if(self.dicepool.length > 0) { for (mydice in self.dicepool){ if (mydice.available() && mydice.basevalue < min) { min = mydice.basevalue; } } } if(min > 1) { givedice(min - 1); },Gadget Roll,EVEN,,YELLOW,change_power,change_power,,,-1,,,,,,,,,,,,,,,
Funnel_upgraded,Do [sword]3 damage[;] roll a dice|1 less than your lowest dice|,1,attack(3); sfxdamage(target|3); var min = d; if(self.dicepool.length > 0) { for (mydice in self.dicepool){ if (mydice.available() && mydice.basevalue < min) { min = mydice.basevalue; } } } if(min > 1) { givedice(min - 1); },Gadget Roll,EVEN,,YELLOW,,,,,-1,,,,,,,,,,,,,,,
Funnel_downgraded,Do [sword]1 damage[;] roll a dice|1 less than your lowest dice|,1,attack(1); sfxdamage(target|1); var min = d; if(self.dicepool.length > 0) { for (mydice in self.dicepool){ if (mydice.available() && mydice.basevalue < min) { min = mydice.basevalue; } } } if(min > 1) { givedice(min - 1); },Gadget Roll,EVEN,,YELLOW,,,,,-1,,,,,,,,,,,,,,,
