Name,Description,Image,ImageOffset,Rule Change,Apply On Continue
The Inventor?,All chest contents are duplicated[;] but|you must make two gadgets per battle.,_inventor,-90|-40,if(!self.varexists(~ncrtheinventorapplied~)) { var oldgadget = Gadget.getcurrentgadget(self); Rules.inventor_setgadgets(1); var newgadget = Gadget.getcurrentgadget(self); Gadget.changegadget(self| newgadget| oldgadget); Gadget.givegadget(self| newgadget| false); trace(~ncr the inventor applied~); } Rules.doublechests = true;,YES
Marshmallow?,On odd turns[;] your initial rolls are odd.|On even turns[;] your initial rolls are even.,marshmallow,10|-10,Rules.addextrascript(~if(turn % 2 == 1) { Rules.playerdicerange([1[;] 3[;] 5]); } else { Rules.playerdicerange([2[;] 4[;] 6]); }~[;] ~beforestartturn~);,YES
Rotten Apple?,Gain [heart]5[] max health[;] but|lose 1 after each fight.,applemimic,0|0,if(self.getvar(~ncrappleapplied~) == 0) { self.maxhp += 5; self.hp += 5; self.setvar(~ncrappleapplied~|1); } Rules.addextrascript(~if(self.maxhp > 1) { self.maxhp -= 1; if(self.hp > self.maxhp) { self.hp = self.maxhp; } }~[;] ~aftercombat~);,YES
Wisp?,Swap all [vanish]Vanish equipment for|[fire]Fire equipment[;] and vice versa.,wisp,20|-60,var database = loaddata(~ncrmod/remixes/wisp~); trace(database); for(eq in database) Rules.swap(eq.fire_equipment[;] eq.vanish_equipment);,YES
The Warrior?,Your skillcard no longer rotates.,_warrior,-90|-20,self.setvar(~ncrthewarriorstopskillcardshuffle~|1);,YES
The Robot?,Jackpot rewards are now static.,_robot,-90|-20,var jacklist = Rules.jackpotskills; var rarejacklist = Rules.jackpotskills_lowodds; var chosenjacks = []; for(i in 0...3) { if(chance(80)) { chosenjacks.push(rand(jacklist)); jacklist.remove(chosenjacks[i]); } else { chosenjacks.push(rand(rarejacklist)); rarejacklist.remove(chosenjacks[i]); } } Rules.jackpotskills = chosenjacks; Rules.jackpotskills_lowodds = [];,YES
The Jester?,Discarding now grants a dice.|Your limit break is now Match 3.,_jester,-90|-20,self.changelimitbreak(~Match 3~); Deck.snapstyle = ~dice~; self.template.limit = self.limitbreak.name; Rules.addextrascript(~Deck.snapstyle = \~dice\~;~[;] ~beforestartturn~);,YES
The Thief?,Switch to [quote]Uptick[quote] rules.,_thief,-90|-20,if(self.getskillcard().name.substr(0|6) != ~Uptick~) { self.replaceskillcard(~Uptick@1~); self.setvar(~uptick~|1); } Rules.addextrascript(~var uptick = self.getvar(\~uptick\~); Rules.stackplayerdice([[uptick]][;] true); self.replaceskillcard(\~Uptick@\~ + uptick);~|~beforestartturn~); Rules.addextrascript(~var uptick = self.getvar(\~uptick\~) + 1; if(uptick >=7) uptick = 1; self.setvar(\~uptick\~[;] uptick);~|~endturn~); Rules.addextrascript(~var uptick = self.getvar(\~uptick\~) + 1; if(uptick >=7) uptick = 1; self.setvar(\~uptick\~[;] uptick);~|~aftercombat); self.changelimitbreak(~Trips~);,YES
Banshee?,At the end of each turn[;] your limit|break is decharged by 2 points.,banshee,-20|0,Rules.addextrascript(~self.limitvalue -= 2; if (self.limitvalue < 0) { self.limitvalue = 0; }~[;] ~endturn~);,YES
Loud Bird?,Your limit break is|permanently weakened.,loudbird,0|-50,self.changelimitbreak(self.alternatelimitbreak.name); self.alternatelimitbreak = new elements.Skill(~Limit Broke~);,YES
Sneezy?,Each turn[;] boost everyone's countdowns|by 2[;] except if they would activate.,sneezey,-20|-10,Rules.addextrascript(~if(self.equipment.length > 0) { for(eq in self.equipment) { if(eq.remainingcountdown > 2 && eq.isready() && eq.shockedsetting == 0) { var newdice = new elements.Dice(); newdice.basevalue = 2; self.dicepool.push(newdice); eq.assigndice(newdice); eq.animate(\~flash\~); } } } ~[;] ~onstartturn~); Rules.addextrascript(~target.scriptonstartturn = \~if(self.equipment.length > 0) { for(eq in self.equipment) { if(eq.remainingcountdown > 2 && eq.isready() && eq.shockedsetting == 0) { var newdice = new elements.Dice(); newdice.basevalue = 2; self.dicepool.push(newdice); eq.assigndice(newdice); eq.animate(\\\~flash\\\~); } } } \~ + target.scriptonstartturn;~[;] ~startcombat~);,YES
Warlock?,Ten random status effects|are made different.,warlock,-70|-50,/*trace(~ncr status list:~ + self.getvar(~ncrwarlockstatuslist~)); trace(self.getvar(~ncrwarlockstatuslist~).length); trace(self.getvar(~ncrwarlockstatuslist~).length > 1);*/ if(self.getvar(~ncrwarlockstatuslist~).length == null) { trace(~setting statuslist~); var statuslist = [~vanish~|~silence~|~poison~|~fire~|~shock~|~ice~|~weaken~|~curse~|~blind~|~fury~|~lock~|~shield~|~dodge~|~thorns~|~confuse~|~clock~|~ctrig~|~reequipnext~|~survive~|~vampire~]; shuffle(statuslist); for(i in 1...10) { statuslist.pop(); } /*trace(statuslist);*/ self.setvar(~ncrwarlockstatuslist~|statuslist); trace(self.getvar(~ncrwarlockstatuslist~)); } /*trace(self.getvar(~ncrwarlockstatuslist~));*/ for(s in self.getvar(~ncrwarlockstatuslist~)) { if(s == ~clock~) { for(i in 1...7) { Rules.setalternate(~counter_~ + i); } } else if(s == ~ctrig~) { for(i in 1...7) { Rules.setalternate(~dice_trigger_~ + i); } } else { if(s == ~fire~ # s == ~ice~) { Rules.setalternate(s); Rules.setalternate(s + ~_all~); } else { if(s == ~vanish~) { Rules.setalternate(~vanish~); Rules.setalternate(~ncr_vanish~); } } } else { Rules.setalternate(s); } },YES
The Witch?,Switch to [quote]Countdown[quote] rules.,_witch,-90|-30,Rules.stackplayerdice([[6[;] 5[;] 4[;] 3[;] 2[;] 1]][;] false);,YES
Bounty Hunter?,Inflicting [fire]Burn also inflicts|[shock]Shock[;] and vice versa.,bountyhunter,-20|0,Rules.addplayerinnatestatus(~ncr_bountyhunter_helper~); Rules.addenemyinnatestatus(~ncr_bountyhunter_helper~);,YES
Drain Monster?,Inflicting [poison]Poison also inflicts|[weaken]Weaken[;] and vice versa.,sewermonster,0|0,Rules.addplayerinnatestatus(~ncr_drainmonster_helper~); Rules.addenemyinnatestatus(~ncr_drainmonster_helper~);,YES
Yolanda?,Get [gold]20 gold[;] now. Beating enemies|makes you lose gold.,*shop,-90|-60,if(self.getvar(~ncryolandaapplied~) == 0 # self.getvar(~ncryolandaapplied~) == ~0~ ) { self.gold += 20; self.setvar(~ncryolandaapplied~|true); } Rules.addextrascript(~if(self.gold > 0) { target.gold-= 2; } ~[;] ~startcombat~); Rules.addextrascript(~if(self.gold < 0) { self.gold = 0; }~[;] ~aftercombat~);,YES
Val?,Replace everything currently equipped|with random items of the same color.,*tradingpost,-75|-80,var eqlist = []; if(self.equipment.length > 0) {  for(eq in self.equipment) {   if(eq.skillcard == ~~) {    eqlist.push(eq);   }  }  var exceptions = [~skillcard~|~excludefromrandomlists~|~alternateversion~|~robotonly~|~witchonly~|~inventoronly~];  if(self.usecpuinsteadofdice) exceptions.remove(~robotonly~);  if(self.getskillcard() != null && self.getskillcard().skillcard == ~witch~) exceptions.remove(~witchonly~);  if(self.getskillcard() != null && self.getskillcard().skillcard == ~inventor~) exceptions.remove(~inventoronly~);  var allbigeq = shuffle(getequipmentlist(null|['large']|exceptions));  var allsmalleq = shuffle(getequipmentlist(null|['small']|exceptions));  for(eq in eqlist) {   var alleq = allsmalleq;   if(eq.size > 1) var alleq = allbigeq;   var neweq = '';   var i = 0;   trace(eq.name);   while(neweq == '') {    trace(i);    trace(alleq[i]);    if(new elements.Equipment(alleq[i]).equipmentcol == eq.equipmentcol) {     neweq = alleq[i];     alleq.remove(neweq);     trace('worked!');     break;    }    i++;    if(i >= alleq.length) break;   }   eq.name = ~blahdeleteme~;   giveequipment(neweq|false|false);   removeequipment(~blahdeleteme~);  } } /*mq has a rule like this (but without the colour part); but mq was still unreleased when the first version of ncrmod with this rule came out; so i don't know if this was me accidentally copying mystic or mystic accidentally copying me*/,NO
Sorceress?,Enemy rolls are fixed and|in descending order.,sorceress,0|0,Rules.stackenemydice([[6[;] 5[;] 4[;] 3[;] 2[;] 1]][;] false);,YES
Wizard?,Enemies get a random spell|from the Wizard's spellbook.,wizard,-50|-20,Rules.addextrascript(~var newwizardspell = rand([\~Freeze Spell\~|\~Flame Spell\~|\~Poison Spell\~|\~Thunder Spell\~|\~Teleport Spell\~|\~Hall of Mirrors\~]); if(target.name == \~Scathach\~) { newwizardspell = \~Hall of Mirrors\~; } if (target.spaceleft() >= 1 && target.name != \~Wizard\~ && target.name != \~Super Wizard\~) { var spelleq = new elements.Equipment(newwizardspell); spelleq.script = \~bonus(5000); \~ + spelleq.script; target.equipment.push(spelleq); }~[;] ~startcombat~); //if scathach got anything but hom it would be kinda boring because most of the wiz spells are objectively worse to her equipment,YES
Buster?,On the first turn of every fight[;]|one of your items errors out.,dragon,-130|-60,Rules.addplayerinnatestatus(~ncr_error~[;] 1[;] true);,YES
Vacuum?,On the enemy's first turn[;] they|drain health on every attack.,vacuum,-100|50,Rules.addextrascript(~if(turn == 1) { for(eq in target.equipment) { target.setvar(\~originalscript\~ + eq.name|eq.script); if(eq.script.split(\~attack(\~).length > 1) { eq.script = eq.script.split(\~drain(\~).join(\~/*NCR SPAM HUMBUG*/drain(\~); eq.script = eq.script.split(\~attack(\~).join(\~drain(\~); eq.script = eq.script.split(\~drainself(\~).join(\~attackself(\~); eq.script = eq.script.split(\~piercedrain(\~).join(\~pierceattack(\~); eq.script = eq.script.split(\~drain(\~).join(\~sfx(\\\~_drain\\\~); drain(\~); } } } if(turn == 2) { for(eq in target.equipment) { eq.script = eq.script.split(\~drain(\~).join(\~attack(\~); eq.script = eq.script.split(\~/*NCR SPAM HUMBUG*/attack(\~).join(\~drain(\~); eq.scriptrunner = null; } } ~[;] ~beforestartturn~);,YES
Copycat?,For the 1st turn of each fight[;]|you have the enemy's equipment.,copycat,0|0,Rules.addextrascript(~  if(target.name != 'Copycat') { /*if target is copycat you're just copying your own equipment! this doesn't lead to any bugs (this 'before combat' script runs *after* fighters' 'before combat' scripts) but it does cause 'your' countdowns to reset when your turn's done. heck you could argue this isn't a bug; this is a feature.*/   for(eq in self.equipment) {    eq.removetag('ncr_copycathide');    if(eq.skillcard == '') {     eq.scriptbeforecombat = '/*ncr copycat disable before combat script*/ //' + eq.scriptbeforecombat;     eq.usedthisbattle = true;     eq.onceperbattle = true;     eq.addtag('ncr_copycathide');    }   }   for(eq in target.equipment) {    var copiedeq = new elements.Equipment(eq.name|eq.upgraded|false|true);    if(copiedeq.name == 'Mystery Box' && target.name == 'Mimic') {     copiedeq = new elements.Equipment(rand(loadtext('diceydungeons/mysterybox'))|eq.upgraded|false|true);    }    copiedeq.equippedby = self;    self.equipment.push(copiedeq);    copiedeq.temporary_thisturnonly = true;   }   self.fixskillcard();   var showneq = [for(eq in self.equipment) if(!eq.hastag('ncr_copycathide')) eq];   if(self.getskillcard() != null) {    showneq.remove(self.getskillcard());    showneq.push(self.getskillcard()); /*make sure skillcard is at the end of the list*/   }   var space = 8;   for(eq in showneq) space -= eq.size;   while(space < 0) {    showneq[0].name = 'ncrsaysdeletethis';    showneq.shift();    removeequipment('ncrsaysdeletethis');    space = 8;    for(eq in showneq) space -= eq.size;   }   for(eq in showneq) eq.resetfornewturn('player');  } ~[;]~startcombat~); Rules.addextrascript(~  for(eq in self.equipment) if(eq.scriptbeforecombat.indexOf('/*ncr copycat disable before combat script*/ //') != -1) eq.scriptbeforecombat = eq.scriptbeforecombat.split('/*ncr copycat disable before combat script*/ //').join('');  if(turn == 1 && target.hp > 0) {   if(self.name == 'Bear' && !self.varexists('copycattransformkludge')) {    for(eq in self.equipment) {     eq.addtag('ncr_copycathide');    }    self.setvar('copycattransformkludge'|true);   }   for(eq in self.equipment) {    if(eq.hastag('ncr_copycathide')) {     eq.usedthisbattle = false;     eq.onceperbattle = false;     eq.removetag('ncr_copycathide');     var dobc = new elements.Skill('Against all odds_old');     self.setvar('thiseq'|eq);     dobc.script = 'var e = self.getvar(\~thiseq\~); ' + eq.scriptbeforecombat;     dobc.execute(self|target);     self.resetvar('thiseq');    } else {     if(eq.skillcard == '') eq.name = 'ncrsaysdeletethis';    }   }   removeequipment('ncrsaysdeletethis');  }  if(turn == 1 && target.hp <= 0) self.setvar('copycatkillturn1kludge'|true); ~[;]~endturn~); Rules.addextrascript(~  if(self.varexists('copycatkillturn1kludge')) {   if(self.name == 'Bear' && !self.varexists('copycattransformkludge')) {    for(eq in self.equipment) {     eq.addtag('ncr_copycathide');    }    self.setvar('copycattransformkludge'|true);   }   for(eq in self.equipment) {    if(eq.hastag('ncr_copycathide')) {     eq.usedthisbattle = false;     eq.onceperbattle = false;     eq.removetag('ncr_copycathide');    } else {     if(eq.skillcard == '') eq.name = 'ncrsaysdeletethis';    }   }   removeequipment('ncrsaysdeletethis');  }  self.resetvar('copycatkillturn1kludge'); ~[;]~aftercombat~);,YES
Keymaster?,Split your highest dice|at the start of every turn.,keymaster,-30|-40,Rules.addextrascript(~var dicelist = []; if(self.dicepool.length > 0) { for(mydice in self.dicepool) { if(mydice.available()) { dicelist.push(mydice); } } if(dicelist.length > 0) { dicelist.sort(function(a|b) return -(a.basevalue - b.basevalue)); dicelist[0].removedice(self.screenposition()); givedice(split(dicelist[0].basevalue)); sfx(\~splitdice\~); sfx(\~_lock\~); } } if(self.dicepool.length == 0 # dicelist.length == 0) { trace(\~starting keymaster? actuator\~); var tw = new motion.actuators.SimpleActuator(null|1/60|null); tw._repeat = -1; var s = new elements.Skill(\~Against all odds_old\~); s.script = \~  if(self.hp <= 0 # self.graphic == null # target == null # target.graphic == null # target.hp <= 0) {   trace(\\\~fight over; keymaster actuator stopped\\\~);   self.getvar(\\\~keymasteractuator\\\~).stop();   self.resetvar(\\\~keymasteractuator\\\~);  }  else {   var dicelist = [];   if(self.dicepool.length > 0) {    for(mydice in self.dicepool) {     if(mydice.available() && !mydice.intween()) {      dicelist.push(mydice);     }    }    if(dicelist.length > 0) {     dicelist.sort(function(a|b) return -(a.basevalue - b.basevalue));     dicelist[0].removedice(self.screenposition());     givedice(split(dicelist[0].basevalue));     sfx(\\\~splitdice\\\~);     sfx(\\\~_lock\\\~);     trace(\\\~found splittable dice; keymaster actuator stopped\\\~);     self.getvar(\\\~keymasteractuator\\\~).stop();     self.resetvar(\\\~keymasteractuator\\\~);    }   }  } \~; s.execute(self|target); tw.onRepeat(s.execute|[self|target]); self.setvar(\~keymasteractuator\~|tw); tw.move(); }~[;] ~onstartturn~);,YES
Ned?,Upgrade everything currently equipped[;]|except items that get bigger.,*anvil,-75|15,var exceptions = []; var eqlist = []; if(self.equipment.length > 0) { for(eq in self.equipment) { var eqtest = new elements.Equipment(eq.name + ~+~); if(eqtest.size <= eq.size && eq.skillcard == ~~ && !eq.upgraded && eq.upgradetype != ~~ && exceptions.indexOf(eq.name) == -1) { eqlist.push(eq); } eqtest.name = ~blahdeleteme~; self.equipment.push(eqtest); removeequipment(~blahdeleteme~); } for(eq in eqlist) { var neweq = eq.name + ~+~; eq.name = ~blahdeleteme~; removeequipment(~blahdeleteme~); giveequipment(neweq|false|false); } },NO
Kraken?,Inflict [blind]Blind_all on|everyone[;] every turn.,kraken,-80|-60,Rules.addextrascript('var red = getstatusself(~alternate_reduce~); removestatusself(~alternate_reduce~|999); if(self.usecpuinsteadofdice) { var hasblind = false; if(self.status.length > 0) { for(stat in self.status) { if(stat.type == ~blind~ # stat.type == ~alternate_blind~) { stat.value = 999; hasblind = true; } } } if(!hasblind) { inflictself(BLIND|999); if(red > 0) { inflictself(~alternate_reduce~|red); } } } else { inflictself(BLIND|self.dice + self.extradice + self.bonusdice); if(red > 0) { inflictself(~alternate_reduce~|red); } }'[;] ~beforestartturn~); Rules.addextrascript(~target.scriptbeforestartturn = \~var red = getstatusself(\\\~alternate_reduce\\\~); removestatusself(\\\~alternate_reduce\\\~|999); inflictself(BLIND|self.dice + self.extradice + self.bonusdice); if(self.innate.length > 0) for(myinnate in self.innate) { if(myinnate == \\\~gaindice\\\~) { inflictself(BLIND); } } if(red > 0) { inflictself(\\\~alternate_reduce\\\~|red); }\~ + target.scriptbeforestartturn;~[;] ~startcombat~);,YES
Skeleton?,Take [sword]10 damage[;] immediately.|(This won't kill you.),skeleton,-20|-80,var myhp = self.hp; if(self.hp <= 10) { self.hp = 1; } else { self.hp -= 10; } sfxdamage(self|10); if(myhp <= 10) { self.limitvalue += myhp - 1; } else { self.limitvalue += 10; } if(self.limitvalue > self.limitmax) self.limitvalue = self.limitmax; screenshake();,NO
Cornelius?,Enemies gain an additional dice|every turn.,cornelius,0|-40,Rules.addextrascript(~if (target.innate.indexOf(\~gaindice\~) == -1) { target.innate.push(\~gaindice\~); } if(target.dice != 0) { target.dice--; }~[;] ~startcombat~);,YES
Aurora?,After enemy's turn[;] they heal [heal]1|per status they inflicted on you.,weathergoddess,0|0,Rules.addextrascript(~if(self.isplayer) { var statii = []; var statvalues = []; if(self.status.length > 0) { for(mystat in self.status) { if(mystat.invisible != true) { statii.push(mystat.type); if(mystat.type == \~poison\~ # \~alternate_poison\~) { statvalues.push(mystat.value + 1); } else { statvalues.push(mystat.value); } } } } self.setvar(\~ncr__statii\~|statii); self.setvar(\~ncr__statvalues\~|statvalues); } else { var statii = []; var statvalues = []; if(target.status.length > 0) { for(mystat in target.status) if(mystat.invisible != true) { { statii.push(mystat.type); if(mystat.type == \~poison\~ # \~alternate_poison\~) { statvalues.push(mystat.value + 1); } else { statvalues.push(mystat.value); } } } } target.setvar(\~ncr__statii\~|statii); target.setvar(\~ncr__statvalues\~|statvalues); } ~[;] ~endturn~); Rules.addextrascript(~var newstatii = []; var newstatvalues = []; var oldvalue = 0; var newvalue = 0; if(self.status.length > 0) { for(mystat in self.status) { if(mystat.invisible != true) { newstatii.push(mystat.type); newstatvalues.push(mystat.value); } } } var statii = self.getvar(\~ncr__statii\~); var statvalues = self.getvar(\~ncr__statvalues\~); var healtotal = 0; if(newstatii.length > 0) { for(mystattype in newstatii) { if(statii.length > 0 && statii.indexOf(mystattype) != -1) { oldvalue = statvalues[statii.indexOf(mystattype)]; } else { donothing(); } newvalue = newstatvalues[newstatii.indexOf(mystattype)]; var add = newvalue - oldvalue; if(add > 0) { healtotal += add; } } } if(healtotal > 0) { sfx(\~_heal\~); attack(-healtotal); } self.setvar(\~ncr__statii\~|0); self.setvar(\~ncr_statvalues\~|0); ~[;] ~beforestartturn~); //localized entirely in your dungeon?,YES
Rhino Beetle?,Take [sword]1 for every four items|you use each turn.,beetlewarrior,0|0,Rules.addextrascript(~if((self.equipmentused % 4 == 0) && (self.equipmentused > 0)) { attackself(1); sfxdamage(self|1); sfx(\~rhinogrunt\~); }~[;] ~playerequipmentuse~); ,YES
Space Marine?,Every time you use an item[;]|nudge a random dice.,spacemarine,-30|-10,Rules.addextrascript(~if(self.dicepool.length > 0) { self.setvar('equsedcheck'|self.getvar('equsedcheck') + 1); if(self.getvar('equsedcheck') > self.equipmentused) { self.setvar('equsedcheck'|self.getvar('equsedcheck') - 1); } else { var nudgelist = [for(dice in self.dicepool) if(dice.basevalue > 1 && dice.available() && !dice.intween()) dice]; if(nudgelist.length > 0) { var nudgedice = rand(nudgelist); nudgedice.animatereroll(nudgedice.basevalue - 1 | self.screenposition()); } } }~[;] ~playerequipmentuse~); Rules.addextrascript(~self.setvar('equsedcheck'|0);~[;] ~beforestartturn~); /*the equsedcheck thing is for toolbox; which actually counts as an equipment use when you put a 1 or 6 in it but visually appears as though it hasn't been used. i need to do it for other rules as well or come up with a way to have the ghost card not activate any on equipment use scripts (or not activate at all). whatever*/,YES
Scathach?,You are [silence]Silenced on|the first turn of every fight.,scahatch,-60|-30,Rules.addplayerinnatestatus(SILENCE[;] 1[;] true);,YES
Aoife?,Enemies get [shield]4 shield|every other turn.,knight,0|-30,Rules.addextrascript(~if(turn % 2 == 0) { if(target.hp > 0) { inflict(SHIELD|4); } }~[;] ~endturn~);,YES
Handyman?,Replace anvils with blueprints.,handyman,-30|-10,Rules.substitute(~upgrade~[;] ~copyshop~);,YES
Fireman?,Dice of a certain number instantly ignite.|That number changes each turn.,fireman,-20|-30,Rules.ignitedice = true; Rules.addextrascript(~Rules.igniterange = [rand([1|2|3|4|5|6])];~[;] ~beforestartturn~); Rules.addextrascript(~if(target.hp > 0) Rules.igniterange = [rand([1|2|3|4|5|6])];~[;] ~endturn~);,YES
Cowboy?,Enemies' starting rolls will|never be less than 3.,cowboy,10|0,Rules.enemydicerange([3[;] 4[;] 5[;] 6]); /*for the longest time i forgot this actually was a rule in a beta version: https://i.frogbox.es/mai think it was taken out before any builds were sent with it in though. wonder why it got removed?*/,YES
Alchemist?,After odd turns[;] recover [heal]2 health.|After even turns[;] take [sword]2 damage.,potionmixer,-20|-70,Rules.addextrascript(~if(target.hp > 0) { if(turn % 2 == 1) { attackself(-2); sfx(\~_heal\~); } else { attackself(2); sfxdamage(self|2); } sfx(\~alchgrunt\~); }~[;] ~endturn~);,YES
Singer?,After using one equipment[;]|all your dice are rerolled.,singer,-20|0,Rules.addextrascript(~if(self.getvar(\~ncrsingerreroll\~) != 1) { var c = 0; for (mydice in self.dicepool){ if (mydice.available() && !mydice.intween() && target.hp > 0){ mydice.animatereroll(rand([1|2|3|4|5|6])| self.screenposition()| c * 0.05); c++; } } self.setvar(\~ncrsingerreroll\~|1); }~[;] ~playerequipmentuse~); Rules.addextrascript(~self.setvar(\~ncrsingerreroll\~|0);~[;] ~beforestartturn~);,YES
Mimic?,You are always [confuse]Confused[].,mimic,,var confusescript = ~if(getstatusself(CONFUSE) < 1) { inflictself(CONFUSE); for(stat in self.status) { if(stat.type == \~confuse\~ # stat.type == \~alternate_confuse\~) { stat.remove_at_endturn = false; stat.remove_at_startturn = false; } } }~; Rules.addextrascript(confusescript[;] ~endturn~); Rules.addextrascript(confusescript[;] ~startcombat~);,YES
Magician?,Your limit break is randomized|every turn.,streetmagician,0|-40,Rules.addextrascript(~if(target.hp > 0) { var skilllist = loadtext(\~ncrmod/magicianlimitbreaks\~); if(target.dice + target.extradice > 1 && self.dice + self.extradice > 1) { skilllist.push(\~Plexiglass\~); } if(self.layout == \~DECK\~) { skilllist.push(\~Snap!\~); skilllist.push(\~Match 3\~); } if(self.usecpuinsteadofdice) { skilllist.push(\~Autoroll\~); skilllist.push(\~Jackpot\~); skilllist.push(\~Disk Cleanup\~); } if(self.getvar(\~uptick\~) >= 1 && self.getvar(\~uptick\~) <= 6) { skilllist.push(\~Trips\~); } self.changelimitbreak(rand(skilllist)); } ~[;] ~endturn~); Rules.addextrascript(~var skilllist = loadtext(\~ncrmod/magicianlimitbreaks\~); if(target.dice + target.extradice > 1 && self.dice + self.extradice > 1) { skilllist.push(\~Plexiglass\~); } if(self.layout == \~DECK\~) { skilllist.push(\~Snap!\~); skilllist.push(\~Match 3\~); } if(self.usecpuinsteadofdice) { skilllist.push(\~Autoroll\~); skilllist.push(\~Jackpot\~); skilllist.push(\~Disk Cleanup\~); } if(self.getvar(\~uptick\~) >= 1 && self.getvar(\~uptick\~) <= 6) { skilllist.push(\~Trips\~); } self.changelimitbreak(rand(skilllist)); ~[;] ~startcombat~);,YES
Rat King?,Every fight[;] a random|enemy item is upgraded.,ratking,-60|-10,if(self.getvar(~ncrratkingapplied~) == 0) { self.setvar(~ncrratkingapplied~|true); self.setvar(~ratseenenemies~|[]); } Rules.addextrascript(~var ratseenenemies = self.getvar(\~ratseenenemies\~); trace(ratseenenemies); if(turn == 1) { var eqlist = []; if(target.equipment.length > 0 && ratseenenemies.indexOf(target.name) == -1) { for(eq in target.equipment) { var eqtest = new elements.Equipment(eq.name + \~+\~); if(eq.namemodifier != \~+\~ && eq.upgradetype != \~\~ && eq.size == eqtest.size) { eqlist.push(eq); } eqtest.name = \~blahdeleteme\~; target.equipment.push(eqtest); removeequipment(\~blahdeleteme\~ + eqtest.namemodifier|target); } var upeq = rand(eqlist); var upeqname = upeq.name; giveenemyequipment(upeq.name + \~+\~|false|false|upeq); upeq.name = \~deletemeaaaa\~; removeequipment(\~deletemeaaaa\~ + upeq.namemodifier|target); ratseenenemies.push(target.name); self.setvar(\~ratseenenemies\~|ratseenenemies); if(self.stolencard != null && self.stolencard.name == upeqname) { var chance = 100; var eqcount = 0; for(eq in target.equipment) { if(eq.name == upeqname) { eqcount++; } } if(eqcount == 0) eqcount = 1; chance = chance/eqcount; if(chance) { var oldx = self.stolencard.x; var oldy = self.stolencard.y; self.stolencard.create(upeqname|true|false|true); self.stolencard.x = oldx; self.stolencard.y = oldy; self.stolencard.stolencard = true; } } } } ~[;] ~beforestartturn~); Rules.addextrascript(~target.scriptbeforestartturn = \~var ratseenenemies = target.getvar(\\\~ratseenenemies\\\~); trace(turn); if(turn == 0) /*turn is 0 when sticky hands goes first. probably.*/ { var eqlist = []; if(self.equipment.length > 0 && ratseenenemies.indexOf(self.name) == -1) { for(eq in self.equipment) { if(eq.namemodifier != \\\~+\\\~ && eq.upgradetype != \\\~\\\~) { eqlist.push(eq); } } var upeq = rand(eqlist); giveequipment(upeq.name + \\\~+\\\~|false|false|upeq); upeq.name = \\\~deletemeaaaa\\\~; removeequipment(\\\~deletemeaaaa\\\~ + upeq.namemodifier); ratseenenemies.push(self.name); target.setvar(\\\~ratseenenemies\\\~|ratseenenemies); } } \~ + target.scriptbeforestartturn;~[;] ~startcombat~);,YES
Copycat? old,At the start of each fight[;] permanently|swap a random item with the enemy.,copycat,0|0,/*turns out this is basically the same thing as thief episode 2 in megquest. i made this rule while megaquest was still under heavy development so i have no idea if mystic got there before me or not. one way or another i need to avoid stealing accusations -- also this is just super jank in general*/ if(self.getvar(~ncrcopycatapplied~) == 0) { trace(~thingsetting~); self.setvar(~ncrcopycatapplied~|true); self.setvar(~copycatseenenemies~|[]); } Rules.addextrascript(~trace(\~yo... yo\~); var seenenemies = self.getvar(\~copycatseenenemies\~); if(turn == 1 && seenenemies.indexOf(target.name) == -1) { trace(\~now im in here\~); var myeqs = []; var mybigeqs = []; var mysmalleqs = []; var theireqs = []; var theirbigeqs = []; var theirsmalleqs = []; var mychoseneq = \~\~; var theirchoseneq = \~\~; if(self.equipment.length > 0) { for(eq in self.equipment) { if(eq.skillcard == \~\~ && eq.name != \~Wooden Stake\~ && eq.name != \~Steel Sword\~ && eq.name != \~Wooden Stake?\~ && eq.name != \~Steel Sword?\~ ) { myeqs.push(eq); if(eq.size == 1) { trace(\~small-pushed \~ + eq.name); mysmalleqs.push(eq); } else { trace(\~big-pushed \~ + eq.name); mybigeqs.push(eq); } } } } if(target.equipment.length > 0) { for(eq in target.equipment) { if(!(eq.onceperbattle && eq.usedthisbattle) && eq.skillcard == \~\~ && eq.name != \~The Storm\~ /*evil kludge to remove the 1/6 possibility of scathach being a complete pushover. when shock isn't alternate; anyway. would do the same to audrey & earthquake but that would be far too obvious - plus audrey can at least still do something if you use earthquake*/) { theireqs.push(eq); if(eq.size == 1) { theirsmalleqs.push(eq); } else { theirbigeqs.push(eq); } } } } trace(myeqs); trace(theireqs); trace(\~hi! my name is\~); if((mysmalleqs.length == 0 && theirbigeqs.length == 0) # (mybigeqs.length == 0 && theirsmalleqs.length == 0) # (theireqs.length == 0) # (myeqs.length == 0)) { self.textparticle(\~Can't do swap!\~); } else { trace(myeqs); trace(mybigeqs); trace(mysmalleqs); trace(theireqs); trace(theirbigeqs); trace(theirsmalleqs); /*coin toss to decide who gets to determine what the other fighter's chosen eq can be. should make this more fair probability-wise.*/ if(chance(50)) { if(theirbigeqs.length == 0) { mychoseneq = rand(mysmalleqs); trace(\~yo 1\~); } else if(theirsmalleqs.length == 0) { mychoseneq = rand(mybigeqs); trace(\~yo 2\~); } else { mychoseneq = rand(myeqs); trace(\~yo 3\~); } if(mychoseneq.size == 1) { theirchoseneq = rand(theirsmalleqs); trace(\~yo 4\~); } else { theirchoseneq = rand(theirbigeqs); trace(\~hi 2\~); } } else { if(mybigeqs.length == 0) { theirchoseneq = rand(theirsmalleqs); trace(\~hi 3\~); } else if(mysmalleqs.length == 0) { theirchoseneq = rand(theirbigeqs); trace(\~hi 4\~); } else { theirchoseneq = rand(theireqs); trace(\~hi 5\~); } if(theirchoseneq.size == 1) { mychoseneq = rand(mysmalleqs); } else { mychoseneq = rand(mybigeqs); } } trace(\~super hi\~); var mychoseneqcopy = \~\~; trace(mychoseneq); trace(mychoseneq.name); mychoseneqcopy = mychoseneq.name; if(mychoseneq.namemodifier != \~-\~) { mychoseneqcopy = mychoseneqcopy + mychoseneq.namemodifier; } var theirchoseneqcopy = \~\~; trace(theirchoseneq); trace(theirchoseneq.name); theirchoseneqcopy = theirchoseneq.name; if(theirchoseneq.namemodifier != \~-\~) { theirchoseneqcopy = theirchoseneqcopy + theirchoseneq.namemodifier; } replacemewith(theirchoseneqcopy [;] -1[;] mychoseneq[;] self); giveenemyequipment(mychoseneqcopy|false|false|theirchoseneq); theirchoseneq.name = \~deletemeaaa\~; removeequipment(\~deletemeaaa\~ + theirchoseneq.namemodifier|target); seenenemies.push(target.name); self.setvar(\~copycatseenenemies\~|seenenemies);  } } ~[;] ~onstartturn~); /*note: 'fair trades' (e.g. trading pea shooter for pea shooter against handyman; or claw for claw against dire wolf) are allowed. is that a legitimate design decision or just me being lazy? yes.*/,YES
The Jester? old,Swap certain cards with their|Parallel Universe counterparts.,_jester,-90|-20,/*makes no sense because jester uses zoop zoop bop bop & veneer instead of the vanilla or pu starters*/ var cardlist = Deck.getcards(~all~); if(cardlist.length > 0 { for(c in cardlist){ if(c.equipment.name == ~Kapow~) { c.delete(); Deck.createcard(~Boop~); } else if(cardlist.length > 0 { for(c in cardlist){ if(c.equipment.name == ~Boop~) { c.delete(); Deck.createcard(~Kapow~); } else if(c.equipment.name == ~Blammo~) { c.delete(); Deck.createcard(~Bop~); } else if(c.equipment.name == ~Bop~) { c.delete(); Deck.createcard(~Blammo~); } else if(c.equipment.name == ~Sour Candy~) { c.delete(); Deck.createcard(~Sweets~); } else if(c.equipment.name == ~Sweets~) { c.delete(); Deck.createcard(~Sour Candy~); } else if(c.equipment.name == ~Call for Backup Inventor~) { c.delete(); Deck.createcard(~Call for Backup Inventor?~); } else if(c.equipment.name == ~Call for Backup Inventor?~) { c.delete(); Deck.createcard(~Call for Backup Inventor~); } else if(c.equipment.name == ~Call for Backup Thief~) { c.delete(); Deck.createcard(~Call for Backup Thief?~); } else if(c.equipment.name == ~Call for Backup Thief?~) { c.delete(); Deck.createcard(~Call for Backup Thief~); } else if(c.equipment.name == ~Call for Backup Warrior~) { c.delete(); Deck.createcard(~Call for Backup Warrior?~); } else if(c.equipment.name == ~Call for Backup Warrior?~) { c.delete(); Deck.createcard(~Call for Backup Warrior~); } else if(c.equipment.name == ~Call for Backup Robot~) { c.delete(); Deck.createcard(~Call for Backup Robot?~); } else if(c.equipment.name == ~Call for Backup Robot?~) { c.delete(); Deck.createcard(~Call for Backup Robot~); } else if(c.equipment.name == ~Call for Backup Witch~) { c.delete(); Deck.createcard(~Call for Backup Witch?~); } else if(c.equipment.name == ~Call for Backup Witch?~) { c.delete(); Deck.createcard(~Call for Backup Witch~); } } }          //Rules.swap(~Boop~[;] ~Kapow~); Rules.swap(~Bop~[;] ~Blammo~); Rules.swap(~Sweets~[;] ~Sour Candy~); Rules.swap(~Call for Backup Inventor~[;] ~Call for Backup Inventor?~); Rules.swap(~Call for Backup Warrior~[;] ~Call for Backup Warrior?~); Rules.swap(~Call for Backup Thief~[;] ~Call for Backup Thief?~); Rules.swap(~Call for Backup Witch~[;] ~Call for Backup Witch?~); Rules.swap(~Call for Backup Robot~[;] ~Call for Backup Robot?~);,YES
