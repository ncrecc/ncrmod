Name,Description,Image,ImageOffset,Implemented,Rule Change,Apply On Continue
The Inventor?,All chest contents are duplicated[;] but|you must make two gadgets per battle.,_inventor,-90|-40,YES,Rules.inventor_setgadgets(2); Rules.doublechests = true; ,YES
Marshmallow?,On odd turns[;] your initial rolls are odd.|On even turns[;] your initial rolls are even.,marshmallow,10|-10,YES,Rules.addextrascript(~if(turn % 2 == 1) { Rules.playerdicerange([1[;] 3[;] 5]); } else { Rules.playerdicerange([2[;] 4[;] 6]); }~[;] ~beforestartturn~);,YES
Rotten Apple?,Gain [heart]5[] max health[;] but|lose 1 after each fight.,applemimic,0|0,YES,if(self.getvar(~ncrappleapplied~) == 0) { self.maxhp += 5; self.hp += 5; self.setvar(~ncrappleapplied~|true); } Rules.addextrascript(~if(self.maxhp > 1) { self.maxhp -= 1; if(self.hp > self.maxhp) { self.hp = self.maxhp; } }~[;] ~aftercombat~);,YES
Wisp?,Swap all [vanish]Vanish equipment for|[fire]Fire equipment[;] and vice versa.,wisp,20|-60,YES,Rules.swap(~Flame Spell~[;] ~Illusion Spell~); Rules.swap(~Fireball~[;] ~Energy Ball~); Rules.swap(~Burning Light~[;] ~Sheer Will~); Rules.swap(~Staff~[;] ~Sceptre~); Rules.swap(~Inferno~[;] ~Pure Energy~); Rules.swap(~Meteor~[;] ~Ritual Sacrifice~); Rules.swap(~Crucible~[;] ~Spectral Cauldron~); Rules.swap(~The Ashes~[;] ~The Grave~); Rules.swap(~Whip~[;] ~Sleight of Hand~); Rules.swap(~Spark~[;] ~Flicker~); Rules.swap(~Sunburn~[;] ~Light Pillar~); Rules.swap(~Heatwave~[;] ~Mist~); Rules.swap(~Fire Breath~[;] ~Thick Fumes~); Rules.swap(~Flamethrower~[;] ~Proton Pack~); Rules.swap(~Matchstick~[;] ~Soul Jar~); Rules.swap(~Fire Potion~[;] ~Milky Potion~); Rules.swap(~Campfire~[;] ~Ouija Board~); Rules.swap(~Flame Blast~[;] ~Psychic Blast~); Rules.swap(~Ignite~[;] ~Shudder~); Rules.swap(~Flaming Sword~[;] ~Spirit Sword~); Rules.swap(~Mercy~[;] ~Boo~); Rules.swap(~Lighter~[;] ~Blacklight~); Rules.swap(~Molotov Cocktail~[;] ~Ectoplasm~); Rules.swap(~Cannon Fire~[;] ~St. Elmo's Fire~); Rules.swap(~Wicker Staff~[;] ~Wicked Sceptre~); Rules.swap(~Scrap Kettle~[;] ~Haunted Teapot~); Rules.swap(~Fire Age~[;] ~Mirage~); Rules.swap(~Soul Shatter~[;] ~Flame Shatter~); Rules.swap(~Shocking Horror~[;] ~Pitchfork~); Rules.swap(~Cremator~[;] ~Furnace~); Rules.swap(~Fool's Fire~[;] ~Undying Flame~); Rules.swap(~Hell's Bells~[;] ~Magic Pipe~); Rules.swap(~Whisp@F~[;] ~Wisper@V~); Rules.swap(~Whisp@W~[;] ~Wisper@W~); Rules.swap(~PyrotechnIX~[;] ~Timeghost~); Rules.swap(~Heat Pump~[;] ~Muon Containment Trap~); Rules.swap(~Whipcrack~[;] ~Gaslighting~); Rules.swap(~Hexagram~[;] ~Hot Table~); Rules.swap(~Matchbox~[;] ~Invocation Ritual~); Rules.swap(~Swamp Gas~[;] ~Carbon Monoxide~); Rules.swap(~Smoke Machine~[;] ~Chainsmoke~); Rules.swap(~Scrapstick~[;] ~Scrap Souls~); Rules.swap(~Undying Flame~[;] ~Fool's Fire~);  Rules.swap(~Bustin' Makes Me Feel Good~[;] ~Explosive Overclocking~); Rules.swap(~Ashes to Ashes~[;] ~Bite the Dust~);,YES
The Robot?,Expand the Jackpot reward pool.,_robot,-90|-20,YES,Rules.jackpotskills = [~One More Roll~|~Regenerate~|~Lucky Shot~|~Barricade~|~Snake Eyes~|~Firebomb~|~Protection~|~Refrigerator~|~Flashbang~|~Stardust~|~Steal~|~Megabump~|~Reroll~|~Flash Freeze~|~Replicate~|~Mumble~|~Blood Sip~|~Drunken Boxing~|~Install Evony~|~impulse 101~|~Obfuscate~|~Proximity Mine~]; Rules.jackpotskills_lowodds = [~Fury~|~Teleport~|~Hook~|~Bear Smash~|~Jackhammer~|~Heat Ray~|~Oh No!~|~Clone Device~|~Magic Six~|~Arctic Storm~|~Briar Bush~|~Quick Thinking~|~Light Switch~|~Megaflip~|~Dramatic Pause~|~Rod~|~Deep Breath~];,YES
The Warrior?,Your skillcard changes to another|dice manipulator every turn.,_warrior,-90|-20,YES,if(self.getvar(~ncrthewarriorapplied~) == 0) { self.setvar(~ncrthewarrior_skillcardpool~|[~Combat Roll~|~Combat Spatula~|~Combat Slam~|~Combat Key~|~Combat Bulb~|~Combat Tweak~|~Combat Bump~|~Combat Grip~|~Combat Doppel~|~Combat Mirror~|~Combat Gumball~|~Combat Gold~|~Combat Silver~|~Combat Flip~|~Combat Ungerade~|~Combat Spanner~|~Combat Calculate~|~Combat Keyhole~|~Combat Scroll~|~Combat Innovate~|~Combat Crucible~|~Combat Murk~]); trace(self.getvar(~ncrthewarrior_skillcardpool~)); self.setvar(~ncrthewarriorapplied~|true); } Rules.addextrascript(~if(self.isplayer) { trace(self.getvar(\~ncrthewarrior_skillcardpool\~)); var skillcardpool = self.getvar(\~ncrthewarrior_skillcardpool\~); trace(self.getvar(\~ncrthewarrior_skillcardpool\~)); trace(skillcardpool); var skillpick = rand(skillcardpool); trace(skillpick); self.replaceskillcard(skillpick); trace(\~replaced ok\~); skillcardpool.remove(skillpick); trace(\~removed ok\~); if(skillcardpool.length > 0) { self.setvar(\~ncrthewarrior_skillcardpool\~|skillcardpool); trace(\~skillcardpoold ok\~); } else { self.setvar(\~ncrthewarrior_skillcardpool\~|[\~Combat Roll\~|\~Combat Spatula\~|\~Combat Slam\~|\~Combat Key\~|\~Combat Bulb\~|\~Combat Tweak\~|\~Combat Bump\~|\~Combat Grip\~|\~Combat Doppel\~|\~Combat Mirror\~|\~Combat Gumball\~|\~Combat Gold\~|\~Combat Silver\~|\~Combat Flip\~|\~Combat Ungerade\~|\~Combat Spanner\~|\~Combat Calculate\~|\~Combat Keyhole\~|\~Combat Scroll\~|\~Combat Innovate\~|\~Combat Crucible\~|\~Combat Murk\~]); self.getskillcard().allowupdatereusabledescription = true; self.getskillcard().updatereuseabledescription(); } } /* else { trace(target.getvar(\~ncrthewarrior_skillcardpool\~)); var skillcardpool = target.getvar(\~ncrthewarrior_skillcardpool\~); trace(target.getvar(\~ncrthewarrior_skillcardpool\~)); trace(skillcardpool); var skillpick = rand(skillcardpool); trace(skillpick); target.replaceskillcard(skillpick); trace(\~replaced ok\~); skillcardpool.remove(skillpick); trace(\~removed ok\~); if(skillcardpool.length > 0) { target.setvar(\~ncrthewarrior_skillcardpool\~|skillcardpool); trace(\~skillcardpoold ok\~); } else { target.setvar(\~ncrthewarrior_skillcardpool\~|[\~Combat Roll\~|\~Combat Spatula\~|\~Combat Slam\~|\~Combat Key\~|\~Combat Bulb\~|\~Combat Tweak\~|\~Combat Bump\~|\~Combat Grip\~|\~Combat Doppel\~|\~Combat Mirror\~|\~Combat Gumball\~|\~Combat Gold\~|\~Combat Silver\~|\~Combat Flip\~|\~Combat Ungerade\~|\~Combat Spanner\~|\~Combat Calculate\~|\~Combat Keyhole\~|\~Combat Scroll\~|\~Combat Innovate\~|\~Combat Crucible\~|\~Combat Murk\~]); target.getskillcard().allowupdatereusabledescription = true; target.getskillcard().updatereuseabledescription(); } }*/ ~[;] ~beforestartturn~);,YES
The Exit?,Lose [heart]10[] max health[;] but|you won't get any more rules.,*exit,-90|-50,NO,//this might never work since disabling rules.remix also disables; surprise; the rules screen and the rules indicator on the top-left corner; which is pretty awkward. if(self.getvar(~ncrtheexitapplied~) != true) { self.maxhp -= 10; if(self.hp > self.maxhp) { self.hp = self.maxhp; } } self.setvar(~ncrtheexitapplied~|true); } Rules.remix = false;,YES
Buster?,Jackpot rewards are now static.,dragon,-130|-60,YES,var jacklist = Rules.jackpotskills; var rarejacklist = Rules.jackpotskills_lowodds; var chosenjacks = []; for(i in 0...3) { if(chance(80)) { chosenjacks.push(rand(jacklist)); jacklist.remove(chosenjacks[i]); } else { chosenjacks.push(rand(rarejacklist)); rarejacklist.remove(chosenjacks[i]); } } Rules.jackpotskills = chosenjacks; Rules.jackpotskills_lowodds = [];,YES
The Jester?,Swap certain cards with their|Parallel Universe counterparts.,_jester,-90|-20,YES,Rules.swap(~Boop~[;] ~Kapow~); Rules.swap(~Bop~[;] ~Blammo~); Rules.swap(~Sweets~[;] ~Sour Candy~); Rules.swap(~Call for Backup Inventor~[;] ~Call for Backup Inventor?~); Rules.swap(~Call for Backup Warrior~[;] ~Call for Backup Warrior?~); Rules.swap(~Call for Backup Thief~[;] ~Call for Backup Thief?~); Rules.swap(~Call for Backup Witch~[;] ~Call for Backup Witch?~); Rules.swap(~Call for Backup Robot~[;] ~Call for Backup Robot?~);     //var cardlist = Deck.getcards(~all~); if(cardlist.length > 0 { for(c in cardlist){ if(c.equipment.name == ~Kapow~) { c.delete(); Deck.createcard(~Boop~); } else if(cardlist.length > 0 { for(c in cardlist){ if(c.equipment.name == ~Boop~) { c.delete(); Deck.createcard(~Kapow~); } else if(c.equipment.name == ~Blammo~) { c.delete(); Deck.createcard(~Bop~); } else if(c.equipment.name == ~Bop~) { c.delete(); Deck.createcard(~Blammo~); } else if(c.equipment.name == ~Sour Candy~) { c.delete(); Deck.createcard(~Sweets~); } else if(c.equipment.name == ~Sweets~) { c.delete(); Deck.createcard(~Sour Candy~); } else if(c.equipment.name == ~Call for Backup Inventor~) { c.delete(); Deck.createcard(~Call for Backup Inventor?~); } else if(c.equipment.name == ~Call for Backup Inventor?~) { c.delete(); Deck.createcard(~Call for Backup Inventor~); } else if(c.equipment.name == ~Call for Backup Thief~) { c.delete(); Deck.createcard(~Call for Backup Thief?~); } else if(c.equipment.name == ~Call for Backup Thief?~) { c.delete(); Deck.createcard(~Call for Backup Thief~); } else if(c.equipment.name == ~Call for Backup Warrior~) { c.delete(); Deck.createcard(~Call for Backup Warrior?~); } else if(c.equipment.name == ~Call for Backup Warrior?~) { c.delete(); Deck.createcard(~Call for Backup Warrior~); } else if(c.equipment.name == ~Call for Backup Robot~) { c.delete(); Deck.createcard(~Call for Backup Robot?~); } else if(c.equipment.name == ~Call for Backup Robot?~) { c.delete(); Deck.createcard(~Call for Backup Robot~); } else if(c.equipment.name == ~Call for Backup Witch~) { c.delete(); Deck.createcard(~Call for Backup Witch?~); } else if(c.equipment.name == ~Call for Backup Witch?~) { c.delete(); Deck.createcard(~Call for Backup Witch~); } } },YES
The Thief?,Switch to [quote]Uptick[quote] rules.,_thief,-90|-20,YES,if(self.getskillcard().name.substr(0|6) != ~Uptick~) { self.replaceskillcard(~Uptick@1~); self.setvar(~uptick~|1); } Rules.addextrascript(~var uptick = self.getvar(\~uptick\~); Rules.stackplayerdice([[uptick]][;] true); self.replaceskillcard(\~Uptick@\~ + uptick);~|~beforestartturn~); Rules.addextrascript(~var uptick = self.getvar(\~uptick\~) + 1; if(uptick >=7) uptick = 1; self.setvar(\~uptick\~[;] uptick);~|~endturn~); Rules.addextrascript(~var uptick = self.getvar(\~uptick\~) + 1; if(uptick >=7) uptick = 1; self.setvar(\~uptick\~[;] uptick);~|~aftercombat); self.changelimitbreak(~Trips~);,YES
Banshee?,At the end of each turn[;] your limit|break is decharged by 2 points.,banshee,-20|0,YES,Rules.addextrascript(~if(self.isplayer) { self.limitvalue -= 2; if (self.limitvalue < 0) { self.limitvalue = 0; } } if(target.isplayer) { target.limitvalue -= 2; if(target.limitvalue < 0) { target.limitvalue = 0; } } ~[;] ~endturn~);,YES
Loud Bird?,Your limit break is|permanently weakened.,loudbird,-130|-60,YES,if(self.alternatelimitbreak != null) { self.limitbreak = self.alternatelimitbreak; } var newalt = new elements.Skill(~Limit Broke~); self.alternatelimitbreak = newalt;,YES
Sneezy?,At the start of everyone's turns[;]|countdowns decrease by 2.,sneezey,-20|-10,YES,Rules.addextrascript(~if(self.equipment.length > 0) { for(eq in self.equipment) { if(eq.countdown > 0) { eq.animate(\~flash\~); } } } boostcountdowns(2);~[;] ~onstartturn~); Rules.addextrascript(~target.scriptonstartturn = \~if(self.equipment.length > 0) { for(eq in self.equipment) { if(eq.countdown > 0) { eq.animate(\\\~flash\\\~); } } } boostcountdowns(2); \~ + target.scriptonstartturn;~[;] ~startcombat~);,YES
Warlock?,Ten random status effects|are made different.,warlock,-70|-50,YES,trace(~ncr status list:~ + self.getvar(~ncrwarlockstatuslist~)); trace(self.getvar(~ncrwarlockstatuslist~).length); trace(self.getvar(~ncrwarlockstatuslist~).length > 1); if(self.getvar(~ncrwarlockstatuslist~) == 0 # self.getvar(~ncrwarlockstatuslist~) == ~0~) { trace(~setting statuslist~); var statuslist = [~silence~|~poison~|~fire~|~shock~|~ice~|~weaken~|~curse~|~blind~|~fury~|~lock~|~shield~|~dodge~|~thorns~|~confuse~|~clock~|~ctrig~|~reequipnext~|~survive~|~vampire~]; shuffle(statuslist); for(i in 1...10) { statuslist.pop(); } trace(statuslist); self.setvar(~ncrwarlockstatuslist~|statuslist); trace(self.getvar(~ncrwarlockstatuslist~)); } trace(self.getvar(~ncrwarlockstatuslist~)); for(s in self.getvar(~ncrwarlockstatuslist~)) { if(s == ~clock~) { for(i in 1...7) { Rules.setalternate(~counter_~ + i); } } else if(s == ~ctrig~) { for(i in 1...7) { Rules.setalternate(~dice_trigger_~ + i); } } else if(s == ~fire~ # s == ~ice~) { Rules.setalternate(s); Rules.setalternate(s + ~_all~); } else { Rules.setalternate(s); } },YES
The Witch?,Switch to [quote]Countdown[quote] rules.,_witch,-90|-30,YES,Rules.stackplayerdice([[6[;] 5[;] 4[;] 3[;] 2[;] 1]][;] false);,YES
Bounty Hunter?,Inflicting [fire]Burn also inflicts|[shock]Shock[;] and vice versa.,bountyhunter,-20|0,YES,Rules.addextrascript(~var fire = 0; var shock = 0; if(target.status.length > 0) { for(stat in target.status) { if(stat.type == \~fire\~ # stat.type == \~alternate_fire\~) { fire += stat.value; } if(stat.type == \~shock\~ # stat.type == \~alternate_shock\~) { shock += stat.value; } } } target.setvar(\~ncrfire\~|fire); target.setvar(\~ncrshock\~|shock); trace(\~fire A: \~ + target.getvar(\~ncrfire\~));  trace(\~shock A: \~ + target.getvar(\~ncrshock\~)); trace(target.name); ~[;] ~beforestartturn~); Rules.addextrascript(~target.scriptbeforestartturn = \~var fire = 0; var shock = 0; if(target.status.length > 0) { for(stat in target.status) { if(stat.type == \\\~fire\\\~ # stat.type == \\\~alternate_fire\\\~) { fire += stat.value; } if(stat.type == \\\~shock\\\~ # stat.type == \\\~alternate_shock\\\~) { shock += stat.value; } } } target.setvar(\\\~ncrfire\\\~|fire); target.setvar(\\\~ncrshock\\\~|shock);\~ + target.scriptbeforestartturn;~[;] ~startcombat~); Rules.addextrascript(~if(self.isplayer) { var fire = 0; var shock = 0; if(target.status.length > 0) { for(stat in target.status) { if(stat.type == \~fire\~ # stat.type == \~alternate_fire\~) { fire += stat.value; } if(stat.type == \~shock\~ # stat.type == \~alternate_shock\~) { shock += stat.value; } } } target.setvar(\~ncrfire\~|fire); target.setvar(\~ncrshock\~|shock); } else { var fire = 0; var shock = 0; if(self.status.length > 0) { for(stat in self.status) { if(stat.type == \~fire\~ # stat.type == \~alternate_fire\~) { fire += stat.value; } if(stat.type == \~shock\~ # stat.type == \~alternate_shock\~) { shock += stat.value; } } } self.setvar(\~ncrfire\~|fire); self.setvar(\~ncrshock\~|shock); }~[;] ~endturn~); Rules.addextrascript(~target.scriptendturn = \~var fire = 0; var shock = 0; if(target.status.length > 0) { for(stat in target.status) { if(stat.type == \\\~fire\\\~ # stat.type == \\\~alternate_fire\\\~) { fire += stat.value; } if(stat.type == \\\~shock\\\~ # stat.type == \\\~alternate_shock\\\~) { shock += stat.value; } } } target.setvar(\\\~ncrfire\\\~|fire); target.setvar(\\\~ncrshock\\\~|shock);\~ + target.scriptendturn~[;] ~startcombat~); Rules.addextrascript(~var newfire = 0; var newshock = 0; if(target.status.length > 0) { for(stat in target.status) { if(stat.type == \~fire\~ # stat.type == \~alternate_fire\~) { newfire += stat.value; } if(stat.type == \~shock\~ # stat.type == \~alternate_shock\~) { newshock += stat.value; } } } trace(target.name); trace(\~fire A again: \~ + target.getvar(\~ncrfire\~));  trace(\~shock A again: \~ + target.getvar(\~ncrshock\~)); trace(\~fire B: \~ + newfire);  trace(\~shock B: \~ + newshock); var diff1 = newfire - target.getvar(\~ncrshock\~); var diff2 = newshock - target.getvar(\~ncrfire\~); trace(\~Difference A (fire B - shock A): \~ + diff1); trace(\~Difference B (shock B - fire A): \~ + diff2); if(diff1 < 0 & diff2 > 0) { diff2 += diff1; } if(diff2 < 0 & diff1 > 0) { diff1 += diff2; } if(diff1 > 0) { inflict(shock|diff1); } if(diff2 > 0) { inflict(fire|diff2); } if(target.status.length > 0) { for(stat in target.status) { if(stat.type == \~fire\~ # stat.type == \~alternate_fire\~) { target.setvar(\~ncrfire\~|stat.value); } if(stat.type == \~shock\~ # stat.type == \~alternate_shock\~) { target.setvar(\~ncrshock\~|stat.value); } } } trace(target.name); trace(target.getvar(\~ncrshock\~)); trace(target.getvar(\~ncrfire\~));~[;] ~playerequipmentuse~); Rules.addextrascript(~var newfire = 0; var newshock = 0; if(target.status.length > 0) { for(stat in target.status) { if(stat.type == \~fire\~ # stat.type == \~alternate_fire\~) { newfire += stat.value; } if(stat.type == \~shock\~ # stat.type == \~alternate_shock\~) { newshock += stat.value; } } } trace(target.name); trace(\~fire A again: \~ + target.getvar(\~ncrfire\~));  trace(\~shock A again: \~ + target.getvar(\~ncrshock\~)); trace(\~fire B: \~ + newfire);  trace(\~shock B: \~ + newshock); var diff1 = newfire - target.getvar(\~ncrshock\~); var diff2 = newshock - target.getvar(\~ncrfire\~); trace(\~Difference A (fire B - shock A): \~ + diff1); trace(\~Difference B (shock B - fire A): \~ + diff2); if(diff1 < 0 & diff2 > 0) { diff2 += diff1; } if(diff2 < 0 & diff1 > 0) { diff1 += diff2; } if(diff1 > 0) { inflict(shock|diff1); } if(diff2 > 0) { inflict(fire|diff2); } if(target.status.length > 0) { for(stat in target.status) { if(stat.type == \~fire\~ # stat.type == \~alternate_fire\~) { target.setvar(\~ncrfire\~|stat.value); } if(stat.type == \~shock\~ # stat.type == \~alternate_shock\~) { target.setvar(\~ncrshock\~|stat.value); } } } trace(target.name); trace(target.getvar(\~ncrshock\~)); trace(target.getvar(\~ncrfire\~));~[;] ~enemyequipmentuse~);,YES
Drain Monster?,Inflicting [poison]Poison also inflicts|[weaken]Weaken[;] and vice versa.,sewermonster,0|0,YES,Rules.addextrascript(~var poison = 0; var weaken = 0; if(target.status.length > 0) { for(stat in target.status) { if(stat.type == \~poison\~ # stat.type == \~alternate_poison\~) { poison += stat.value; } if(stat.type == \~weaken\~ # stat.type == \~alternate_weaken\~) { weaken += stat.value; } } } target.setvar(\~ncrpoison\~|poison); target.setvar(\~ncrweaken\~|weaken); trace(\~Poison A: \~ + target.getvar(\~ncrpoison\~));  trace(\~Weaken A: \~ + target.getvar(\~ncrweaken\~)); trace(target.name); ~[;] ~beforestartturn~); Rules.addextrascript(~target.scriptbeforestartturn = \~var poison = 0; var weaken = 0; if(target.status.length > 0) { for(stat in target.status) { if(stat.type == \\\~poison\\\~ # stat.type == \\\~alternate_poison\\\~) { poison += stat.value; } if(stat.type == \\\~weaken\\\~ # stat.type == \\\~alternate_weaken\\\~) { weaken += stat.value; } } } target.setvar(\\\~ncrpoison\\\~|poison); target.setvar(\\\~ncrweaken\\\~|weaken);\~ + target.scriptbeforestartturn;~[;] ~startcombat~); Rules.addextrascript(~if(self.isplayer) { var poison = 0; var weaken = 0; if(target.status.length > 0) { for(stat in target.status) { if(stat.type == \~poison\~ # stat.type == \~alternate_poison\~) { poison += stat.value; } if(stat.type == \~weaken\~ # stat.type == \~alternate_weaken\~) { weaken += stat.value; } } } target.setvar(\~ncrpoison\~|poison); target.setvar(\~ncrweaken\~|weaken); } else { var poison = 0; var weaken = 0; if(self.status.length > 0) { for(stat in self.status) { if(stat.type == \~poison\~ # stat.type == \~alternate_poison\~) { poison += stat.value; } if(stat.type == \~weaken\~ # stat.type == \~alternate_weaken\~) { weaken += stat.value; } } } self.setvar(\~ncrpoison\~|poison); self.setvar(\~ncrweaken\~|weaken); }~[;] ~endturn~); Rules.addextrascript(~target.scriptendturn = \~var poison = 0; var weaken = 0; if(target.status.length > 0) { for(stat in target.status) { if(stat.type == \\\~poison\\\~ # stat.type == \\\~alternate_poison\\\~) { poison += stat.value; } if(stat.type == \\\~weaken\\\~ # stat.type == \\\~alternate_weaken\\\~) { weaken += stat.value; } } } target.setvar(\\\~ncrpoison\\\~|poison); target.setvar(\\\~ncrweaken\\\~|weaken);\~ + target.scriptendturn~[;] ~startcombat~); Rules.addextrascript(~var newpoison = 0; var newweaken = 0; if(target.status.length > 0) { for(stat in target.status) { if(stat.type == \~poison\~ # stat.type == \~alternate_poison\~) { newpoison += stat.value; } if(stat.type == \~weaken\~ # stat.type == \~alternate_weaken\~) { newweaken += stat.value; } } } trace(target.name); trace(\~Poison A again: \~ + target.getvar(\~ncrpoison\~));  trace(\~Weaken A again: \~ + target.getvar(\~ncrweaken\~)); trace(\~Poison B: \~ + newpoison);  trace(\~Weaken B: \~ + newweaken); var diff1 = newpoison - target.getvar(\~ncrweaken\~); var diff2 = newweaken - target.getvar(\~ncrpoison\~); trace(\~Difference A (Poison B - Weaken A): \~ + diff1); trace(\~Difference B (Weaken B - Poison A): \~ + diff2); if(diff1 < 0 & diff2 > 0) { diff2 += diff1; } if(diff2 < 0 & diff1 > 0) { diff1 += diff2; } if(diff1 > 0) { inflict(WEAKEN|diff1); } if(diff2 > 0) { inflict(POISON|diff2); } if(target.status.length > 0) { for(stat in target.status) { if(stat.type == \~poison\~ # stat.type == \~alternate_poison\~) { target.setvar(\~ncrpoison\~|stat.value); } if(stat.type == \~weaken\~ # stat.type == \~alternate_weaken\~) { target.setvar(\~ncrweaken\~|stat.value); } } } trace(target.name); trace(target.getvar(\~ncrweaken\~)); trace(target.getvar(\~ncrpoison\~));~[;] ~playerequipmentuse~); Rules.addextrascript(~var newpoison = 0; var newweaken = 0; if(target.status.length > 0) { for(stat in target.status) { if(stat.type == \~poison\~ # stat.type == \~alternate_poison\~) { newpoison += stat.value; } if(stat.type == \~weaken\~ # stat.type == \~alternate_weaken\~) { newweaken += stat.value; } } } trace(target.name); trace(\~Poison A again: \~ + target.getvar(\~ncrpoison\~));  trace(\~Weaken A again: \~ + target.getvar(\~ncrweaken\~)); trace(\~Poison B: \~ + newpoison);  trace(\~Weaken B: \~ + newweaken); var diff1 = newpoison - target.getvar(\~ncrweaken\~); var diff2 = newweaken - target.getvar(\~ncrpoison\~); trace(\~Difference A (Poison B - Weaken A): \~ + diff1); trace(\~Difference B (Weaken B - Poison A): \~ + diff2); if(diff1 < 0 & diff2 > 0) { diff2 += diff1; } if(diff2 < 0 & diff1 > 0) { diff1 += diff2; } if(diff1 > 0) { inflict(WEAKEN|diff1); } if(diff2 > 0) { inflict(POISON|diff2); } if(target.status.length > 0) { for(stat in target.status) { if(stat.type == \~poison\~ # stat.type == \~alternate_poison\~) { target.setvar(\~ncrpoison\~|stat.value); } if(stat.type == \~weaken\~ # stat.type == \~alternate_weaken\~) { target.setvar(\~ncrweaken\~|stat.value); } } } trace(target.name); trace(target.getvar(\~ncrweaken\~)); trace(target.getvar(\~ncrpoison\~));~[;] ~enemyequipmentuse~);,YES
Yolanda?,Get [gold]20 gold[;] now. Beating enemies|makes you lose gold.,*shop,-90|-60,YES,if(self.getvar(~ncryolandaapplied~) == 0 # self.getvar(~ncryolandaapplied~) == ~0~ ) { self.gold += 20; self.setvar(~ncryolandaapplied~|true); } Rules.addextrascript(~target.gold-= 2;~[;] ~startcombat~); Rules.addextrascript(~if(self.gold < 0) { self.gold = 0; }~[;] ~aftercombat~);,YES
Val?,Everything you currently have equipped|is replaced with random items.,*tradingpost,-75|-80,YES,var eqlist = []; if(self.equipment.length > 0) { for(eq in self.equipment) { if(eq.skillcard == ~~) { eqlist.push(eq); } } for(eq in eqlist) { var eqsize = ~small~; if(eq.size > 1) {eqsize = ~large~; } var neweq = rand(getparticularequipment([eqsize])); eq.name = ~blahdeleteme~; removeequipment(~blahdeleteme~); giveequipment(neweq|false|false); } },NO
Sorceress?,Enemy rolls are fixed and|in descending order.,sorceress,0|0,YES,Rules.stackenemydice([[6[;] 5[;] 4[;] 3[;] 2[;] 1]][;] false);,YES
Wizard?,Enemies get a random spell|from the Wizard's spellbook.,wizard,-50|-20,YES,Rules.addextrascript(~var randomspell = rand([\~Freeze Spell\~|\~Flame Spell\~|\~Poison Spell\~|\~Thunder Spell\~|\~Teleport Spell\~|\~Hall of Mirrors\~]; if (target.spaceleft() >= 1) giveenemyequipment(randomspell[;] false[;] false);~[;] ~startcombat~);,YES
Handyman?,On the first turn of every fight[;]|one of your items is disabled.,handyman,-30|-10,YES,Rules.addextrascript(~if(turn == 1) { eqlist = []; for(eq in self.equipment) { if(eq.ready && eq.availablethisturn && eq.skillcard == \~\~) { eqlist.push(eq); } } shuffle(eqlist); eqlist[0].animate(\~flashandshake\~); eqlist[0].availablethisturn = false; sfx(\~_shock\~); }~[;] ~onstartturn~);,YES
Keymaster? X,[lock]Lock one of your dice|every other turn.,keymaster,-30|-40,NO,Rules.addextrascript(~if(turn % 2 == 0) { inflictself(LOCK); }~[;] ~beforestartturn~); // this is just skeleton * 0.5 (but different if lock is alt i guess); and keymaster is cooler for the 'split your dice' rule,YES
Vacuum?,On the enemy's first turn[;] they|drain health on every attack.,vacuum,-100|50,YES,Rules.addextrascript(~if(turn == 1) { for(eq in target.equipment) { target.setvar(\~originalscript\~ + eq.name|eq.script); if(eq.script.split(\~attack(\~).length > 1) { eq.script = eq.script.split(\~drain(\~).join(\~/*NCR SPAM HUMBUG*/drain(\~); eq.script = eq.script.split(\~attack(\~).join(\~drain(\~); eq.script = eq.script.split(\~drainself(\~).join(\~attackself(\~); eq.script = eq.script.split(\~piercedrain(\~).join(\~pierceattack(\~); } } } if(turn == 2) { for(eq in target.equipment) { eq.script = eq.script.split(\~drain(\~).join(\~attack(\~); eq.script = eq.script.split(\~/*NCR SPAM HUMBUG*/attack(\~).join(\~drain(\~); } } ~[;] ~beforestartturn~);,YES
Copycat?,At the start of each fight[;] permanently|swap a random item with the enemy.,copycat,0|0,YES,if(self.getvar(~ncrcopycatapplied~) == 0) { self.setvar(~ncrcopycatapplied~|true); self.setvar(~seenenemies~|[]); } Rules.addextrascript(~var seenenemies = self.getvar(\~seenenemies\~); if(turn == 1 && seenenemies.indexOf(target.name) == -1) { var myeqs = []; var mybigeqs = []; var mysmalleqs = []; var theireqs = []; var theirbigeqs = []; var theirsmalleqs = []; var mychoseneq = \~\~; var theirchoseneq = \~\~; for(eq in self.equipment) { if(eq.skillcard == \~\~) { myeqs.push(eq); if(eq.size == 1) { mysmalleqs.push(eq); } else { mybigeqs.push(eq); } } } for(eq in target.equipment) { if(eq.skillcard == \~\~ && eq.name != \~The Storm\~ /*evil kludge to remove the 1/6 possibility of scathach being a complete pushover. when shock isn't alternate; anyway. would do the same to audrey & earthquake but that would be far too obvious - plus audrey can at least still do something if you use earthquake*/) { theireqs.push(eq); if(eq.size == 1) { theirsmalleqs.push(eq); } else { theirbigeqs.push(eq); } } } if((mysmalleqs == [] && theirbigeqs == []) # (mybigeqs == [] && theirsmalleqs == []) # (theireqs == []) # (myeqs == [])) { self.textparticle(\~Can't swap items!\~); } else { /*coin toss to decide who gets to determine what the other fighter's chosen eq can be. should make this more fair probability-wise.*/ if(chance(50)) { if(theirbigeqs == []) { mychoseneq = rand(mysmalleqs); trace(\~yo 1\~); } else if(theirsmalleqs == []) { mychoseneq = rand(mybigeqs); trace(\~yo 2\~); } else { mychoseneq = rand(myeqs); trace(\~yo 3\~); } if(mychoseneq.size == 1) { theirchoseneq = rand(theirsmalleqs); trace(\~yo 4\~); } else { theirchoseneq = rand(theirbigeqs); trace(\~hi 2\~); } } else { if(mybigeqs == []) { theirchoseneq = rand(theirsmalleqs); trace(\~hi 3\~); } else if(mysmalleqs == []) { theirchoseneq = rand(theirbigeqs); trace(\~hi 4\~); } else { theirchoseneq = rand(theireqs); trace(\~hi 5\~); } if(theirchoseneq.size == 1) { mychoseneq = rand(mysmalleqs); } else { mychoseneq = rand(mybigeqs); } } trace(\~super hi\~); var mychoseneqcopy = \~\~; trace(mychoseneq.name); if(mychoseneq.namemodifier == \~+\~ # mychoseneq.originallyupgraded) { mychoseneqcopy = mychoseneq.name + \~+\~; } else { mychoseneqcopy = mychoseneq.name; } var theirchoseneqcopy = \~\~; trace(theirchoseneq.name); if(theirchoseneq.namemodifier == \~+\~ # theirchoseneq.originallyupgraded) { theirchoseneqcopy = theirchoseneq.name + \~+\~; } else { theirchoseneqcopy = theirchoseneq.name; } replacemewith(theirchoseneqcopy [;] -1[;] mychoseneq[;] self); giveenemyequipment(mychoseneqcopy|false|false|theirchoseneq); seenenemies.push(target.name); self.setvar(\~seenenemies\~|seenenemies); } } ~[;] ~onstartturn~);,YES
Keymaster?,Split your highest dice|at the start of every turn.,keymaster,-30|-40,YES,Rules.addextrascript(~var dicelist = []; if(self.dicepool.length > 0) { for(mydice in self.dicepool) { if(mydice.available()) { dicelist.push(mydice); } } dicelist.sort(function(a|b) return a.basevalue - b.basevalue); dicelist[0].removedice(self.screenposition()); givedice(split(dicelist[0].basevalue)); sfx(\~splitdice\~); sfx(\~_lock\~); }~onstartturn~);,YES
Ned?,Upgrade everything currently equipped.,*anvil,-75|15,YES,var eqlist = []; if(self.equipment.length > 0) { for(eq in self.equipment) { if(eq.skillcard == ~~ && eq.namemodifier != ~+~ && eq.upgradetype != ~~) { eqlist.push(eq); } } for(eq in eqlist) { var neweq = eq.name + ~+~; eq.name = ~blahdeleteme~; removeequipment(~blahdeleteme~); giveequipment(neweq|false|false); } } //this is really just a more mild form of the ned rule thats already in the game; HOWEVER: it provides a good counterbalance to val?; so getting paranoid and stuffing all your equipment away whenever you move down a floor doesn't always benefit.,NO
Kraken?,Blind all starting rolls for|everyone[;] every turn.,kraken,-80|-60,YES,Rules.addextrascript(~inflictself(BLIND|self.dice + self.extradice + self.bonusdice);~[;] ~beforestartturn~); Rules.addextrascript(~target.scriptbeforestartturn = \~inflictself(BLIND|self.dice + self.extradice + self.bonusdice); for(myinnate in self.innate) { if(myinnate == \\\~gaindice\\\~) { inflictself(BLIND); } } \~ + target.scriptbeforestartturn;~[;] ~startcombat~);,YES
Skeleton?,Take [sword]10 damage[;] immediately.|(This won't kill you.),skeleton,-20|-80,YES,if(self.hp <= 10) { self.hp == 1; } else { self.hp -= 10; } sfxdamage(self|10); screenshake();,NO
Cornelius?,Enemies gain an additional dice|every turn.,cornelius,0|-40,YES,Rules.addextrascript(~if (target.innate.indexOf(\~gaindice\~) == -1) { target.innate.push(\~gaindice\~); } if(target.dice != 0) { target.dice--; }~[;] ~startcombat~);,YES
Aurora?,After enemy's turn[;] they heal [heal]1|per status they inflicted on you.,weathergoddess,0|0,YES,Rules.addextrascript(~if(self.isplayer) { var statii = []; var statvalues = []; for(mystat in self.status) { statii.push(mystat.type); if(mystat.type == \~poison\~ # \~alternate_poison\~) { statvalues.push(mystat.value + 1); } else { statvalues.push(mystat.value); } } self.setvar(\~ncr__statii\~|statii); self.setvar(\~ncr__statvalues\~|statvalues); } else { var statii = []; var statvalues = []; for(mystat in target.status) { statii.push(mystat.type); if(mystat.type == \~poison\~ # \~alternate_poison\~) { statvalues.push(mystat.value + 1); } else { statvalues.push(mystat.value); } } target.setvar(\~ncr__statii\~|statii); target.setvar(\~ncr__statvalues\~|statvalues); } ~[;] ~endturn~); Rules.addextrascript(~var newstatii = []; var newstatvalues = []; var oldvalue = 0; var newvalue = 0; for(mystat in self.status) { newstatii.push(mystat.type); newstatvalues.push(mystat.value); } var statii = self.getvar(\~ncr__statii\~); var statvalues = self.getvar(\~ncr__statvalues\~); var healtotal = 0; for(mystattype in newstatii) { if(statii.indexOf(mystattype) != -1) { oldvalue = statvalues[statii.indexOf(mystattype)]; } else { donothing(); } newvalue = newstatvalues[newstatii.indexOf(mystattype)]; var add = newvalue - oldvalue; if(add > 0) { healtotal += add; } } attack(-healtotal); if(healtotal != 0) { sfx(\~_heal\~); } self.setvar(\~ncr__statii\~|0); self.setvar(\~ncr_statvalues\~|0); ~[;] ~beforestartturn~); //at this time of year?,YES
Rhino Beetle?,Take [sword]1 for every four items|you use each turn.,beetlewarrior,0|0,YES,Rules.addextrascript(~if(self.equipmentused % 4 == 0) attackself(1); sfxdamage(self|1); self.equipment[0].playcharactervoice(\~Rhino Beetle\~); ~[;] ~playerequipmentuse~); ,YES
Space Marine?,Every time you use an item[;]|increase countdowns by 1.,spacemarine,-30|-10,YES,Rules.addextrascript(~for(eq in self.equipment) { trace(eq.name); trace(eq.remainingcountdown); if(eq.remainingcountdown > 0) { eq.remainingcountdown++; sfx(\~countdowntick_above3\~|\~\~|0.025); } } ~[;] ~playerequipmentuse~); ,YES
Scathach?,You are [silence]Silenced on the|first turn of every fight.,scahatch,-60|-30,YES,Rules.addplayerinnatestatus(SILENCE[;] 1[;] true);,YES
