Name,Description,Requirements,Script
Plexiglass,-1 dice for you and enemy,,if(self.dice + self.extradice == 1 # target.dice + target.extradice == 1) { self.textparticle(~Can't go lower!~); } else { self.extradice--; target.extradice--; sfx(~magic_gaindice~); }
Obfuscate,Inflict [blind]2 blind,,inflict(BLIND|2); sfx(~_blind~);
Confiscate,Lock [lock]1 dice,,inflict(LOCK); sfx(~_lock~);
Science,Blind a random amount,,var r = rand([1|1|1|1|2|2|2|3|3|4|5]); inflict(BLIND| r); sfx(~_blind~); /* you could probably do this without r by just putting the rand in place of it; but this is how the official items do it so what-ever */
Neutron Star,Odd turns: [sword]3[;] even: [sword]6,,if(turn % 2 == 0) { attack(6); sfxdamage(target|6); } else { attack(3); sfxdamage(target|3); }
Conformity,Set a dice to your highest,,var dicelist = []; var max = 0; if(self.dicepool.length > 0) { for (mydice in self.dicepool){ if (mydice.available()){ dicelist.push(mydice);  if (mydice.basevalue > max) { max = mydice.basevalue; } } } if(dicelist.length > 0 && max > 0) { var backupdicelist = dicelist.copy(); for(mydice in backupdicelist) { if(mydice.basevalue == max) { dicelist.remove(mydice); } } if(dicelist.length > 0) { shuffle(dicelist); dicelist[0].animatereroll(max| self.screenposition()); } else { shuffle(backupdicelist); backupdicelist[0].animatereroll(max|self.screenposition()); } } }
Healthy Eating,Gain 2 max hp (once),,self.maxhp +=2; attackself(-2); if(!self.isplayer) var self = target; sfx(~_heal~); Gadget.changegadget(self| ~Healthy Eating~| ~Broken Gadget~); /*kale salad used to be the only way of raising max hp; builds exploiting kale salad with hookshot and a breakable enemy (like paper knight) were called 'healthy eating' builds at least once*/
Electrify,Shock a random amount,,var r = rand([1|1|1|1|1|1|2|2|2|2|2|2|3|3|3|3|4|5]); inflict(SHOCK| r); sfx(~_shock~);
Underwhelm,Do [sword]<var:underwhelm> dmg[;] dmg -1,,if(!self.isplayer) var self = target; if(!self.getvar(~underwhelm~) > 0) {self.setvar(~underwhelm~|5);} attack(self.getvar(~underwhelm~)); sfxdamage(target|self.getvar(~underwhelm~)); if(self.getvar(~underwhelm~) > 1) {self.setvar(~underwhelm~|self.getvar(~underwhelm~)-1);} /* base value of underwhelm; 5; was _merged into inventor gadgets. also yes; i use semicolons instead of commas; do; not; mock me;;;;;; */
Dice Bash,Do [sword] with one of your dice,,var dicelist = []; for (mydice in self.dicepool){ if (mydice.available()){ dicelist.push(mydice); }} if(dicelist.length > 0) { shuffle(dicelist); attack(dicelist[0]); sfxdamage(target|dicelist[0]); }
Phillips Head,[sword]3 dmg[;] [sword]6 if reactivated,,if(!self.isplayer) var self = target; if (self.getvar(~phillip~) != true) { attack(3); self.setvar(~phillip~|true); } else { attack(6); } // _merge inventor gadgets shenanigans
Drunken Boxing,Do [sword]1-10 damage,,var r = rand([1|2|2|3|3|3|4|4|4|4|5|5|5|5|5|6|6|6|6|6|7|7|7|7|8|8|8|9|9|10]); attack(r); sfxdamage(target|r);
Rod,Cut enemy health by 1/4,,var p = (target.hp / 4); pierceattack(p); sfxdamage(target|p);
Perfectionism,Make dice parity match,,var availabledice = []; var evens = 0; var odds = 0; var oddparity = false; if(self.dicepool.length > 0) { for (mydice in self.dicepool){ if (mydice.available()){ availabledice.push(mydice); trace(1); if (mydice.basevalue % 2 == 0) { evens++; } else { odds++; } } } if(availabledice.length > 0) { trace(2); if(evens > odds) { oddparity = true; } else { if(evens == odds) { oddparity = rand([false|true]); } } trace(3); if(oddparity == false) { sfx(~diceroll~); for(mydice in availabledice){ if(mydice.basevalue % 2 == 0) { mydice.animatereroll(mydice.basevalue - 1|self.screenposition()); } } } else { if(oddparity == true) { trace(4); sfx(~diceroll~); for(mydice in availabledice) { if(mydice.basevalue % 2 == 1) { mydice.animatereroll(mydice.basevalue + 1|self.screenposition()); } } } else { self.textparticle(~Already matched!~); } } } }
Reset Button,Revert all your statuses (once),,var exceptions = loadtext(~ncrmod/resetbuttonexceptions~); /*if(target.status.length > 0) { for(x in target.status) { if(exceptions.indexOf(x.type) == -1) { removestatus(x.type|ALL); } } }*/ if(self.status.length > 0) { for(x in self.status) { if(exceptions.indexOf(x.type) == -1) { removestatusself(x.type|ALL); } } } sfx(~_cure~); /*frankly kind of surprised that part was as simple as it was*/ if(self.equipment.length > 0) { for(eq in self.equipment) { if(eq.shockedsetting != 0) { eq.shockedsetting = 0; eq.animate(~flashandshake~); } if(eq.namemodifier == ~-~) { eq.unweaken(); eq.animate(~flashandshake~); } } } if(self.dicepool.length > 0) { for(mydice in self.dicepool) { mydice.priority = false; if(mydice.burn # mydice.alternateburn # mydice.blind # mydice.locked) { mydice.animate(~flashshake~); } mydice.burn = false; mydice.alternateburn = false; mydice.blind = false; mydice.showoverlayimage = false; if(mydice.locked) { mydice.locked = false; mydice.canbedragged = true; mydice.dicealpha = 1; } } } if(!self.isplayer) var self = target;  Gadget.changegadget(self| ~Reset Button~| ~Broken Gadget~);
Scabbard (1/2),Get Sacrificial Blade (once),,giveequipment(~Sacrificial Blade@2~|true|false); if(!self.isplayer) var self = target;  Gadget.changegadget(self| ~Scabbard (1/2)~| ~Broken Gadget~);
Scabbard+ (1/4),Get Sacrificial Blade+ (once),,giveequipment(~Sacrificial Blade@2+~|true|false); if(!self.isplayer) var self = target;  Gadget.changegadget(self| ~Scabbard+ (1/4)~| ~Broken Gadget~);
Scabbard (2/2),Get Sacrificial Blade (once),,giveequipment(~Sacrificial Blade@1~|true|false);if(!self.isplayer) var self = target;  Gadget.changegadget(self| ~Scabbard (2/2)~| ~Broken Gadget~);
Scabbard+ (2/4),Get Sacrificial Blade+ (once),,giveequipment(~Sacrificial Blade@1+~|true|false);if(!self.isplayer) var self = target;  Gadget.changegadget(self| ~Scabbard+ (2/4)~| ~Broken Gadget~);
Scabbard+ (3/4),Get Sacrificial Blade+ (once),,giveequipment(~Sacrificial Blade@0+~|true|false);if(!self.isplayer) var self = target;  Gadget.changegadget(self| ~Scabbard+ (3/4)~| ~Broken Gadget~);
Scabbard+ (4/4),Get Sacrificial Blade+ (once),,giveequipment(~Sacrificial Blade@X+~|true|false);if(!self.isplayer) var self = target;  Gadget.changegadget(self| ~Scabbard+ (4/4)~| ~Broken Gadget~);
Deep Breath,Trash all dice[;] gain [heal]3 each,,sfx(~_heal~); if(self.dicepool.length > 0) { for (mydice in self.dicepool){ if (mydice.available()){ mydice.removedice(self.screenposition()); attackself(-3); } } } /* actually an official item that was scrapped - see https://github.com/TerryCavanagh/diceydungeonsbeta/issues/264 */
Delude,Inflict [vanish]1 vanish,,inflict(~ncr_vanish~); sfx(~_vanish~);
Strobe Light,Vanish a random amount,,var r = rand([1|1|1|1|2|2|2|3|3|4|5]); inflict(~ncr_vanish~|r); sfx(~_vanish~);
Hadoken,Do [vanish]3 damage,,attack(3|VANISH); sfx(~_vanish~); sfxdamage(target|3);
Briar Bush,Gain [thorns]2 thorns,,inflictself(THORNS|2); sfx(~_thorns~);
Mass Deception,Inflict [vanish]Vanish_all[],,inflict(VANISH); sfx(~_vanish~);
THE [200%]GASDGFET,[200%]THE [300%]SBETST [200%]GDAGET. 2 DAMMAGE,,attack(2); sfxdamage(target|999);
Light Switch,Copy a dice for next turn,,var dicelist = []; for (mydice in self.dicepool){ if (mydice.available()){ dicelist.push(mydice); }} if(dicelist.length > 0) { shuffle(dicelist); inflictself(~stash~+dicelist[0].basevalue); dicelist[0].animate(~flashshake~); inflictself(~ncr_lightswitch~+dicelist[0].basevalue); sfx(~magic~); }
Install Evony,In [jinx]1[;] card uses raise CPU,,jinx(~Install Evony~|~each equipment use will raise CPU by 1~|~Each equipment use will raise CPU by 1~|~inflict(\~cpuvirus\~| 1); sfx(\~magic\~);~|self|self|1|0); sfx(~_thinghappens~);
impulse 101,In [jinx]1 turn[;] +1 Jackpot range,,jinx(~impulse 101~|~increase Jackpot range~|~Increase Jackpot range~|~target.roll_range += 1; sfx(\~useitem\~);~|self|self|1|0); sfx(~_thinghappens~);
Less Fluff,Scrap an active item now,,if(!self.isplayer) { self.equipment[0].name = ~blahdeleteme~; removeequipment(~blahdeleteme~|target); sfx(~_whooshweapons~); } else { var cardlist = []; var cardtoscrap = null; for(eq in self.equipment){ if(eq.isready(true) && eq != self.getskillcard()) { cardlist.push(eq); } } if(cardlist.length > 0) { /*cardlist.reverse(); /*so top row items come 'after' bottom row items*/ var mincolumn = 999; for(card in cardlist) { if(card.column < mincolumn) { mincolumn = card.column; cardtoscrap = card; } }*/ cardtoscrap = rand(cardlist); Gadget.givegadget(self|cardtoscrap.gadget|true); cardtoscrap.ready = false; cardtoscrap.temporary_thisturnonly = true; cardtoscrap.animate(~error~); cardtoscrap.animation[cardtoscrap.animation.length - 1].command[2] = ~~; /*remove 'errored!' text particle from error anim*/ sfx(~_whooshweapons~); sfx(~upgradeequipment~); if(self.getskillcard() != null) { self.getskillcard().animate(~flashandshake~); } } else { self.textparticle(~No equipment!~); } }
Proximity Mine,Reroll dice nearest to this,,if(!self.isplayer) { self.textparticle(~No effect!~); } else { var proximy = self.getskillcard().y + (self.getskillcard().height / 2) - 132; var proximx = self.getskillcard().x + (self.getskillcard().width / 2) - 110; var dicelist = []; for(mydice in self.dicepool) { if(mydice.available()) { dicelist.push(mydice); } } if(dicelist.length != 0) { var proxlist = []; for(mydice in dicelist) { proxlist.push(((mydice.x - proximx) * (mydice.x - proximx)) + ((mydice.y - proximy) * (mydice.y - proximy))); if(proxlist[proxlist.length - 1] < 0) { proxlist[proxlist.length - 1] = proxlist[proxlist.length - 1] * -1; } } var min = [0|999999999999999999999]; for(prox in proxlist) { trace(prox); trace(min[1]); trace(~---~); if(prox < min[1]) { min[1] = prox; min[0] = proxlist.indexOf(prox); } } sfx(~diceroll~); dicelist[min[0]].animatereroll(rand([1|2|3|4|5|6]) | self.screenposition()); } else { self.textparticle(~No dice!~); } }
Turbo Boost,10 to a random count,,var poss = []; for(eq in self.equipment){if(eq.countdown > 0 && eq.ready && eq.availablethisturn){ poss.push(eq) } }  if(poss.length > 0){ var r = rand(poss); givedice(5); givedice(5); r.assigndice(self.dicepool[self.dicepool.length - 1]); r.assigndice(self.dicepool[self.dicepool.length - 2]); } /*basically another ropedart copypaste. should that 2 be a 1 i dono*/
Vaporizer,Do [sword]5 damage,,attack(5); sfxdamage(target|5);
Parity Flip,Bump odds[;] nudge evens,,var c = 0; if(self.dicepool.length > 0) { sfx(~diceroll~); for (mydice in self.dicepool){ if (mydice.available() && mydice.basevalue % 2 == 0){ mydice.animatereroll((mydice.basevalue - 1)| self.screenposition()| c * 0.05); c++; } if (mydice.available() && mydice.basevalue % 2 == 1){ mydice.animatereroll((mydice.basevalue + 1)| self.screenposition()| c * 0.05); c++; } } }
Razor Blade,Split all dice,,var dicelist = []; for (mydice in self.dicepool){ if (mydice.available()){ dicelist.push(mydice); } } if(dicelist.length > 0) { sfx(~splitdice~); for(mydice in dicelist) { mydice.removedice(self.screenposition()); givedice(split(mydice.basevalue)); } }
Emulator,Mimic a card's gadget,,if(!self.isplayer) { self.textparticle(~No effect!~); } else { var exceptionlist = [~Emulator~|~Boltzmann Brain~|~N/A~]; var gadgpool = []; for(eq in self.equipment) { if(eq.isready(true) && !eq.hastag(~skillcard~) && exceptionlist.indexOf(eq.gadget) == -1) { gadgpool.push(eq); } } shuffle(gadgpool); gadgpool[0].animate(~flashandshake~); var gadgettomimic = gadgpool[0].gadget; var emulategadget = new elements.Skill(gadgettomimic); if(emulategadget.name == ~Mirror Smash~) { pierceattackself(3); sfx(~_heal~); givedice(); self.setvar(~smashuses~|self.getvar(~smashuses~) - 1); if(self.getvar(~smashuses~) > 0) { if(!self.usecpuinsteadofdice) { Gadget.reactivate(self|~Emulator~); } else { self.roll_jackpotbonus++; self.getskillcard().animate(~flashandshake~); var tw = new motion.actuators.SimpleActuator(null|0.01|null); var s = new elements.Skill(~Against all odds_old~); s.script = ~  for(i in 0...self.getskillcard().skills.length) {   if(self.getskillcard().skills[i].name == \~Emulator\~) {    self.getskillcard().skillsavailable[i] = true;   }  } ~; tw.onComplete(s.execute|[self|target]); tw.move();  } } } else if(emulategadget.name == ~Gadget Roll~) { var availdice = []; for (mydice in self.dicepool){ if (mydice.available()){ availdice.push(mydice); } } if(availdice.length > 0) { trace(~hi~); shuffle(availdice); availdice[0].animatereroll(rand([1|2|3|4|5|6]) | self.screenposition()); sfx(~diceroll~); } self.setvar(~grolluses~|self.getvar(~grolluses~) - 1); if(self.getvar(~grolluses~) > 0) { if(!self.usecpuinsteadofdice) { Gadget.reactivate(self|~Emulator~); } else { self.roll_jackpotbonus++; self.getskillcard().animate(~flashandshake~); var tw = new motion.actuators.SimpleActuator(null|0.01|null); var s = new elements.Skill(~Against all odds_old~); s.script = ~  for(i in 0...self.getskillcard().skills.length) {   if(self.getskillcard().skills[i].name == \~Emulator\~) {    self.getskillcard().skillsavailable[i] = true;   }  } ~; tw.onComplete(s.execute|[self|target]); tw.move();  } } } else { var j = emulategadget.script.split(~Gadget.changegadget(self| \~~ + emulategadget.name + ~\~~); if(j.length > 1) { if(!self.usecpuinsteadofdice) { emulategadget.script = j.join(~Gadget.changegadget(self| \~Emulator\~~); } else { emulategadget.script = j.join(~self.innate.push(\~Emulator\~); self.innate.push(~); } } emulategadget.execute(self|target); } self.getskillcard().animation = []; self.getskillcard().animate(~particleblah~); self.getskillcard().animation[0].addcommand(~textparticle~[;] emulategadget.name + ~!~[;] 16777215); }
Gadget Roll,Reroll a dice (uses: 3),,if(self.dicepool.length > 0) { var availdice = []; for (mydice in self.dicepool){ if (mydice.available()){ availdice.push(mydice); } } if(availdice.length > 0) { shuffle(availdice); availdice[0].animatereroll(rand([1|2|3|4|5|6]) | self.screenposition()); sfx(~diceroll~); } } if(!self.isplayer) var self = target; if(self.getvar(~grolluses~) > 0) { self.setvar(~grolluses~|self.getvar(~grolluses~) - 1); } for(myskill in self.getskillcard().skills) { if(myskill.name == ~Gadget Roll~) { var a = ~~ + self.getvar(~grolluses~); var b = ~~ + (self.getvar(~grolluses~) + 1); var m = myskill.description.split(b); myskill.description = m.join(a); } } if(self.getvar(~grolluses~) > 0) { if(!self.usecpuinsteadofdice) { Gadget.reactivate(self|~Gadget Roll~); } else { self.roll_jackpotbonus++; self.getskillcard().animate(~flashandshake~); var tw = new motion.actuators.SimpleActuator(null|0.01|null); var s = new elements.Skill(~Against all odds_old~); s.script = ~  for(i in 0...self.getskillcard().skills.length) {   if(self.getskillcard().skills[i].name == \~Gadget Roll\~ && self.getskillcard().skills[i].description.indexOf(\~uses: 0\~) == -1) {    self.getskillcard().skillsavailable[i] = true;   }  } ~; tw.onComplete(s.execute|[self|target]); tw.move();  } }
Mirror Smash,-3 [heart][][;] get dice (uses: 3),,pierceattackself(3); sfx(~_heal~); givedice(); if(!self.isplayer) var self = target; if(self.getvar(~smashuses~) > 0) { self.setvar(~smashuses~|self.getvar(~smashuses~) - 1); } for(myskill in self.getskillcard().skills) { if(myskill.name == ~Mirror Smash~) { var a = ~~ + self.getvar(~smashuses~); var b = ~~ + (self.getvar(~smashuses~) + 1); var m = myskill.description.split(b); myskill.description = m.join(a); if(myskill.description.split(~-2 [~).length > 1) { myskill.description = myskill.description.split(~-2 [~).join(~-3 [~); } } } if(self.getvar(~grolluses~) > 0) { if(!self.usecpuinsteadofdice) { Gadget.reactivate(self|~Mirror Smash~); } else { self.roll_jackpotbonus++; self.getskillcard().animate(~flashandshake~); var tw = new motion.actuators.SimpleActuator(null|0.01|null); var s = new elements.Skill(~Against all odds_old~); s.script = ~  for(i in 0...self.getskillcard().skills.length) {   if(self.getskillcard().skills[i].name == \~Mirror Smash\~ && self.getskillcard().skills[i].description.indexOf(\~uses: 0\~) == -1) {    self.getskillcard().skillsavailable[i] = true;   }  } ~; tw.onComplete(s.execute|[self|target]); tw.move();  } }
Hustle,Boost limit charge by [confuse]2,,self.limitvalue += 2; if(self.limitvalue > self.limitmax) self.limitvalue = self.limitmax; sfx(~_cure~); /*jackeea later told me he has a gadget exactly like this but boosts 5 instead of 2. 5 is an awful lot though.. also i'm ncrecc and this is my mod so i get to do whatever i want*/
Limit Broke old,Revert to initial limit break,,if(self.getvar(~myoldlimit~) != 0) { self.changelimitbreak(self.getvar(~myoldlimit~)); } else { target.textparticle(~yell at ncr if you see this~); } /*scrapped because it only made sense with cybernetics and this is also used for loud bird? rule*/
Limit Roll,Reroll 3 dice,,var availdice = []; for (mydice in self.dicepool){ if (mydice.available()){ availdice.push(mydice); } } if(availdice.length > 0) { dicelist.sort(function(a|b) return -1 * (a.basevalue - b.basevalue)); for(i in 0...3) { if(availdice.length > i) { availdice[i].animatereroll(rand([1|2|3|4|5|6]) | self.screenposition());  } } }
Limit Mirror,-9 [heart][;] roll 3 new dice,,pierceattackself(9); sfx(~_heal~); givedice(rand([1|2|3|4|5|6])|rand([1|2|3|4|5|6])|rand([1|2|3|4|5|6]));
Copyright Strike,[lock]Counter with nearest dice,,if(!self.isplayer) { self.textparticle(~No effect!~); } else { var proximy = self.getskillcard().y + (self.getskillcard().height / 2) - 132; var proximx = self.getskillcard().x + (self.getskillcard().width / 2) - 110; var dicelist = []; for(mydice in self.dicepool) { if(mydice.available()) { dicelist.push(mydice); } } if(dicelist.length != 0) { var proxlist = []; for(mydice in dicelist) { proxlist.push(((mydice.x - proximx) * (mydice.x - proximx)) + ((mydice.y - proximy) * (mydice.y - proximy))); if(proxlist[proxlist.length - 1] < 0) { proxlist[proxlist.length - 1] = proxlist[proxlist.length - 1] * -1; } } var min = [0|999999999999999999999]; for(prox in proxlist) { trace(prox); trace(min[1]); trace(~---~); if(prox < min[1]) { min[1] = prox; min[0] = proxlist.indexOf(prox); } } inflict(~counter_~ + dicelist[min[0]].basevalue); sfx(~_magic~); } else { self.textparticle(~No dice!~); } }
Everywhere You Look,Roll a full house,,var randlist = [1|2|3|4|5|6]; var dicelist = []; shuffle(randlist); dicelist.push(randlist[0]); dicelist.push(randlist[1]); var giveorder = [0|0|0|1|1]; shuffle(giveorder); givedice([dicelist[giveorder[0]]|dicelist[giveorder[1]]|dicelist[giveorder[2]]|dicelist[giveorder[3]]|dicelist[giveorder[4]]]); /*this sucks*/
Curved Mirror,Get random amt. of dice,,var r = rand([1|2|2|3|3|3|4|4|5]); var dicelist = []; for(i in 0...r) { dicelist.push(rand([1|2|3|4|5|6])); } givedice(dicelist);
Rejuvenate,Heal a random amount,,var r = rand([1|2|2|3|3|3|4|4|5]); attackself(-r); sfx(~_heal~);
Double Whammy,Reroll 2 lowest dice,,if(self.dicepool.length > 0) { for(i in 1...3) { var dicelist = []; for(mydice in self.dicepool) { if(mydice.available() && !mydice.intween()) { dicelist.push(mydice); } } if(dicelist.length < 1) { break; } if(dicelist.length == 1) { sfx(~diceroll~); dicelist[0].animatereroll(rand([1|2|3|4|5|6])|self.screenposition()); break; } sfx(~diceroll~); dicelist.sort(function(a|b) return a.basevalue - b.basevalue); for(mydice in dicelist) { if(mydice.basevalue > dicelist[0].basevalue) { dicelist.remove(mydice); } } var dicelistcopy = dicelist.copy(); for(mydice in dicelist) { if(mydice.burn) { dicelist.remove(mydice); } } for(mydice in dicelist) { if(mydice.blind) { dicelist.remove(mydice); } } if(dicelist.length > 0) {  dicelist[0].animatereroll(rand([1|2|3|4|5|6])|self.screenposition()); } else { dicelist = dicelistcopy.copy(); for(mydice in dicelist) { if(mydice.blind) { dicelist.remove(mydice); } } if(dicelist.length > 0) {  dicelist[0].animatereroll(rand([1|2|3|4|5|6])|self.screenposition()); } else { dicelist = dicelistcopy.copy(); for(mydice in dicelist) { if(mydice.burn) { dicelist.remove(mydice); } } if(dicelist.length > 0) {  dicelist[0].animatereroll(rand([1|2|3|4|5|6])|self.screenposition()); } else { dicelist = dicelistcopy.copy(); if(dicelist.length > 0) { dicelist[0].animatereroll(rand([1|2|3|4|5|6])|self.screenposition()); } } } } } }
Safeguard,Shield a random amount,,var r = rand([2|3|3|3|3|4|4|5]); inflictself(SHIELD|r); sfx(~_shield~);
Sustainability,Gain [recycle]3 (once),,inflictself(REEQUIPNEXT|3); if(!self.isplayer) var self = target; Gadget.changegadget(self| ~Sustainability~| ~Broken Gadget~); sfx(~_recycle~);
Limit Broke,No effect,,donothing();
Glisten,Gain [mana]2 mana,,inflictself(MANA|2); sfx(~_mana~);
Down Low,Boost jinxes by 1 turn,,boostjinxcountdowns(self| 1); boostjinxcountdowns(target| 1);
Health Pack,Heal [heal]16 (once),,attackself(-16); sfx(~_heal~); if(!self.isplayer) var self = target; Gadget.changegadget(self| ~Health Pack~| ~Broken Gadget~);
ncr Limit Enforcer,Internal limit break correction,,trace(target); var standardscripttoself = ~trace(self.getvar(\~myenforcedlimit\~)); self.changelimitbreak(self.getvar(\~myenforcedlimit\~)); var limbroke = new elements.Skill(\~Limit Broke\~); self.alternatelimitbreak = limbroke; var superenforce = new elements.Skill(\~ncr Cyber Limit Enforcer self\~); superenforce.execute(self|target);~; var standardscripttotarget = ~trace(target.getvar(\~myenforcedlimit\~)); target.changelimitbreak(target.getvar(\~myenforcedlimit\~)); var limbroke = new elements.Skill(\~Limit Broke\~); target.alternatelimitbreak = limbroke; var superenforce = new elements.Skill(\~ncr Cyber Limit Enforcer target\~); superenforce.execute(self|target);~; var ascheckscripttoself = ~trace(self.getvar(\~myenforcedlimit\~)); if(getstatusself(\~alternate_silence\~) == 0) { self.changelimitbreak(self.getvar(\~myenforcedlimit\~)); } var limbroke = new elements.Skill(\~Limit Broke\~); self.alternatelimitbreak = limbroke; var superenforce = new elements.Skill(\~ncr Cyber Limit Enforcer self\~); superenforce.execute(self|target);~; var ascheckscripttotarget = ~trace(target.getvar(\~myenforcedlimit\~)); if(getstatus(\~alternate_silence\~) == 0) { target.changelimitbreak(target.getvar(\~myenforcedlimit\~)); } var limbroke = new elements.Skill(\~Limit Broke\~); target.alternatelimitbreak = limbroke; var superenforce = new elements.Skill(\~ncr Cyber Limit Enforcer target\~); superenforce.execute(self|target);~; if(target != null) { trace(~blahhh~); if(self.isplayer) { self.scriptbeforestartturn = ascheckscripttoself + self.scriptbeforestartturn; self.scriptaftercombat = standardscripttoself + self.scriptaftercombat; self.scriptbeforecombat = ~target.scriptbeforestartturn = \~trace(target.getvar(\\\~myenforcedlimit\\\~)); target.changelimitbreak(target.getvar(\\\~myenforcedlimit\\\~)); var limbroke = new elements.Skill(\\\~Limit Broke\\\~); target.alternatelimitbreak = limbroke;\~ + target.scriptbeforestartturn;~ + standardscripttoself + self.scriptbeforecombat; target.scriptbeforestartturn = standardscripttotarget + target.scriptbeforestartturn; } else { target.scriptbeforestartturn = ascheckscripttoself + target.scriptbeforestartturn; target.scriptaftercombat = standardscripttoself + target.scriptaftercombat; target.scriptbeforecombat = standardscripttoself + target.scriptbeforecombat; self.scriptbeforestartturn = standardscripttotarget + self.scriptbeforestartturn; } } else { trace(~bassaaahhh~);  self.scriptbeforestartturn = ascheckscripttoself + self.scriptbeforestartturn; self.scriptaftercombat = standardscripttoself + self.scriptaftercombat; self.scriptbeforecombat = ~target.scriptbeforestartturn = \~trace(target.getvar(\\\~myenforcedlimit\\\~)); target.changelimitbreak(target.getvar(\\\~myenforcedlimit\\\~)); var limbroke = new elements.Skill(\\\~Limit Broke\\\~); target.alternatelimitbreak = limbroke;\~ + target.scriptbeforestartturn;~ + standardscripttoself + self.scriptbeforecombat; }
ncr Cyber Limit Enforcer self,Further internal limit break correction,,var j = self.limitbreak.script.split(~Gadget.changegadget(self| \~~ + self.limitbreak.name + ~\~| \~Broken Gadget~); if(j.length > 1) { self.limitbreak.script = j.join(~self.changelimitbreak(\~Limit Broke~); } var l = self.limitbreak.script.split(~Gadget.changegadget(self | \~~ + self.limitbreak.name + ~\~|~); if(l.length > 1) { self.limitbreak.script = l.join(~self.changelimitbreak(\~~); } var h = self.limitbreak.script.split(~var proximy = self.getskillcard().y + (self.getskillcard().height / 2) - 132; var proximx = self.getskillcard().x + (self.getskillcard().width / 2) - 110;~); if(h.length > 1) { self.limitbreak.script = h.join(~var proximy = self.y + 335; var proximx = self.x + 960;~); }
ncr Cyber Limit Enforcer target,Further internal limit break correction,,var j = target.limitbreak.script.split(~Gadget.changegadget(self| \~~ + target.limitbreak.name + ~\~| \~Broken Gadget~); if(j.length > 1) { target.limitbreak.script = j.join(~self.changelimitbreak(\~Limit Broke~); } var l = target.limitbreak.script.split(~Gadget.changegadget(self | \~~ + target.limitbreak.name + ~\~|~); if(l.length > 1) { target.limitbreak.script = l.join(~self.changelimitbreak(\~~); } var h = target.limitbreak.script.split(~var proximy = self.getskillcard().y + (self.getskillcard().height / 2) - 132; var proximx = self.getskillcard().x + (self.getskillcard().width / 2) - 110;~); if(h.length > 1) { target.limitbreak.script = h.join(~var proximy = self.y + 335; var proximx = self.x + 960;~); }
Trinity,+3 to a random dice,,var extradice = []; var availdice = []; for (mydice in self.dicepool){ if (mydice.available()){ availdice.push(mydice); } } if(availdice.length > 0) { sfx(~diceroll~); var randdice = rand(availdice); if((randdice.basevalue + 3) > 6) { randdice.animatereroll(6| self.screenposition()); extradice.push(randdice.basevalue - 3); } else { randdice.animatereroll(randdice.basevalue + 3| self.screenposition()); } givedice(extradice); }
Rubber Bullet,[sword]2[;] 10% chance: [sword]10,,var odds = 10; if(getstatusself(~luck~) > 0){ odds = 20; } if(getstatusself(~luck+~) > 0){ odds = 100; }   if(chance(odds)) { self.textparticle(~Success!~); attack(10); sfxdamage(target|10); } else{ attack(2); sfxdamage(target|2); }
Rollout,Reroll a random amount,,var dicelist = []; for(mydice in self.dicepool) { if(mydice.available()) { dicelist.push(mydice); } } var numlist = []; if(dicelist.length > 0) { sfx(~diceroll~); dicelist = shuffle(dicelist); numlist = [0]; for(i in 0...dicelist.length) { numlist.push(numlist[numlist.length - 1] + 1); } numlist.shift(); var r = rand(numlist); for(i in 0...r) { dicelist[i].animatereroll(rand([1|2|3|4|5|6]) | self.screenposition()); } }
Guitar Solo,[weaken]1 per 2 items used (<var:invgadgets_eqsused_display>),,if(self.getvar(~invgadgets_eqsused_display~) > 0) { inflict(WEAKEN|self.getvar(~invgadgets_eqsused_display~)); sfx(~_weaken~); } else { self.textparticle(~No effect!~); } /*all the gadgetroll string-modification weirdness wasn't even necessary oops*/
Super Hexahedron,Roll 6 new dice (once),,var rolllist = []; for(i in 0...6) { rolllist.push(rand([1|2|3|4|5|6])); } givedice(rolllist); if(!self.isplayer) var self = target; Gadget.changegadget(self| ~Super Hexahedron~| ~Broken Gadget~);
Discharge,[shock]1 per 2 items used (<var:invgadgets_eqsused_display>),,if(self.getvar(~invgadgets_eqsused_display~) > 0) { inflict(SHOCK|self.getvar(~invgadgets_eqsused_display~)); sfx(~_shock~); } else { self.textparticle(~No effect!~); }
Silence Handler,Internal skill used to deal with inflicting custom silence.,,/*var scripttoinject = ~if(getstatusself(\~alternate_ncr_silence\~) > 0 && self.equipment.length > 0) { var righteq = self.equipment[self.equipment.length - 1]; righteq.downgrade(); righteq.animate(\~flashandshake\~); righteq.animation[righteq.animation.length - 1].addcommand(\~textparticle\~[;] \~[silence] Silenced!\~[;] 16777215); sfx(\~apply_silence_to_equipment\~); } else if(getstatusself(\~ncr_silence\~) > 0 && self.equipment.length > 0) { self.equipment[self.equipment.length - 1].shockedsetting = 0; self.equipment[self.equipment.length - 1].animate(\~silence\~); }~; trace(target.scriptonstartturn.indexOf(scripttoinject)); if(target.scriptonstartturn.indexOf(scripttoinject) == -1) target.scriptonstartturn = scripttoinject + target.scriptonstartturn;*/
Boltzmann Brain,Mimic a random gadget,,var gadgpool = loadtext(~ncrmod/boltzmannbrainrandomgadget~); if(chance(33)) gadgpool.push(~Broken Gadget~); if(target.dice + target.extradice > 1 && self.dice + self.extradice > 1) gadgpool.push(~Plexiglass~); if(self.getvar(~invgadgets_eqsused_display~) > 0) { gadgpool.push(~Guitar Solo~); gadgpool.push(~Discharge~); } gadgpool = shuffle(gadgpool); var emulategadget = new elements.Skill(gadgpool[0]); if(emulategadget.name == ~Gadget Roll~) { var availdice = []; for (mydice in self.dicepool){ if (mydice.available()){ availdice.push(mydice); } } if(availdice.length > 0) { trace(~hi~); shuffle(availdice); availdice[0].animatereroll(rand([1|2|3|4|5|6]) | self.screenposition()); sfx(~diceroll~); } } else { emulategadget.execute(self|target); } if(!self.isplayer) var self = target; self.getskillcard().animation = []; self.getskillcard().animate(~particleblah~); self.getskillcard().animation[0].addcommand(~textparticle~[;] emulategadget.name + ~!~[;] 16777215);
Pure Evil,[sword]7 dmg (passive: get [curse]1[]),,attack(7); sfxdamage(target|7);
Embrace,Double HP for both (once),,attackself(-self.hp); attack(-target.hp); sfx(~_heal~); if(!self.isplayer) var self = target; Gadget.changegadget(self| ~Embrace~| ~Broken Gadget~);
Anthrax,Poison a random amount,,var r = rand([1|1|2|2|2|2|3|3|4|5]); inflict(POISON| r); sfx(~_poison~);
Omegaflip,Flip dice under 4,,var c = 0; for (mydice in self.dicepool){ if (mydice.available() && mydice.basevalue < 4){ mydice.animatereroll((7 - mydice.basevalue)| self.screenposition()| c * 0.05); c++; } } sfx(~useitem~);
Comedy,Error [ncr_error]1 card,,inflict(~ncr_error~); sfx(~roboterror~);
Best Friend,[]+1 dice[;] forever (once),,self.dice++; if(!self.isplayer) var self = target; Gadget.changegadget(self| ~Best Friend~| ~Broken Gadget~); sfx(~permadice~);
Identity Crisis,Become Warrior (once),,if(!self.isplayer) { self.textparticle(~No effect!~); } else { var s = new elements.Skill(~Against all odds_old~); s.script = ~switchenemy(target|rand(getenemy(-1|[\~Sorceress\~])));~; s.execute(target|self); }
N/A,Consumed upon entering battle,,self.textparticle(~HOWD YOU DO THIS~); self.y += 999;
lolsorandom,Reroll an active item,,if(self.equipment.length > 0 && self.layout != ~DECK~) {  var eqlist = []; for(eq in self.equipment) { if(eq.skillcard == ~~ && eq.isready(true) && !eq.temporary_thisturnonly && eq.onscreen()) { eqlist.push(eq); } }  if(eqlist.length > 0) for(eq in eqlist) { trace(eq.name); trace(eq.row); trace(eq.column); }  if(eqlist.length > 0) {  var choseneq = rand(eqlist);   var smallorlarge = ~small~;      if(choseneq.size > 1) {       smallorlarge = ~large~;      }    var exceptions = [~skillcard~|~excludefromrandomlists~|~alternateversion~|~robotonly~|~witchonly~|~inventoronly~|~onceperbattle~|~jester~]; if(self.usecpuinsteadofdice) exceptions.remove(~robotonly~); if(self.getskillcard().skillcard == ~witch~) exceptions.remove(~witchonly~); if(self.getskillcard() != null && self.getskillcard().skillcard == ~inventor~) exceptions.remove(~inventoronly~);  var neweq = new elements.Equipment(rand(getequipmentlist(null|[smallorlarge]|exceptions)));      neweq.row = choseneq.row; neweq.column = choseneq.column; neweq.x = choseneq.x;      neweq.y = choseneq.y;      self.equipment[self.equipment.indexOf(choseneq)] = neweq;      var dobefcombscript = new elements.Skill(~Against all odds_old~);      dobefcombscript.script = neweq.scriptbeforecombat;      dobefcombscript.execute(self|target);      var dobefturnscript = new elements.Skill(~Against all odds_old~);      dobefturnscript.script = neweq.scriptbeforestartturn;      dobefturnscript.execute(self|target); var doonturnscript = new elements.Skill(~Against all odds_old~); doonturnscript.script = neweq.scriptonstartturn; doonturnscript.execute(self|target);      neweq.animate(~flashandshake~); sfx(~upgradeequipment~);  } else { self.textparticle(~No effect!~); }      } else {      self.textparticle(~No effect!~);     }     trace(~--~); for(eq in self.equipment) { trace(eq.name); trace(eq.row); trace(eq.column); }
Oh Shit!,Take [sword]1 damage,,attackself(1); sfxdamage(self|1);
Disk Cleanup,Set CPU to 0,,adjustrobotcounter(-self.roll_total); sfx(~jackpot_reducecounter~);
Disk Partitioning,Decrease CPU by half,,adjustrobotcounter(-(self.roll_total / 2)); sfx(~jackpot_reducecounter~);
Broken Gadget[],Inflict [confuse]Confuse,,inflict(CONFUSE); sfx(~_confuse~);
Vroom,Gain [ncr_car]2 cars,,inflictself(~ncr_car~|2); sfx(~car~);
Pet Peeve,Gain [fury]2 fury (once),,inflictself(FURY|2); sfx(~_fury~); sfx(~_fury~|~~|0.2); if(!self.isplayer) var self = target; Gadget.changegadget(self| ~Pet Peeve~| ~Broken Gadget~);
Bling,Do [sword]1 per gold (once),,sfx(~pickupgold~); sfxdamage(target|self.gold); attack(self.gold); if(!self.isplayer) var self = target; Gadget.changegadget(self| ~Bling~| ~Broken Gadget~);
Improvise,Get a temporary random item,,giveequipment(rand(getequipmentlist(null|[]|[~skillcard~|~excludefromrandomlists~|~robotonly~|~witchonly~|~onceperbattle~|~alternateversion~])));
Heck Off,Set your HP to 0,,self.hp = 0; self.reducehp(0);
